'From Squeak6.0 of 5 July 2022 [latest update: #22104] on 6 July 2022 at 9:04:15 am'!BookMorph subclass: #StoryboardBookMorph	instanceVariableNames: 'alansSliders panAndTiltFactor zoomFactor zoomController'	classVariableNames: ''	poolDictionaries: ''	category: 'MorphicExtras-Books'!!StoryboardBookMorph methodsFor: 'initialization' stamp: 'ct 6/16/2022 17:46' prior: 91247064!intoWorld: world	zoomController openInWorld.! !SHTextStyler subclass: #SHTextStylerST80	instanceVariableNames: 'classOrMetaClass workspace font parser formatAssignments environment sourceMap processedSourceMap pixelHeight attributesByPixelHeight parseAMethod context'	classVariableNames: 'EnforceItalicEmphasisInComments SyntaxHighlightingAsYouTypeAnsiAssignment SyntaxHighlightingAsYouTypeLeftArrowAssignment TextAttributesByPixelHeight'	poolDictionaries: ''	category: 'ShoutCore-Styling'!!SHTextStylerST80 methodsFor: 'style table' stamp: 'mt 7/3/2022 11:58' prior: 85155933!createTextAttributesForPixelHeight: aNumber	| result |	 	result := IdentityDictionary new.	result at: #default put: {}. "Required as fall-back for non-existing attributes."		self class themeProperties do: [:each |		| spec element emphasis font color |		element := each first.		spec := self userInterfaceTheme perform: element.		spec isArray ifFalse: [spec := {spec}]. "Support color-only hints."				color := spec first ifNotNil: [:colorSpec | Color colorFrom: colorSpec].		emphasis := spec at: 2 ifAbsent:[nil].		font := spec at: 3 ifAbsent: [nil].				(element == #comment and: [self class enforceItalicEmphasisInComments])			ifTrue: [				emphasis					ifNil: [emphasis := TextEmphasis italic]					ifNotNil: [						emphasis isArray							ifFalse: [emphasis := {emphasis}, {TextEmphasis italic}]							ifTrue: [emphasis := emphasis, {TextEmphasis italic}].				emphasis := emphasis asSet asArray "no double italic"]].				"Support for named text styles."		font isString ifTrue: [			| textStyle |			textStyle := TextStyle named: font.			font := textStyle ifNotNil: [textStyle fontOfSize: aNumber]].		(self createAttributeArrayForColor: color emphasis: emphasis font: font)			ifNotEmpty: [:attrArray | result at: element put: attrArray]].	^ result! !!SHTextStylerST80 commentStamp: 'tween 8/27/2004 10:55' prior: 0!I style Smalltalk methods and expressions.My 'styleTable' class instance var holds an array ofArrays which control how each token is styled/coloured. See my defaultStyleTable class method for its structure.My styleTable can be changed by either modifying the defaultStyleTable class method and then executing SHTextStylerST80 initialize ; or by giving me a new styleTable through my #styleTable: class method.My 'textAttributesByPixelSize' class instance var contains a dictionary of dictionaries.	The key is a pixelSize and the value a Dictionary from token type Symbol to TextAttribute array.	It is created/maintained automatically.	I also install these 3 preferences when my class initialize method is executed....	#syntaxHighlightingAsYouType  - controls whether methods are styled in browsers	#syntaxHighlightingAsYouTypeAnsiAssignment - controls whether assignments are formatted to be :=	#syntaxHighlightingAsYouTypeLeftArrowAssignment - controls whether assignments are formatted to be _I reimplement #unstyledTextFrom: so that TextActions are preserved in the unstyled text 					 	!SHTextStylerST80 class	instanceVariableNames: ''!!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'mt 7/3/2022 11:56'!enforceItalicEmphasisInComments	<preference: 'Enforce Italic in Comments'		categoryList: #(browsing Accessibility)		description: 'When enabled, always typeset source-code comments in italic, regardless of the current UI theme. When disabled, depend on what the current UI theme prescribes as text attributes for such comments.'		type: #Boolean>	^ EnforceItalicEmphasisInComments ifNil: [true]! !!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'mt 7/3/2022 11:50'!enforceItalicEmphasisInComments: aBooleanOrNil	EnforceItalicEmphasisInComments = aBooleanOrNil ifTrue: [^ self].	EnforceItalicEmphasisInComments := aBooleanOrNil.	self userInterfaceTheme apply. "Invalidate all styling caches."	! !Morph subclass: #SketchMorph	instanceVariableNames: 'originalForm rotationStyle scalePoint framesToDwell rotatedForm keepAspectRatio'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!SketchMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45' prior: 88092522!reduceColorPalette: evt	"Let the user ask for a reduced number of colors in this sketch"	| str nColors |	str := UIManager default		request: 'Please enter a number greater than one.(note: this cannot be undone, so answer zeroto abort if you need to make a backup first)' translated		initialAnswer: '256'.	nColors := Integer readFrom: (ReadStream on: str).	(nColors between: 2 and: 256) ifFalse: [^ self].	originalForm := originalForm copyWithColorsReducedTo: nColors.	rotatedForm := nil.	self changed! !AlignmentMorph subclass: #PluggablePanelMorph	instanceVariableNames: 'model getChildrenSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!PluggablePanelMorph methodsFor: 'update' stamp: 'ct 7/4/2022 18:39' prior: 63531534!update: selectorSymbolOrNil	selectorSymbolOrNil ifNil: [^ self].	selectorSymbolOrNil = getChildrenSelector ifTrue: [		self rebuildPaneAfter: [			| children |			children := self children.			self				 removeAllMorphs;				 addAllMorphs: children.			self containingWindow ifNotNil: [:window |				children do: [:child |					child adoptPaneColor: window paneColor]].						"Let my children take all the place unless my extent is described by them."			self hResizing ~~ #shrinkWrap ifTrue:				[self submorphsDo: [:m | m hResizing: #spaceFill]].			self vResizing ~~ #shrinkWrap ifTrue:				[self submorphsDo: [:m | m vResizing: #spaceFill]].						"Tell dependents about this update. There is no pluggable notification for changed submorphs."			self changed: #submorphs]].! !!PluggablePanelMorph methodsFor: 'private' stamp: 'ct 7/5/2022 09:25'!rebuildPaneAfter: replacePaneMorphsBlock	"Performance. Reset layout properties during children update to avoid intermediate relayouting."	| cellGap wantsGrips wantsPaneSplitters |	self flag: #duplication. "See PluggableSystemWindow>>#rebuildPaneAfter: and MorphicToolBuilder>>#buildPluggableWindow:."		cellGap := self cellGap.	wantsGrips := self wantsGrips.	wantsPaneSplitters := self wantsPaneSplitters.		self cellGap: 0.	self wantsPaneSplitters: false; wantsGrips: false.	self removePaneSplitters; removeGrips.		^ replacePaneMorphsBlock ensure: [		wantsPaneSplitters ifTrue: [			self wantsPaneSplitters: wantsPaneSplitters.			self addPaneSplitters].		wantsGrips ifTrue: [			self wantsGrips: wantsGrips.			self addGrips].		self cellGap: cellGap]! !PluggableTextMorph class	instanceVariableNames: ''!!PluggableTextMorph class methodsFor: 'preferences' stamp: 'mt 7/4/2022 17:54' prior: 63708005!applyUserInterfaceTheme	self flushAdornmentCache.	TextEditor withAllSubclassesDo: [:cls |		cls initializeYellowButtonMenu.		cls initializeShiftedYellowButtonMenu].! !Morph subclass: #DialogWindow	instanceVariableNames: 'titleMorph messageMorph paneMorph buttonRow result selectedButton cancelButton timeout preferredPosition keyMap exclusive filter filterEnabled filterMorph autoCancel'	classVariableNames: 'GradientDialog IncludeCloseButton IncludeControlMenu RoundedDialogCorners UseWiggleAnimation'	poolDictionaries: ''	category: 'Morphic-Windows'!!DialogWindow methodsFor: 'initialization' stamp: 'mt 7/4/2022 18:09' prior: 26125052!setMessageParameters	| fontToUse colorToUse margins |	messageMorph ifNil: [^ self].	fontToUse := self userInterfaceTheme font ifNil: [TextStyle defaultFont].	colorToUse := self userInterfaceTheme textColor ifNil: [Color black].	margins := (TextStyle pointsToPixels: 5) truncated.	messageMorph		margins: (self wantsRoundedCorners			ifTrue: [margins @ (margins - self cornerRadius) corner: margins @ margins]			ifFalse: [margins]);		textColor: colorToUse;		textStyle: fontToUse asNewTextStyle. "Use style with other point sizes available"			"Style read-only text for copy interaction."	self flag: #todo. "mt: Duplication with PluggableTextMorph >> #setDefaultParameters"	(UserInterfaceTheme current get: #caretColor for: #PluggableTextMorph)		ifNotNil: [:c | messageMorph caretColor: c].	(UserInterfaceTheme current get: #selectionColor for: #PluggableTextMorph)		ifNotNil: [:c | 			self userInterfaceTheme color = (UserInterfaceTheme current get: #color for: #PluggableTextMorph)				ifTrue: [messageMorph selectionColor: c]				ifFalse: [					"Background is different than in a text field. Use dialog-title color to ensure contrast."					messageMorph selectionColor: self userInterfaceTheme titleColor]].! !SystemWindow subclass: #PluggableSystemWindow	instanceVariableNames: 'getLabelSelector getChildrenSelector closeWindowSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!PluggableSystemWindow methodsFor: 'updating' stamp: 'ct 7/4/2022 18:54' prior: 63554011!update: what	what ifNil:[^self].	what == getLabelSelector ifTrue:[self setLabel: (model perform: getLabelSelector)].	what == getChildrenSelector ifTrue: [		self rebuildPaneAfter: [			paneMorphs ifNil: [paneMorphs := #()].			self removeAllMorphsIn: paneMorphs.			paneMorphs := model perform: getChildrenSelector.			self addAllMorphs: paneMorphs.			paneMorphs do: [:child |				child adoptPaneColor: self paneColor].			paneMorphs do: [:m | m hResizing: #spaceFill; vResizing: #spaceFill]]].	what == #windowColorToUse ifTrue: [		self paneColor = model windowColorToUse ifFalse:			[self refreshWindowColor]].	^super update: what! !!PluggableSystemWindow methodsFor: 'private' stamp: 'ct 7/5/2022 09:25'!rebuildPaneAfter: replacePaneMorphsBlock	"Performance. Reset layout properties during children update to avoid intermediate relayouting."	| cellGap wantsGrips wantsPaneSplitters |	self flag: #duplication. "See PluggablePanelMorph>>#rebuildPaneAfter: and MorphicToolBuilder>>#buildPluggableWindow:."		cellGap := self cellGap.	wantsGrips := self wantsGrips.	wantsPaneSplitters := self wantsPaneSplitters.		self cellGap: 0.	self wantsPaneSplitters: false; wantsGrips: false.	self removePaneSplitters; removeGrips.		^ replacePaneMorphsBlock ensure: [		wantsPaneSplitters ifTrue: [			self wantsPaneSplitters: wantsPaneSplitters.			self addPaneSplitters].		wantsGrips ifTrue: [			self wantsGrips: wantsGrips.			self addGrips].		self cellGap: cellGap]! !!PluggableSystemWindow commentStamp: 'ar 2/11/2005 20:14' prior: 0!A pluggable system window. Fixes the issues with label retrieval and adds support for changing children.!ToolBuilder subclass: #MorphicToolBuilder	instanceVariableNames: 'widgets panes parentMenu'	classVariableNames: 'ButtonBorderWidth ButtonMargins ListBorderWidth ListMargins TextBorderWidth TextMargins'	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!MorphicToolBuilder methodsFor: 'widgets required' stamp: 'ct 7/4/2022 18:45' prior: 58453963!buildPluggablePanel: aSpec	| widget |	widget := self panelClass new.	self register: widget id: aSpec name.	widget model: aSpec model.	"Set child dependent layout properties."	self setLayoutHintsFor: widget spec: aSpec.	widget layoutInset: (aSpec padding ifNil: [self panelPadding]).	widget wantsPaneSplitters: (aSpec wantsResizeHandles ifNil: [false]).	"widget wantsGrips: true."	widget cellGap: (aSpec spacing ifNil: [		widget wantsPaneSplitters			ifTrue: [self windowSpacing]			ifFalse: [self panelSpacing]]).		"Now create the children."	aSpec children isSymbol		ifTrue: [			widget getChildrenSelector: aSpec children.			widget update: widget getChildrenSelector]		ifFalse: [			widget rebuildPaneAfter: [				self buildAll: aSpec children in: widget]].		self setFrame: aSpec frame in: widget.	self setLayout: aSpec layout in: widget.		parent ifNotNil:[self add: widget to: parent].	widget borderWidth: 0.	self buildHelpFor: widget spec: aSpec. 	widget color: Color transparent.		^ widget! !!MorphicToolBuilder methodsFor: 'widgets required' stamp: 'ct 7/4/2022 18:39' prior: 58515854!buildPluggableWindow: aSpec	| widget |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec) new.	self register: widget id: aSpec name.		widget model: aSpec model.	"Set child dependent layout properties."	MorphicProject worldGridEnabled ifTrue: [		"Snap both #position and #extent to grid."		aSpec horizontalResizing ifNil: [aSpec horizontalResizing: #spaceFill].		aSpec verticalResizing ifNil: [aSpec verticalResizing: #spaceFill]].			self setLayoutHintsFor: widget spec: aSpec.	widget layoutInset: (aSpec padding ifNil: [self windowPadding]).	widget morphicLayerNumber: widget class windowLayer.		self flag: #todo. "ct: Below, there is a lot of duplication with #buildPluggablePanel:. Can we factor out some of this, or even just collect all children in a PluggablePanelMorph?"	widget cellGap: (aSpec spacing ifNil: [self windowSpacing]).	widget wantsGrips: true.	widget wantsPaneSplitters: (aSpec wantsResizeHandles ifNil: [true]).		"Now create the children."	panes := OrderedCollection new.	aSpec children isSymbol		ifTrue: [			widget getChildrenSelector: aSpec children.			widget update: aSpec children]		ifFalse: [			widget rebuildPaneAfter: [				self buildAll: aSpec children in: widget]].	widget setUpdatablePanesFrom: panes.	aSpec defaultFocus ifNotNil: [:name |		widget defaultFocusMorph: name].		aSpec label ifNotNil: [:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	widget closeWindowSelector: aSpec closeAction.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: ((aSpec extent ifNil:[widget initialExtent]) * RealEstateAgent windowScaleFactor * RealEstateAgent scaleFactor) rounded		world: self currentWorld).	widget refreshWindowColor.	^ widget! !TerseGuideHelp class	instanceVariableNames: ''!!TerseGuideHelp class methodsFor: 'pages' stamp: 'mt 7/4/2022 09:32' prior: 98475106!block	"This method was automatically generated. Edit it using:"	"TerseGuideHelp edit: #block"	<generated>	^(HelpTopic		title: 'Blocks'		contents: '"Blocks: - blocks are objects and may be assigned to a variable - value is last expression evaluated unless explicit return - blocks may be nested - specification -         [ arguments | | localvars | expressions ] - ^ expression terminates block & method (exits all nested blocks) - blocks intended for long term storage should not contain ^,	as they can not return to the sender context - use #cull: (and #cull:cull:...) if you do not know the exact number of arguments - blocks (along with polymorphism on booleans) are the basis of control structures	-> See Conditional Expressions"| x y z fac |x := [ y := 1. z := 2. ]. x value.							"simple block usage"x := [ :argOne :argTwo |   argOne, '' and '' , argTwo.].	"set up block with argument passing"Transcript show: (x value: ''First'' value: ''Second''); cr.	"use block with argument passing"x := [:e | | v | v := 1. e + v] value: 2.					"local variable in a block"fac := [ :n | n > 1 ifTrue:  [n * (fac value: n-1)] ifFalse: [1]].	"closure on block variable"fac value: 5.											"closure variable scoped to its block"!!' readStream nextChunkText)			key: #block;			shouldStyle: true;			yourself! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'mt 7/4/2022 09:26'!conditionalExpression	"This method was automatically generated. Edit it using:"	"TerseGuideHelp edit: #conditionalExpression"	<generated>	^(HelpTopic		title: 'Conditional Expression'		contents: '"Conditional Expressions: - Conditional expressions, or control structures in general, use	blocks as deferred computations which can be evaluated	selectively"| x switch result |x := 11.x > 10 ifTrue: [Transcript show: ''ifTrue''; cr].		"if then"x > 10 ifFalse: [Transcript show: ''ifFalse''; cr].	"if else"x > 10											"if then else"   ifTrue: [Transcript show: ''ifTrue''; cr]   ifFalse: [Transcript show: ''ifFalse''; cr].x > 10											"if else then"   ifFalse: [Transcript show: ''ifFalse''; cr]   ifTrue: [Transcript show: ''ifTrue''; cr].Transcript   show:      (x > 10         ifTrue: [''ifTrue'']         ifFalse: [''ifFalse'']);   cr.Transcript										"nested if then else"   show:      (x > 10         ifTrue: [x > 5            ifTrue: [''A'']            ifFalse: [''B'']]         ifFalse: [''C'']);   cr.switch := Dictionary new.						"switch functionality"switch at: $A put: [Transcript show: ''Case A''; cr].switch at: $B put: [Transcript show: ''Case B''; cr].switch at: $C put: [Transcript show: ''Case C''; cr].result := (switch at: $B) value.!!' readStream nextChunkText)			key: #conditionalExpression;			shouldStyle: true;			yourself! !!TerseGuideHelp class methodsFor: 'accessing' stamp: 'mt 7/4/2022 09:25' prior: 98579526!pages	^ #( introduction transcript assignment constants boolean arithmetic		bitwise conversion block exceptionHandling methodCall conditionalExpression		iterationStatement character string symbol  array orderedCollection		sortedCollection bag set interval association dictionary internalStream		fileStream date time point rectangle pen dynamic metaclass debugging		misc )! !ReleaseBuilder class	instanceVariableNames: ''!!ReleaseBuilder class methodsFor: 'class initialization' stamp: 'mt 7/2/2022 11:38' prior: 84068758!initialize	QAndA ifNil: [self clearQAndA].	"We have to be after AutoStart so that Morphic is up and running."	Smalltalk addToStartUpList: ReleaseBuilder after: AutoStart.	SystemVersion newVersion: 'Squeak6.0'! !Object subclass: #SystemVersion	instanceVariableNames: 'version date highestUpdate updates'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'System-Support'!!SystemVersion methodsFor: 'continuous integration' stamp: 'mt 7/4/2022 17:29' prior: 97443498!ciStatusPageUrl	^ 'https://github.com/squeak-smalltalk/squeak-app/actions/workflows/{1}?query=branch%3A{2}{3}{4}'		format: {			self ciWorkflow.			self ciBranch.			'+is%3Acompleted'. "Show only completed runs."			self isRelease				ifTrue: ['' "Only Trunk has daily builds"]				ifFalse: ['+event%3Aschedule']}! !!SystemVersion methodsFor: 'continuous integration' stamp: 'mt 7/4/2022 10:12' prior: 97446315!ciStatusTimestamp	"Slow. Fetch HTML page, extract first occurrence of		... <time-ago datetime='2021-08-04T14:24:20Z' ... "	| statusResponse statusPage begin end dateAndTime |	statusResponse := WebClient httpGet: self ciStatusPageUrl.	statusResponse isSuccess ifFalse: [^ nil].	statusPage := statusResponse content.	begin := statusPage findString: 'datetime' startingAt: 100000. "Skip the first X bytes decoration."	begin = 0 ifTrue: [^ nil].	end := statusPage findString: 'Z' startingAt: begin.	end = 0 ifTrue: [^ nil].	dateAndTime := DateAndTime readFrom: (statusPage copyFrom: begin + 10 to: end) readStream.	^ String streamContents: [:s |		dateAndTime asDate = Date today			ifTrue: [s nextPutAll: 'Today' translated, ',']			ifFalse: [dateAndTime asDate = Date yesterday				ifTrue: [s nextPutAll: 'Yesterday' translated, ',']				ifFalse: [dateAndTime printYMDOn: s]].		s space.		dateAndTime printHMOn: s]! !Object subclass: #MCMcmUpdater	instanceVariableNames: 'repository updateMapName lastUpdateMap'	classVariableNames: 'DefaultUpdateMap DefaultUpdateURL Registry SkipPackages UpdateFromServerAtStartup UpdateMissingPackages'	poolDictionaries: ''	category: 'MonticelloConfigurations'!!MCMcmUpdater methodsFor: 'accessing' stamp: 'mt 7/2/2022 11:17'!lastUpdateMapAt: repoDescription		^ self lastUpdateMap		at: repoDescription		ifAbsent: [			self lastUpdateMap				at: (self class alternativeDescriptionOf: repoDescription)				ifAbsent: [0]]! !!MCMcmUpdater methodsFor: 'accessing' stamp: 'mt 7/2/2022 11:19'!lastUpdateMapAt: repoDescription put: lastUpdate		self lastUpdateMap at: repoDescription put: lastUpdate.	self lastUpdateMap at: (self class alternativeDescriptionOf: repoDescription) put: lastUpdate.! !!MCMcmUpdater methodsFor: 'updating' stamp: 'mt 7/2/2022 11:00' prior: 53029764!refreshUpdateMapFor: r with: updateList	"Update the lastUpdateMap and answer a possibly reduced updateList"	| config |	(self lastUpdateMapAt: r description) = 0 ifTrue: [		"No update has ever been loaded from this repo. If no package is		present in the image either, we can skip right to the latest config"		config := r versionNamed: updateList last value.		(config dependencies anySatisfy: [:dep | dep package hasWorkingCopy])			ifFalse: [(self useLatestPackagesFrom: r)					ifTrue: [self lastUpdateMapAt: r description put: updateList last key].				updateList isEmpty					ifTrue: [^ #()]					ifFalse: [^ updateList last: 1]]].	^ updateList! !!MCMcmUpdater methodsFor: 'updating' stamp: 'mt 7/2/2022 11:01' prior: 53032870!updateFromRepository	| config repo |	repo := self getRepositoryFromRepositoryGroup.	repo cacheAllFileNamesDuring: [ | updateList |		updateList := self updateListFor: repo.		"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			updateList := self refreshUpdateMapFor: repo with: updateList.			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: ('Processing {1}' translated format: {assoc value}).				config := repo versionNamed: assoc value.				self updateFromConfig: config.				self lastUpdateMapAt: repo description put: assoc key.			] displayingProgress: 'Processing configurations' translated.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			(self useLatestPackagesFrom: repo) ifTrue: [				config updateFromRepositories.				config upgrade].		]].	^ config! !!MCMcmUpdater methodsFor: 'updating' stamp: 'mt 7/2/2022 11:01' prior: 53034943!updateFromRepository: repository upTo: versionNumber	| config |	config := nil.	repository cacheAllFileNamesDuring: [ | updateList |		updateList := self updateListFor: repository.		"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			updateList := self refreshUpdateMapFor: repository with: updateList.			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				assoc key > versionNumber ifTrue: [^config].				ProgressNotification signal: '' extra: ('Processing ' translated format: {assoc value}).				config := repository versionNamed: assoc value.				self updateFromConfig: config.				self lastUpdateMapAt: repository description put: assoc key.			] displayingProgress: 'Processing configurations' translated.		]].	^config! !!MCMcmUpdater methodsFor: 'private' stamp: 'mt 7/2/2022 11:01' prior: 53038788!updateListFor: repo	| updateList allNames minVersion |	updateList := OrderedCollection new.	minVersion := self lastUpdateMapAt: repo description.	"Find all the update-*.mcm files"	allNames := ('Checking {1}' translated format: {repo description})		displayProgressFrom: 0 to: 1 during: [:bar| 			bar value: 0.			repo allFileNamesOrCache ].	allNames do: [:fileName | | version |		((fileName endsWith: '.mcm')			and: [fileName packageAndBranchName = self updateMapName				and: [(version := fileName versionNumber) >= minVersion]]) 					ifTrue: [updateList add: version -> fileName]].	^updateList sort! !MCMcmUpdater class	instanceVariableNames: ''!!MCMcmUpdater class methodsFor: 'registry' stamp: 'mt 7/2/2022 11:17' prior: 53068296!forRepository: repository updateMap: basename	"Answer the requested updater from the repository, or nil of not found"	"MCMcmUpdater forRepository: 'http://source.squeak.org/trunk' updateMap: 'update'"	"MCMcmUpdater forRepository: 'foo' updateMap: 'bar'"	^ ((Registry ifNil: [Registry := Dictionary new])		at: repository		ifAbsent: [Registry at: (self alternativeDescriptionOf: repository) ifAbsent: [^nil]])			at: basename			ifAbsent: [^nil]! !!MCMcmUpdater class methodsFor: 'utilities' stamp: 'mt 7/2/2022 11:16'!alternativeDescriptionOf: repoDescription	"Treat HTTP and HTTPS as the same repository."	(repoDescription beginsWith: 'http:')		ifTrue: [^ 'https', (repoDescription allButFirst: 4)].	(repoDescription beginsWith: 'https:')		ifTrue: [^ 'http', (repoDescription allButFirst: 5)].	^ repoDescription! !----SNAPSHOT----{6 July 2022 . 9:04:15 am} Squeak.image priorSource: 25347!----QUIT----{6 July 2022 . 9:04:16 am} Squeak.image priorSource: 25347!----STARTUP----{25 October 2023 . 6:28:25 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!----QUIT----{25 October 2023 . 6:30:51 am} Squeak6.0-22104-64bit.image priorSource: 25424!----STARTUP----{25 October 2023 . 6:31:04 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!----QUIT----{25 October 2023 . 6:31:37 am} Squeak6.0-22104-64bit.image priorSource: 25603!----STARTUP----{25 October 2023 . 6:31:41 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!SystemOrganization addCategory: #UserObjects!Player subclass: #Player114	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Player subclass: #Player115	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Player subclass: #Player114	instanceVariableNames: 'patch'	classVariableNames: ''	poolDictionaries: ''	category: 'UserObjects'!KedamaExamplerPlayer subclass: #KedamaExamplerPlayer116	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!KedamaTurtleVectorPlayer2 subclass: #KedamaTurtleVectorPlayer2117	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!KedamaSequenceExecutionStub subclass: #KedamaSequenceExecutionStub118	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Player subclass: #Player119	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Player subclass: #Player119	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!1+1!1+1!5+2! Transcript show: 1+1! Transcript show: 1+5!Transcript show: 5+2!Transcript show: 5+2!Transcript show: 5+2!Transcript show: 5+2!Transcript show: 1+1!Transcript show: 1+1!Transcript show: 1+1!Transcript show: 1+1.Transcript show: 1+1!Transcript show: 2+2;cr.Transcript show: 2+2;cr.!Transcript show: 2+2;cr.Transcript show: 2+2;cr.!Transcript show: 2+2;cr.123!Transcript show: 2+2;cr.123!Transcript show: 2/2;cr.Transcript show: 2.0/2;cr.!Transcript show: 1/2;cr.!----QUIT----{25 October 2023 . 6:54:34 am} Squeak6.0-22104-64bit.image priorSource: 25801!----STARTUP----{26 October 2023 . 1:42:35 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!----QUIT----{26 October 2023 . 2:52:05 am} Squeak6.0-22104-64bit.image priorSource: 27646!----STARTUP----{26 October 2023 . 2:52:07 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!----QUIT----{26 October 2023 . 2:52:09 am} Squeak6.0-22104-64bit.image priorSource: 27844!----STARTUP----{27 October 2023 . 2:51:41 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!myScrollPane!----QUIT----{27 October 2023 . 3:07:07 am} Squeak6.0-22104-64bit.image priorSource: 28042!----STARTUP----{27 October 2023 . 3:07:09 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!----SNAPSHOT----{27 October 2023 . 3:13:11 am} Squeak6.0-22104-64bit.image priorSource: 28255!----STARTUP----{27 October 2023 . 3:42:58 am} as C:\Users\1\Desktop\Squeak\Squeak6.0-22104-64bit.image!----SNAPSHOT----{27 October 2023 . 3:44:15 am} Squeak6.0-22104-64bit.image priorSource: 28453!----SNAPSHOT----{27 October 2023 . 3:44:31 am} mine.image priorSource: 28655!----SNAPSHOT----{27 October 2023 . 3:45:29 am} mine.image priorSource: 28751!----SNAPSHOT----{27 October 2023 . 3:45:34 am} mine.image priorSource: 28830!----QUIT----{27 October 2023 . 3:45:53 am} mine.image priorSource: 28909!----STARTUP----{27 October 2023 . 3:46:02 am} as C:\Users\1\Desktop\Squeak\mine.image!----QUIT----{27 October 2023 . 3:46:05 am} mine.image priorSource: 28988!----STARTUP----{27 October 2023 . 3:47:24 am} as C:\Users\1\Desktop\Squeak\mine.image!----QUIT----{27 October 2023 . 3:47:26 am} mine.image priorSource: 29152!----STARTUP----{27 October 2023 . 3:49:33 am} as C:\Users\1\Desktop\Squeak\mine.image!"Game Initialization"!"Game Initialization"!    "Display the game result"!Transcript show: 1+1!Transcript show: 1+1!Transcript show: 1+1!Transcript show: 1+1!Transcript show:'Hello World';cr!Transcript show:'Hello World';cr!Transcript open.!Transcript open.!Transcript open.!Transcript show:'Hello World';cr!Transcript open.Transcript show:'Hello World';cr!Transcript show:'Hello World';cr!Transcript show:'Hello World';cr!----SNAPSHOT----{27 October 2023 . 3:56:34 am} mine.image priorSource: 29316!----SNAPSHOT----{27 October 2023 . 3:56:44 am} mine.image priorSource: 29936!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: 1+1;cr!Transcript show: (5/2+1);cr!Transcript show: 5/2+1;cr!Transcript show: 5*2+1;cr!Transcript show: 5/2+1;cr!Transcript show: 20/2+1;cr!Transcript show: 9/2+1;cr!Transcript show: 2+3*2;cr!Transcript show: 5+3*2;cr!Transcript show: 5+3*2;cr!Transcript show: 5+3*2;cr!Transcript show: 5+3*2;cr!----SNAPSHOT----{27 October 2023 . 4:03:42 am} mine.image priorSource: 30015!----QUIT----{27 October 2023 . 4:03:47 am} mine.image priorSource: 30743!----STARTUP----{27 October 2023 . 4:03:59 am} as C:\Users\1\Desktop\Squeak\mine.image!----QUIT----{27 October 2023 . 4:04:02 am} mine.image priorSource: 30822!----STARTUP----{29 October 2023 . 5:57:02 am} as C:\Users\1\Desktop\Squeak\mine.image!----QUIT----{29 October 2023 . 5:57:29 am} mine.image priorSource: 30986!----STARTUP----{29 October 2023 . 6:01:30 am} as C:\Users\1\Desktop\Squeak\mine.image!----QUIT----{29 October 2023 . 6:01:36 am} mine.image priorSource: 31150!----STARTUP----{29 October 2023 . 6:02:30 am} as C:\Users\1\Desktop\Squeak\mine.image!SystemOrganization addCategory: #'Metacello-Platform'!MCRepository subclass: #MCFilesystemFetchOnlyRepository	instanceVariableNames: 'repoPath projectVersion projectPath projectVersionPattern repositoryReader readonly directory username password'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Platform'!MCFilesystemFetchOnlyRepository class	instanceVariableNames: 'siteUsername sitePassword repoCacheDirectory repoDownloadCache'!!MCFilesystemFetchOnlyRepository commentStamp: 'tobe 5/6/2020 10:02' prior: 0!A MCDownloadRepository is an abstract class that supports loading repositories from a remote location. Subclasses can specify concrete locations and ways to retrieve repositories. Deserialization is handled as a separate step by finding a `self repositoryReader` that knows how to deserialize the downloaded files.Note that this class is essentially a copy of MCGitBasedNetworkRepository with the intent to decouple transport from deserialization.!MCFilesystemFetchOnlyRepository subclass: #MCFetchBitbucketRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Platform'!MCFilesystemFetchOnlyRepository subclass: #MCFetchGithubRepository	instanceVariableNames: ''	classVariableNames: 'ETagsCache'	poolDictionaries: ''	category: 'Metacello-Platform'!Notification subclass: #MCTonelMissing	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Platform'!SystemOrganization addCategory: #'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloCleanNotification	instanceVariableNames: 'version'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!MetacelloCleanNotification subclass: #MetacelloCleanLoadAndTestsNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!MetacelloCleanNotification subclass: #MetacelloCleanLoadNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloClearStackCacheNotification	instanceVariableNames: 'cacheNames'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloErrorInProjectConstructionNotification	instanceVariableNames: 'versionString exception'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloIgnorePackageLoaded	instanceVariableNames: 'packageSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!SystemOrganization addCategory: #'Metacello-Core-Scripts'!Notification subclass: #MetacelloScriptGitBasedDownloadNotification	instanceVariableNames: 'projectPath versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Notification subclass: #MetacelloScriptNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptNotification subclass: #MetacelloResolveProjectUpgrade	instanceVariableNames: 'existingProjectRegistration newProjectRegistration'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowConflictingProjectUpgrade	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowLockedProjectChange	instanceVariableNames: 'operationString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowProjectDowngrade	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowProjectUpgrade	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptNotification subclass: #MetacelloScriptEnsureProjectLoadedForDevelopment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptNotification subclass: #MetacelloScriptProjectSpecNotification	instanceVariableNames: 'projectSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptProjectSpecNotification subclass: #MetacelloLookupBaselineSpecForEnsureLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptProjectSpecNotification subclass: #MetacelloLookupProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloLookupProjectSpec commentStamp: 'dkh 6/1/2012 10:02' prior: 0!**MetacelloLookupProjectSpec** is signalled to allow a handler to substitute a different (equivalent) project spec for fetching or loading purposes!MetacelloScriptProjectSpecNotification subclass: #MetacelloLookupProjectSpecForLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloLookupProjectSpecForLoad commentStamp: 'dkh 6/1/2012 10:55' prior: 0!**MetacelloLookupProjectSpecForLoad** ends up returning an instance of **MetacelloProjectSpecForLoad**!MetacelloScriptProjectSpecNotification subclass: #MetacelloProjectSpecLoadedNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloProjectSpecLoadedNotification commentStamp: 'dkh 6/1/2012 09:32' prior: 0!**MetacelloLoadProjectSpecVersionNotification** is signalled to indicate that the given project spec was loaded into the image.!Notification subclass: #MetacelloSkipDirtyPackageLoad	instanceVariableNames: 'packageSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloStackCacheNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloValidationNotification	instanceVariableNames: 'issue'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!SystemOrganization addCategory: #'Metacello-Help'!PackageAPIHelpBuilder subclass: #MetacelloPackageAPIHelpBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Help'!SystemOrganization addCategory: #'MonticelloFileTree-Core'!MCMczWriter subclass: #MCFileTreeWriter	instanceVariableNames: 'directory packageFileDirectory cachedPackageFileDirectoryEntries'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!HelpBuilder subclass: #MetacelloConfigurationHelpBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Help'!SystemOrganization addCategory: #'Metacello-Core-Model'!Magnitude subclass: #MetacelloSemanticVersionNumber	instanceVariableNames: 'normalVersion preReleaseVersion buildVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!!MetacelloSemanticVersionNumber commentStamp: 'dkh 6/24/2012 18:20' prior: 0!MetacelloSemanticVersionNumber conforms to version 2.0.0-rc.1 of  [Semantic Versioning 2.0.0-rc.1](http://semver.org/)The most important thing that you need to know is that: **A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers.****Semantic Versioning Specification** extracted from [Semantic versioning 2.0.0-rc.1](https://github.com/mojombo/semver/blob/3c7f2e8df747ea0ca15208fdfc90e3275240184f/semver.md):Semantic Versioning Specification (SemVer)------------------------------------------The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD","SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to beinterpreted as described in RFC 2119.1. Software using Semantic Versioning MUST declare a public API. This APIcould be declared in the code itself or exist strictly in documentation.However it is done, it should be precise and comprehensive.1. A normal version number MUST take the form X.Y.Z where X, Y, and Z arenon-negative integers. X is the major version, Y is the minor version, and Zis the patch version. Each element MUST increase numerically by increments ofone. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.1. Once a versioned package has been released, the contents of that versionMUST NOT be modified. Any modifications must be released as a new version.1. Major version zero (0.y.z) is for initial development. Anything may changeat any time. The public API should not be considered stable.1. Version 1.0.0 defines the public API. The way in which the version numberis incremented after this release is dependent on this public API and how itchanges.1. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwardscompatible bug fixes are introduced. A bug fix is defined as an internalchange that fixes incorrect behavior.1. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwardscompatible functionality is introduced to the public API. It MUST beincremented if any public API functionality is marked as deprecated. It MAY beincremented if substantial new functionality or improvements are introducedwithin the private code. It MAY include patch level changes. Patch versionMUST be reset to 0 when minor version is incremented.1. Major version X (X.y.z | X > 0) MUST be incremented if any backwardsincompatible changes are introduced to the public API. It MAY include minorand patch level changes. Patch and minor version MUST be reset to 0 when majorversion is incremented.1. A pre-release version MAY be denoted by appending a hyphen and a series ofdot separated identifiers immediately following the patch version. IdentifiersMUST be comprised of only ASCII alphanumerics and dash [0-9A-Za-z-].Pre-release versions satisfy but have a lower precedence than the associatednormal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,1.0.0-x.7.z.92.1. A build version MAY be denoted by appending a plus sign and a series of dotseparated identifiers immediately following the patch version or pre-releaseversion. Identifiers MUST be comprised of only ASCII alphanumerics and dash[0-9A-Za-z-]. Build versions satisfy and have a higher precedence than theassociated normal version. Examples: 1.0.0+build.1, 1.3.7+build.11.e0f985a.1. Precedence MUST be calculated by separating the version into major, minor,patch, pre-release, and build identifiers in that order. Major, minor, andpatch versions are always compared numerically. Pre-release and build versionprecedence MUST be determined by comparing each dot separated identifier asfollows: identifiers consisting of only digits are compared numerically andidentifiers with letters or dashes are compared lexically in ASCII sort order.Numeric identifiers always have lower precedence than non-numeric identifiers.Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.About-----The Semantic Versioning specification is authored by [TomPreston-Werner](http://tom.preston-werner.com), inventor of Gravatars andcofounder of GitHub.If you'd like to leave feedback, please [open an issue onGitHub](https://github.com/mojombo/semver/issues).License-------Creative Commons - CC BY 3.0http://creativecommons.org/licenses/by/3.0/!MetacelloSemanticVersionNumber subclass: #MetacelloOldSemanticVersionNumber	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!Magnitude subclass: #MetacelloVersion	instanceVariableNames: 'spec versionNumber importedVersions versionStatus'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!SystemOrganization addCategory: #'Metacello-MC-Model'!MetacelloVersion subclass: #MetacelloMCVersion	instanceVariableNames: 'loaderPolicy'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!Magnitude variableSubclass: #MetacelloVersionNumber	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!!MetacelloVersionNumber commentStamp: 'dkh 6/22/2012 12:00' prior: 0!# Metacello version formatThanks to [Mozilla Toolkit version format](https://developer.mozilla.org/en/Toolkit_version_format) for inspiration.##Version FormatA version string consists of one or more version parts, separated with dots or dashes.A version part with a leading dot is numeric. A version part with a leading dash is string.The rationale behind splitting a version part into a sequence of strings and numbers is that when comparing version parts, the numeric parts are compared as numbers, e.g. '1.0-pre.1' < '1.0-pre.10', while the strings are compared bytewise. See the next section for details on how versions are compared.##Comparing versionsWhen two version strings are compared, their version parts are compared left to right. Empty parts are ignored.If at some point a version part of one version string is greater than the corresponding version part of another version string, then the first version string is greater than the other one.If a version string has extra parts and the common parts are equal, the shorter version string is less than the longer version string (1.0 is less than 1.0.0).Otherwise, the version strings are equal. ##Comparing version partsVersion parts are also compared left to right, A string-part that exists is always less-then a nonexisting string-part (1.6-a is less than 1.6).Examples```1 == 1. < 1.0 == 1..--0< 1.1-a < 1.1-aa < 1.1-ab < 1.1-b < 1.1-c< 1.1-pre < 1.1-pre.0 < 1.1-pre.1-a < 1.1-pre.1-aa < 1.1-pre.1-b < 1.1-pre.1< 1.1-pre.2< 1.1-pre.10< 1.1 < 1.1.0 < 1.1.00< 1.10< 2.0```!MCDirectoryRepository subclass: #MCFileTreeRepository	instanceVariableNames: 'readonly repositoryProperties versionNameToFileNameMap cacheInvalidationFlag'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeRepository class	instanceVariableNames: 'defaultPackageExtension defaultPropertyFileExtension'!SystemOrganization addCategory: #'Metacello-GitBasedRepository'!MCFileTreeRepository subclass: #MCGitBasedNetworkRepository	instanceVariableNames: 'projectPath projectVersion repoPath projectVersionPattern'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-GitBasedRepository'!MCGitBasedNetworkRepository class	instanceVariableNames: 'repoCacheDirectory repoDownloadCache siteUsername sitePassword'!SystemOrganization addCategory: #'Metacello-Bitbucket'!MCGitBasedNetworkRepository subclass: #MCBitbucketRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Bitbucket'!SystemOrganization addCategory: #'Metacello-GitHub'!MCGitBasedNetworkRepository subclass: #MCGitHubRepository	instanceVariableNames: ''	classVariableNames: 'CacheDirectory DownloadCache ETagsCache'	poolDictionaries: ''	category: 'Metacello-GitHub'!SystemOrganization addCategory: #'Metacello-Core-Constructors'!Array variableSubclass: #MetacelloMethodSectionPath	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!SystemOrganization addCategory: #'Gofer-Core'!Error subclass: #GoferRepositoryError	instanceVariableNames: 'repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferRepositoryError commentStamp: 'lr 1/30/2010 14:39' prior: 0!A GoferRepositoryError is the error thrown when a repository cannot be accessed.!SystemOrganization addCategory: #'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloCannotUpdateReleasedVersionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloNameNotDefinedError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloPackageSpecResolutionError	instanceVariableNames: 'packageSpec repositories repositoryError'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloProjectSpecLoadError	instanceVariableNames: 'projectSpec versionDoesNotExistException'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!MetacelloProjectSpecLoadError subclass: #MetacelloProjectSpecLoadConflict	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloScriptingError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptingError subclass: #MetacelloConflictingProjectError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptingError subclass: #MetacelloUseUpgradeError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Error subclass: #MetacelloValidationFailure	instanceVariableNames: 'issues'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloVersionDoesNotExistError	instanceVariableNames: 'project versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!MetacelloVersionDoesNotExistError subclass: #MetacelloSymbolicVersionDoesNotExistError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!MetacelloSymbolicVersionDoesNotExistError subclass: #MetacelloSymbolicVersionNotDefinedError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!MetacelloVersionDoesNotExistError subclass: #MetacelloVersionDefinitionError	instanceVariableNames: 'exception'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!SystemOrganization addCategory: #'STON-Core-Reader'!Error subclass: #STONReaderError	instanceVariableNames: 'streamPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Reader'!!STONReaderError commentStamp: '' prior: 0!STONReaderError is the error/exception signalled by STONReader when illegal/incorrect input is seen. !SystemOrganization addCategory: #'STON-Core-Writer'!Error subclass: #STONWriterError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Writer'!!STONWriterError commentStamp: '' prior: 0!STONWriterError is the error/exception signalled by STONWriter when illegal/incorrect input is seen. !MCMczReader subclass: #MCFileTreeAbstractReader	instanceVariableNames: 'packageDirectory packageProperties'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeAbstractReader subclass: #MCFileTreeStReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeAbstractReader subclass: #MCFileTreeStSnapshotReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeStSnapshotReader subclass: #MCFileTreeStCypressReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!ClassAPIHelpBuilder subclass: #MetacelloClassAPIHelpBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Help'!CustomHelp subclass: #MetacelloConfigurationHelp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Help'!CustomHelp subclass: #MetacelloHelp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Help'!MetacelloHelp subclass: #MetacelloAPIDocumentation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Help'!MCWriter subclass: #MCFileTreeAbstractStWriter	instanceVariableNames: 'stWriter initializers orderedClassNames orderedTraitNames'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeAbstractStWriter subclass: #MCFileTreeStSnapshotWriter	instanceVariableNames: 'classDefinitions traitDefinitions classTraitDefinitions methodDefinitions'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeStSnapshotWriter subclass: #MCFileTreeStCypressWriter	instanceVariableNames: 'fileStream'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeStCypressWriter class	instanceVariableNames: 'specials'!MCFileTreeAbstractStWriter subclass: #MCFileTreeStWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCStWriter subclass: #MCFileTreePackageStructureStWriter	instanceVariableNames: 'initializers'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!SystemOrganization addCategory: #'Metacello-Base'!Object subclass: #ConfigurationOf	instanceVariableNames: 'project'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!ConfigurationOf commentStamp: 'dkh 5/30/2012 16:31' prior: 0!You must use a *configuration* when your project is stored in arepository using `.mcz` files.If you are using a source code manager (SCM) like [git][1] and havecreated a *baseline* (see the [**BaselineOf** class comment][3] for more info)you may use a *configuration* to associate a specificgit commit (SHA, branch name, tag name) with a [Metacello version][2].To create a new Metacello configuration:1. Create a subclass of the **ConfigurationOf** class. The configuration   class for your project should be names by appending the name of   your project to the string `ConfigurationOf`. The name of the   category and package should be the same as the name of the class:    ```Smalltalk    ConfigurationOf subclass: #ConfigurationOfExample      instanceVariableNames: ''      classVariableNames: ''      poolDictionaries: ''      category: 'ConfigurationOfExample'    ```2. Create a **baselineXXXX:** method where you specify the structure of your project:    ```Smalltalk    baseline0100: spec      <baseline: '1.0-baseline'>      spec for: #common do: [        spec repository: 'http://ss3.gemstone.com/ss/Example'.        spec          package: 'Example-Core';          package: 'Example-Tests' with: [            spec requires: 'Example-Core' ]].    ```3. Create a **versionXXXX:** method where you specify the specific   versions of the packages to be loaded for this version:    ```Smalltalk    version01000: spec      <version: '1.0' imports: #('1.0-baseline')>      spec for: #common do: [        spec blessing: #release.        spec          package: 'Example-Core' with: 'Example-Core';          package: 'Example-Tests' with: 'Example-Tests' ].    ```4. Create a Monticello package for your **ConfigurationOf** class and save it in the repository where your packages are stored. [1]: http://git-scm.com/[2]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacello-version-numbers[3]: https://github.com/dalehenrich/metacello-work/blob/master/repository/Metacello-Base.package/BaselineOf.class/README.md!ConfigurationOf subclass: #BaselineOf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!BaselineOf commentStamp: 'dkh 5/30/2012 16:30' prior: 0!You should use a *baseline* when you are using a disk-based sourcecode manager (SCM) like [git][1].When using a disk-based SCM it is not necessary to use the Metacello*version* method, because it is intended for use with `.mcz` files. With a disk-based SCM you only need a single `baseline:` method. Whenyou change the structure of your project you can change the baseline andsave everything in a single commit. So multiple `baseline:` methods areno longer needed.You may still need a *configuration* when using a *baseline*. The[Sample project][3] on GitHub has a good example of a configuration usedin conjunction with a *baseline*. See the [**ConfigurationOf** class comment][2] for information on creating a *configuration*.To create a new Metacello baseline:1. Create a subclass of the **BaselineOf** class. The baseline   class for your project should be named by appending the name of   your project to the string `BaselineOf`. The name of the category and   package should be the same as the name of the class:    ```Smalltalk    BaselineOf subclass: #BaselineOfExample      instanceVariableNames: ''      classVariableNames: ''      poolDictionaries: ''      category: 'BaselineOfExample'    ```2. Create a **baseline:** method where you specify the structure of your project:    ```Smalltalk    baseline: spec      <baseline>      spec for: #common do: [        spec          package: 'Example-Core';          package: 'Example-Tests' with: [            spec requires: 'Example-Core' ]].    ```3. Create a Monticello package for your **BaselineOf** class and save it in the repository where your packages are stored.4. To load a package from GitHub that contains a baseline evaluate the following:```Smalltalk| repositorySpec |"edit to match your username, repository name and branch"repositorySpec := 'dalehenrich/metacello-work:master'.Metacello new  baseline: 'Sample';  repository: 'github://', repositorySpec;  load.```For further documentation see For more information on the [github://](MetacelloScriptingAPI.md#github) url specifigation see the [Metacello Scripting APIreference](MetacelloScriptingAPI.md). There more information on [working with GitHub here](GettingStartedWithGitHub.md).[1]: http://git-scm.com/[2]: https://github.com/dalehenrich/metacello-work/blob/master/repository/Metacello-Base.package/ConfigurationOf.class/README.md[3]: https://github.com/dalehenrich/sample/tree/configuration/ConfigurationOfSample.package/ConfigurationOfSample.class!SystemOrganization addCategory: #'Metacello-Core-Deprecated'!ConfigurationOf subclass: #MetacelloBaseConfiguration	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Deprecated'!!MetacelloBaseConfiguration commentStamp: 'dkh 5/30/2012 13:50' prior: 0!You should be using ConfigurationOf instead of MetacelloBaseConfiguration. The class is being kept around because many extant Metacello configurations use MetacelloBaseConfiguration as a sentinel class to indicate whether or not Metacello is loaded..Once the Metacello scripting API becomes prevalent (the api has it's own ensureMetacello logic) this class can be removed.!Object subclass: #Gofer	instanceVariableNames: 'references repositories errorBlock packageCacheRepository resolvedReferencesCache'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!Gofer commentStamp: 'lr 1/30/2010 14:42' prior: 0!: Gofer, a person who runs errands. Origin 1960s: from go for, i.e. go and fetch.: ''The New Oxford American Dictionary''!! SynopsisGofer is a small tool on top of Monticello that loads, updates, merges, diffs, reverts, commits, recompiles and unloads groups of Monticello packages. Contrary to existing tools Gofer makes sure that these operations are performed as clean as possible:- Gofer treats packages from one or more repository in one operation.- Gofer works with fixed versions or tries to find the "latest" version using a given package name.- Gofer automatically assigns repositories to all packages, so that the other tools are ready to be used on individual packages.- Gofer makes sure that there is only one repository instance registered for a single physical location.- Gofer works with Monticello dependencies and uniformly treats them like the primary package.- Gofer prefers to work with faster repositories if there is a choice.- Gofer cleans up after Monticello, no empty class categories and no empty method protocols are to be expected.- Gofer supports operations to sync remote and local repositories with each other.!! InstallationGofer is included with the latest Pharo and GemStone distributions. To update to the latest version you can use Gofer itself:== Gofer upgradeIn case you are missing Gofer in your image, grab it from *http://source.lukas-renggli.ch/gofer.html*.!! DescriptionGofer is very simple by design, the basic useage scenario is always the same and consists of three steps:# You specify one or more Monticello repository URLs. You can do this using the methods ==url:==, ==url:username:password:== (HTTP, FTP), ==directory:==, or ==repository:== if you need full control. You might also use the convenience methods like ==squeaksource:==, ==wiresong:==, or ==gemsource:== for well known repositories. Additionally the following settings are available:#- Gofer implicitly declares the local package cache as a repository. To disable the local package cache use the method ==disablePackageCache==, to re-enable use ==enablePackageCache==.#- Gofer throws an error if a repository is not reachable. To silently ignore repository erros use the message ==disableRepositoryErrors==, to re-enable use ==enableRepositoryErrors==.# You specify one or more Monticello packages you want to work with, by adding them to the Gofer instance. Use ==version:== to add a specific version, or use ==package:== to add the "latest" version in the given repository. Furthermore there is ==package:constraint:== that allows you to further constraint the version to be loaded in a block passed in as the second argument.# You specify one or more actions to be performed on the specified packages:| ==load==	| Load the specified packages.| ==update==	| Update the specified packages.| ==merge==	| Merge the specified packages into their working copies.| ==localChanges==	| Answer the changes between the base version and the working copy.| ==browseLocalChanges==	| Browse the changes between the base version and the working copy.| ==remoteChanges==	| Answer the changes between the working copy and the remote changes.| ==browseRemoteChanges==	| Browse the changes between the working copy and the remote changes.| ==cleanup==	| Cleans the specified packages.| ==commit==	| Commit the modified specified packages.| ==commit:==	| Commit the modified specified packages with the given commit message.| ==revert==	| Revert the specified packages to the currently loaded version.| ==recompile==	| Recompile the specified packages.| ==reinitialize==	| Call the class side initializers on the specified packages.| ==unload==	| Unload the specified packages.| ==fetch==     | Download versions from remote repositories into the local cache.| ==push==      | Upload local versions from local cache into remote repositories.!! ExampleTo use Gofer to update to exact versions of the Kom Server, the 'latest' code of Seaside 2.8 and the 'latest' code of the Scriptaculous package that is committed by the author with the initials 'lr' one could evaluate:== Gofer new==     squeaksource: 'KomHttpServer';==     version: 'DynamicBindings-gc.7';==     version: 'KomServices-gc.19';==     version: 'KomHttpServer-gc.32';==     update.== Gofer new==     squeaksource: 'Seaside';==     package: 'Seaside2.8a';==     package: 'Scriptaculous' constraint: [ :version | version author = 'lr' ];==     load!SystemOrganization addCategory: #'Metacello-MC-Gofer'!Gofer subclass: #MetacelloGofer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!Object subclass: #GoferOperation	instanceVariableNames: 'gofer model'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferOperation subclass: #GoferLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferLoad subclass: #MetacelloGoferLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!GoferOperation subclass: #GoferSynchronize	instanceVariableNames: 'cacheReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferSynchronize subclass: #GoferFetch	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferSynchronize subclass: #GoferPush	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferOperation subclass: #GoferWorking	instanceVariableNames: 'workingCopies'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferChanges subclass: #GoferLocalChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferLocalChanges subclass: #GoferBrowseLocalChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferChanges subclass: #GoferRemoteChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferRemoteChanges subclass: #GoferBrowseRemoteChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferCleanup	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferCommit	instanceVariableNames: 'message'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferCommit subclass: #MetacelloGoferCommit	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!GoferWorking subclass: #GoferRecompile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferReinitialize	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferUnload	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferUpdate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferUpdate subclass: #GoferMerge	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferUpdate subclass: #GoferRevert	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!Object subclass: #GoferReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferReference commentStamp: 'lr 1/30/2010 14:38' prior: 0!A GoferReference is an abstract superclass for various kinds of references to Monticello packages and versions.!GoferReference subclass: #GoferPackageReference	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferPackageReference commentStamp: 'lr 12/9/2009 22:47' prior: 0!A GoferPackageReference refers to the latest version of a Monticello package.!GoferPackageReference subclass: #GoferConstraintReference	instanceVariableNames: 'constraintBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferConstraintReference commentStamp: 'lr 1/30/2010 14:37' prior: 0!A GoferPackageReference refers to the latest version of a Monticello package satisfying an additional constraint.!GoferPackageReference subclass: #MetacelloGoferPackage	instanceVariableNames: 'packageFilename version workingCopy'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!GoferReference subclass: #GoferVersionReference	instanceVariableNames: 'package author branch versionNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferVersionReference commentStamp: 'lr 12/9/2009 22:50' prior: 0!A GoferVersionReference refers to a specific version of a Monticello package.!GoferVersionReference subclass: #GoferResolvedReference	instanceVariableNames: 'repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferResolvedReference commentStamp: 'lr 1/30/2010 14:38' prior: 0!A GoferVersionReference refers to a specific version of a Monticello package in a particular repository. This class is the only one that can actually load the version, because it is the only one knowing where to find it.!GoferResolvedReference subclass: #MetacelloCachingGoferResolvedReference	instanceVariableNames: 'cachedVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!Object subclass: #MCFileTreeFileUtils	instanceVariableNames: ''	classVariableNames: 'Current'	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!SystemOrganization addCategory: #'MonticelloFileTree-FileDirectory-Utilities'!MCFileTreeFileUtils subclass: #MCFileTreeFileDirectoryUtils	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-FileDirectory-Utilities'!Object subclass: #MCFileTreeJsonParser	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!Object subclass: #Metacello	instanceVariableNames: 'executorSpec statements'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!Metacello commentStamp: 'dkh 7/28/2012 20:04' prior: 0!# Metacello User GuideIn this guide we'll take a walk through a couple of common developmentscenarios and highlight some of the features of the *Metacello ScriptingAPI*.*For installatation and more detailed documentation on the MetacelloScripting API, see the [Metcello Scripting API Documentation][1].*## IntroductionThe number one job of the *Metacello Scripting API* is to simplify thejob of loading projects into your image. As you are probably alltoo aware, today it's a two step process where you first load theconfiguration into your image using [Gofer][2] and then load yourproject using Metacello:```SmalltalkGofer new  package: 'ConfigurationOfSeaside30';  squeaksource: 'MetacelloRepository';  load.((Smalltalk at: #ConfigurationOfSeaside30) version: #stable) load.```In the early days of Metacello (and Gofer) this was a great improvementover the alternatives, but today, 3 years after the introduction ofMetacello, there should be a better way...and there is.Using the *Metacello Scripting API* the above expression reduces to thefollowing:```SmalltalkMetacello new  configuration: 'Seaside30';  load.```## LoadingIn this example of the [`load` command][5] we are leveraging a couple ofdefault values, namely the `version` of the project and the `repository` where the**ConfigurationOfSeaside** package can be found:```SmalltalkMetacello new  configuration: 'Seaside30';  load.```Here is a variantof the same expression with the (current) default values explicitly specified:```SmalltalkMetacello new  configuration: 'Seaside30';  version: #stable;  squeaksource: 'MetacelloRepository';  load.```The `version` attribute can be any legal [version number][10].`squeaksource` is a [repository shortcut][4]. You can also specify thefull [repository description][3] as follows:```SmalltalkMetacello new  configuration: 'Seaside30';  version: #stable;  repository: 'http://www.squeaksource.com/MetacelloRepository';  load.```##ListingOnce you've loaded one or more projects into your image, you may want tolist them. The following is an example of the [`list` command][6]:```SmalltalkMetacello image  configuration: [:spec | true ];  list.```The `image` message tells Metacello that you'd like to lookat only loaded configurations. The *block* argument to the`configuration:` message is used to *select* against the list of loaded[MetacelloProjectSpec][7] instances in the [registry][8].The `list` command itself returns a list of [MetacelloProjectSpec][7] instances that can be printed, inspected or otherwise manipulated.In addition to a *select block*, you can specify a *select collection*specifying the names of the projects you'd like to select:```SmalltalkMetacello registry  configuration: #('Seaside30' 'MetacelloPreview');  list.```The `registry` message tells Metacello that you'd like tolook at all projects in the [registry][8] whether or not they are loaded.The *collection* argument to the `configuration:` message is used to*select* against the list of project names in the [registry][8].The `list` command can also be used to look at configurations inMonticello repositories. For example:```SmalltalkMetacello new  configuration: [:spec | spec name beginsWith: 'Seaside'];  squeaksource: 'MetacelloRepository';  list.```lists the configurations whose names (sans the `ConfigurationOf`) beginwith `Seaside` in the `MetacelloRepositry` in the[Squeaksource](http://www.squeaksource.com) repostory.## GettingOnce you've loaded a project into your image the next logical step isupgrading your project to a new version. Let's say that a new `#stable` version of Seaside30 has been releasedand that you want to upgrade. This is a two step process: * [get a new version of the configuration][11]* [load the new version][12]### Get a new version of the configurationThe following expression gets the latest version of theconfiguration:```SmalltalkMetacello image  configuration: 'Seaside30';  get.```By using the `image` message, you can leverage the fact that the [registry][8] remembersfrom which repository you loaded the original version of the configuration.The `get` command simply downloads the latest version of theconfiguration package from the repository.You may download the configuration from a different repository:```SmalltalkMetacello image  configuration: 'Seaside30';  squeaksource: 'Seaside30;  get.```The `get` command will update the [registry][8] with the newrepository location information.You may also use the `get` command to load a configuration for a projectinto your image without actually loading the project itself:```SmalltalkMetacello image  configuration: 'SeasideRest';  squeaksource: 'Seaside30';  get.```The 'SeasideRest' project information will be registered in the [registry][8] and markedas *unloaded*.### Load the new versionOnce you've got a new copy of the Seaside30 configuration loaded into your image, you mayupgrade your image with the following expression:```SmalltalkMetacello image  configuration: 'Seaside30';  version: #stable;  load.```By using the `image` message, you are asking Metacello to look theproject up in the [registry][8] before performing theoperation, so it isn't necessary to supply all of the project details for everycommand operation.Of course, the `load` command updates the [registry][8].If you want to load a project for which you've already done a `get`(like the SeasideRest project earlier), you can do the following:```SmalltalkMetacello registry  configuration: 'SeasideRest';  version: #stable;  load.```In this case you use the `registry` message to indicate that you areinterested in both *loaded* and *unloaded* projects.##LockingLet's say that you are using an older version of Seaside30 (say 3.0.5)instead of the #stable version (3.0.7) and that your application doesn'twork with newer versions of Seaside30 (you've tried and it's more workto get you application to work with the newer version of Seaside30 thanit's worth).Let's also say that you want to try out something in theSeasideRest project, but when you try loading SeasideRest, you end uphaving Seaside 3.0.7 loaded as well. This is an unfortunate side effect of Metacello trying to *do the rightthing*, only in your case it is the wrong thing.Fortunately, the [`lock` command][9] can give you control. First youneed to `lock` the Seaside30 project:```SmalltalkMetacello image  configuration: 'Seaside30';  lock.```The `image` message tells Metacello to do a lookup in the list of loadedprojects and then to put a lock on the loaded version of the project.If you want you can specify which version of the project you wantlocked:```SmalltalkMetacello image  configuration: 'Seaside30';  version: '3.0.5';  lock.```After a project is locked an error (**MetacelloLockedProjectError**) is thrown when you attempt to load a project that has a dependency upon a different version of Seaside30. The error is thrown before any packages are actually loaded.### Bypassing locksLet's say that you want to load the SeasideRest project even though it mayrequire a version of Seaside30 that is later than the version that you havelocked. To do that you need to suppress the upgrade of the Seaside30project during the load of the SeasideRest project and you can do thatwith the use of the `onUpgrade:` message:```SmalltalkMetacello new  configuration: 'SeasideRest';  version: #stable;  onUpgrade: [:ex :existing :new |     existing baseName = 'Seaside30'      ifTrue: [ ex disallow ].    ex pass ];  load.```The `onUpgrade:` block tells Metacello to disallow the upgrade of anyproject whose `baseName` is `Seaside30` and to continue with the load.Of course if there are any explicit dependencies between SeasideRest andthe later version of Seaside30 (missing classes, etc.) then you may verywell get load errors or errors while using the SeasideRest, but that'sthe price you pay for not upgrading.### Upgrading a locked projectIf you want to explicitly upgrade a locked project, you can use the`load` command. The following command will upgrade Seaside30 to version3.0.6 even if it is locked: ```SmalltalkMetacello image  configuration: 'Seaside30';  version: '3.0.6';  lock.```The newly loaded of the project will continue to be locked.[1]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md[2]: http://www.lukas-renggli.ch/blog/gofer[3]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#repository-descriptions[4]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#repository-shortcuts[5]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#loading[6]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#listing[7]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacelloprojectspec[8]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacello-project-registry[9]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#locking[10]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacello-version-numbers[11]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloUserGuide.md#get-a-new-version-of-the-configuration[12]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloUserGuide.md#load-the-new-version!Object subclass: #MetacelloAbstractConstructor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloAbstractConstructor subclass: #MetacelloAbstractVersionConstructor	instanceVariableNames: 'root configuration project attributeMap attributeOrder symbolicVersion currentContext'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloAbstractVersionConstructor subclass: #MetacelloBaselineConstructor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!!MetacelloBaselineConstructor commentStamp: 'dkh 5/4/2012 17:05' prior: 0!##MetacelloBaselineConstructor**MetacelloBaselineConstructor** extracts the #baseline pragma from a **BaselineOfConfiguration** and produces a **MetacelloVersion**:.```SmalltalkMetacelloBaselineConstructor on: BaselineOfExample```!MetacelloAbstractVersionConstructor subclass: #MetacelloToolBoxConstructor	instanceVariableNames: 'currentSection methodSections'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloToolBoxConstructor subclass: #MetacelloToolBoxBaselineConstructor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloAbstractVersionConstructor subclass: #MetacelloVersionConstructor	instanceVariableNames: 'errorMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!SystemOrganization addCategory: #'Metacello-Core-Validation'!MetacelloAbstractConstructor subclass: #MetacelloVersionValidator	instanceVariableNames: 'configurationClass exludededValidations validationReport recurse debug visited'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!MetacelloVersionValidator class	instanceVariableNames: 'reasonCodeDescriptions'!SystemOrganization addCategory: #'Metacello-MC-Validation'!MetacelloVersionValidator subclass: #MetacelloMCVersionValidator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Validation'!!MetacelloMCVersionValidator commentStamp: 'dkh 1/26/2012 09:49' prior: 0!Performs configuration validation.For programmatically decoding reason codes use:  MetacellMCVersionValidator fullDescriptionForReasonCode: <reasonCode>Warning reason codes:	#notDevelopmentVersion			- the symbolic version #development refers to a non-development literal version.	#loadWarning 						- Warning signalled during load [load validation].	#onlyBaselineVersion 				- one or more baseline versions have been defined, but no non-baseline versions are defined.	#stableDevelopmentVersion		- a version whose blessing is #development has been declared as a #stable versionCritical Warning reason codes:	#duplicateVersionDefinitions 		         - there are multiple pragma methods specifying the same version	#loadDeprecation					         - deprecation warning signalled while loading configuration [load validation]	#missingRecommendedProjectSpecField - missing recommended fields in project reference (versionString). The versionString should be specified so that #bleedingEdge loads will be predictable and repeatable	#noLoadableVersions 				         - no non #baseline versions defined in configuration	#noTests 							         - no test cases defined in loaded configuration [load validation]	#noVersionSpecified 				         - no version defined for the project reference or package. The version specified in the baseline or the latest version of the project or package in the repository will be used.	#packageNameMismatch 			         - the name in the packageSpec does not match the name of the mcz file	#projectClassNameFileMismatch 	         - the class name of the configuration does not match the mcz file containing the configuration	#testDeprecation 					         - deprecation warning signalled while running configuration tests [load validation]Error reason codes:	#cannotResolveVersion 			- the version (project reference or symbolic version) was not found in the specified configuration	#duplicateNames 					- multiple independent definitions for an entity with same name (project, package, or group)	#incompleteProjectSpec 			- missing required fields in project reference (className and/or repository)	#incorrectVersionString 			- the version declared in pragma doesn't match version in versionSpec	#invalidDoItSelector 				- doit select must be a Symbol	#invalidVersionString 				- versionString must be a String	#loadError 							- error occured while loading configuration [load validation]	#missingVersionImport 			- version specified in import pragma not defined in configuration	#noVersionsDefined 				- no usable baseline or version defined in configuration ... configuration cannot be loaded	#projectCreationError 				- error occured while resolving project reference	#shadowedNames 					- name duplication between packages and projects	#testFailures						- test failures while running tests [load validation]	#versionCompositionError 			- error while creating versionSpec from pragmas!Object subclass: #MetacelloConfigTemplate	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'Metacello-MC-Model'!!MetacelloConfigTemplate commentStamp: '<historical>' prior: 0!Copy me to create a new configuration or edit and evaluate the following doits.        "Create configuration class and initial baseline method"        MetacelloToolBox                 createBaseline: '1.0-baseline'                for: 'MyProject'                repository: 'http://www.example.com/MyProjectRepository'                requiredProjects: #('Gofer')                packages: #('MyProject-Core' 'MyProject-Tests')                dependencies:                        {('MyProject-Core' -> #('Gofer')).                         ('MyProject-Tests' -> #('MyProject-Core'))}                groups:                        {('default' -> #('Core')).                        ('Core' -> #('MyProject-Core')).                        ('Tests' -> #('MyProject-Tests'))}.	   "create initial development method from the baseline"         MetacelloToolBox               createDevelopment: '1.0'               for: 'MyProject'                importFromBaseline: '1.0-baseline'                description: 'initial version'.!Object subclass: #MetacelloConfigTemplateExample	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'Metacello-MC-Model'!!MetacelloConfigTemplateExample commentStamp: '<historical>' prior: 0!Copy me to create a new configuration or edit and evaluate the following doits.        "Create configuration class and initial baseline method"        MetacelloToolBox                 createBaseline: '1.0-baseline'                for: 'MyProject'                repository: 'http://www.example.com/MyProjectRepository'                requiredProjects: #('Gofer')                packages: #('MyProject-Core' 'MyProject-Tests')                dependencies:                        {('MyProject-Core' -> #('Gofer')).                         ('MyProject-Tests' -> #('MyProject-Core'))}                groups:                        {('default' -> #('Core')).                        ('Core' -> #('MyProject-Core')).                        ('Tests' -> #('MyProject-Tests'))}.	   "create initial development method from the baseline"         MetacelloToolBox               createDevelopment: '1.0'               for: 'MyProject'                importFromBaseline: '1.0-baseline'                description: 'initial version'.!SystemOrganization addCategory: #'Metacello-MC-Directives'!Object subclass: #MetacelloDirective	instanceVariableNames: 'spec loader'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloDirective subclass: #MetacelloPackageLoadDirective	instanceVariableNames: 'resolvedReference externalReference'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloDirective subclass: #MetacelloPrePostLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloPrePostLoadDirective subclass: #MetacelloPostLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloPrePostLoadDirective subclass: #MetacelloPreLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloDirective subclass: #MetacelloVersionLoadDirective	instanceVariableNames: 'loadDirectives'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloVersionLoadDirective subclass: #MetacelloAtomicLoadDirective	instanceVariableNames: 'packageloads preloads postloads'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloVersionLoadDirective subclass: #MetacelloExplicitLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloVersionLoadDirective subclass: #MetacelloLinearLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!SystemOrganization addCategory: #'Metacello-MC-Loaders'!Object subclass: #MetacelloLoadData	instanceVariableNames: 'dataMap versionInfoMap packageNameMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!Object subclass: #MetacelloLoaderPolicy	instanceVariableNames: 'overrideRepositories repositoryMap ensuredMap cacheRepository cacheGofer ignoreImage loadData loadDirective silently'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!SystemOrganization addCategory: #'Metacello-MC-Specs'!Object subclass: #MetacelloMCPartiallyLoadedStatus	instanceVariableNames: 'hasNoPackage hasNoProject aProjectIsLoaded aPackageIsLoaded aLoadedProjectIsExact aLoadedPackageIsExact aLoadedProjectIsCurrent aLoadedPackageIsCurrent aLoadedProjectIsNotCurrent aLoadedPackageIsNotCurrent aProjectNotLoaded aPackageNotLoaded vrsnStatus abort'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!Object subclass: #MetacelloMCVersionSpecLoader	instanceVariableNames: 'versionSpec required packages loader loaderPolicy'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!Object subclass: #MetacelloMethodSection	instanceVariableNames: 'attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSection subclass: #MetacelloSymbolicVersionSpec	instanceVariableNames: 'versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSection subclass: #MetacelloVersionMethodSection	instanceVariableNames: 'block versionSpec parent methodSections'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!Object subclass: #MetacelloMethodSpec	instanceVariableNames: 'project selector category versionString methodSections'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSpec subclass: #MetacelloSymbolicVersionMethodSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSpec subclass: #MetacelloVersionMethodSpec	instanceVariableNames: 'imports'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloVersionMethodSpec subclass: #MetacelloBaselineOfMethodSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!Object subclass: #MetacelloPlatform	instanceVariableNames: 'bypassProgressBars bypassGoferLoadUpdateCategories'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'Metacello-Core-Model'!MetacelloPlatform subclass: #MetacelloSqueakPlatform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Platform'!Object subclass: #MetacelloProject	instanceVariableNames: 'versionMap symbolicVersionMap errorMap loader loaderClass loadType configuration projectAttributes versionNumberClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!MetacelloProject subclass: #MetacelloMCProject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!MetacelloMCProject subclass: #MetacelloMCBaselineProject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!!MetacelloMCBaselineProject commentStamp: 'dkh 5/5/2012 08:47' prior: 0!The **MetacelloMCBaselineProject**  is a wrapper for the **BaselineOf** version specification for file-based repositories.There is a single version in a **MetacelloMCBaselineProject**, named *'baseline'*.A typical **BaselineOf** is specification:```Smalltalkbaseline: spec    <baseline>    spec        package: 'External-Core';        package: 'External-Tests' with: [ spec requires: 'External-Core' ];        yourself.    spec        group: 'Core' with: #('External-Core');        group: 'default' with: #('Core');        group: 'Tests' with: #('External-Tests');        yourself```The `<baseline>` pragma marks the method containing the baseline specification.!SystemOrganization addCategory: #'Metacello-Cypress'!MetacelloMCBaselineProject subclass: #MetacelloCypressBaselineProject	instanceVariableNames: ''	classVariableNames: 'UseCypressPackagesForAllBaselines'	poolDictionaries: ''	category: 'Metacello-Cypress'!!MetacelloCypressBaselineProject commentStamp: 'CyrilFerlicot 2/8/2018 15:56' prior: 0!The **MetacelloCypressBaselineProject**  is a wrapper for the **BaselineOf** version specification for file-based repositories specific to metadataless export format. (Filetree/Tonel)It should be used by metadataless repositories (FileTree/Tonel). To use it the **BaselineOf** needs to redefine this method:```Smalltalk	projectClass	    ^ MetacelloMCBaselineProject```Metacello has an internal rule to not load Monticello packages of the same version, since they are already loaded. However, when using metadataless repositories the filetree/tonel Monticello package readers typically generate a package name using the author/version `-cypress.1`, which make Metacello think that the versions are the same and the package is not loaded. By including the above method in your baselineof, Metacello will know to ignore the Monticello author/version of the package and always load it.!Object subclass: #MetacelloProjectRegistration	instanceVariableNames: 'projectName configurationProjectSpec baselineProjectSpec loadedInImage locked mutable versionInfo'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectRegistrationVersionInfo	instanceVariableNames: 'versionString projectVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectRegistry	instanceVariableNames: 'baselineRegistry configurationRegistry'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectSpecForLoad	instanceVariableNames: 'projectSpec useDetermineVersionForLoad overrideProjectSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectSpecGenerator	instanceVariableNames: 'target'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloProjectSpecGenerator subclass: #MetacelloBaselineSpecGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloProjectSpecGenerator subclass: #MetacelloConfigurationSpecGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloScriptEngine	instanceVariableNames: 'root projectSpec options'	classVariableNames: 'DefaultRepositoryDescription DefaultVersionString'	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloScriptEngine commentStamp: 'dkh 7/12/2012 14:48' prior: 0!MetacelloScriptEngine runs the execution of the script for one projectSpec!Object subclass: #MetacelloScriptExecutor	instanceVariableNames: 'options roots singleRoot projectSpecGenerator actionArg configurationArg baselineArg projectArg classNameArg versionArg repositoryArg passwordArg usernameArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloScriptExecutor commentStamp: 'dkh 7/12/2012 14:49' prior: 0!MetacelloScriptExecutor decodes script args and launches MetacelloScriptEngine to run for each projectSpec encounters...i,e., primarily here to handl array and block args to configuration:, baseline: or project:.!MetacelloScriptExecutor subclass: #MetacelloScriptApiExecutor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloScriptApiExecutor commentStamp: 'dkh 7/12/2012 14:49' prior: 0!MetacelloScriptExecutor decodes script args and launches MetacelloScriptEngine to run for each projectSpec encounters...i,e., primarily here to handl array and block args to configuration:, baseline: or project:.!MetacelloScriptExecutor subclass: #MetacelloScriptImageExecutor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptExecutor subclass: #MetacelloScriptRegistryExecutor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!SystemOrganization addCategory: #'Metacello-Core-Specs'!Object subclass: #MetacelloSpec	instanceVariableNames: 'project loader mutable'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloAbstractPackageSpec	instanceVariableNames: 'name requires includes answers'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloAbstractPackageSpec subclass: #MetacelloGroupSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloAbstractPackageSpec subclass: #MetacelloPackageSpec	instanceVariableNames: 'file repositories goferPackage preLoadDoIt postLoadDoIt'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!SystemOrganization addCategory: #'Metacello-Cypress-Specs'!MetacelloPackageSpec subclass: #MetacelloCypressPackageSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Cypress-Specs'!!MetacelloCypressPackageSpec commentStamp: 'CyrilFerlicot 2/8/2018 15:55' prior: 0!I am a package spec specific to metadataless projects (filetree/tonel).!MetacelloAbstractPackageSpec subclass: #MetacelloProjectReferenceSpec	instanceVariableNames: 'projectReference'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!SystemOrganization addCategory: #'Metacello-Core-Members'!MetacelloSpec subclass: #MetacelloMemberListSpec	instanceVariableNames: 'list memberMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberListSpec subclass: #MetacelloPackagesSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloMemberListSpec subclass: #MetacelloRepositoriesSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloSpec subclass: #MetacelloMemberSpec	instanceVariableNames: 'name spec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloAddMemberSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloCopyMemberSpec	instanceVariableNames: 'sourceName'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloMergeMemberSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloRemoveMemberSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloSpec subclass: #MetacelloProjectSpec	instanceVariableNames: 'name className versionString operator loads preLoadDoIt postLoadDoIt'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloProjectSpec subclass: #MetacelloGenericProjectSpec	instanceVariableNames: 'projectPackage repositories'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloGenericProjectSpec subclass: #MetacelloMCProjectSpec	instanceVariableNames: 'file'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloMCProjectSpec subclass: #MetacelloMCBaselineOfProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloMCBaselineOfProjectSpec subclass: #MetacelloCypressBaselineProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Cypress-Specs'!!MetacelloCypressBaselineProjectSpec commentStamp: 'CyrilFerlicot 2/8/2018 15:55' prior: 0!I am a project spec specific to metadataless projects (filetree/tonel).!MetacelloMCProjectSpec subclass: #MetacelloMCConfigurationOfProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloMCProjectSpec subclass: #MetacelloMCNamelessProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloSpec subclass: #MetacelloRepositorySpec	instanceVariableNames: 'description username password type'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloSpec subclass: #MetacelloValueHolderSpec	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloVersionSpec	instanceVariableNames: 'versionString blessing description author timestamp preLoadDoIt postLoadDoIt packageList importName importArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloVersionSpec subclass: #MetacelloMCVersionSpec	instanceVariableNames: 'repositories packages'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!SystemOrganization addCategory: #'Metacello-Core-Loaders'!Object subclass: #MetacelloSpecLoader	instanceVariableNames: 'spec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Loaders'!MetacelloSpecLoader subclass: #MetacelloCommonMCSpecLoader	instanceVariableNames: 'operator loaderPolicy disablePackageCache'	classVariableNames: 'RetryPackageResolution'	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloCommonMCSpecLoader subclass: #MetacelloFetchingMCSpecLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloFetchingMCSpecLoader subclass: #MetacelloEnsureFetchingMCSpecLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloFetchingMCSpecLoader subclass: #MetacelloNullRecordingMCSpecLoader	instanceVariableNames: 'afterLoads beforeLoads evalDoits'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloCommonMCSpecLoader subclass: #MetacelloLoadingMCSpecLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!SystemOrganization addCategory: #'Metacello-ToolBox'!Object subclass: #MetacelloToolBox	instanceVariableNames: 'project methodSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-ToolBox'!!MetacelloToolBox commentStamp: '<historical>' prior: 0!MetacelloToolbox implements a toolbox API for Metacello.The toolbox methods on the class-side implement scripts for a number of commonly performed Metacello development tasks. The methods should be used in development scripts or GUI tools so that a common implementation is preserved across the toolset.!Object subclass: #MetacelloValidationIssue	instanceVariableNames: 'configurationClass explanation reasonCode callSite'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!MetacelloValidationIssue subclass: #MetacelloValidationCriticalWarning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!!MetacelloValidationCriticalWarning commentStamp: '<historical>' prior: 0!MetacelloValidationCriticalWarning indicates that there is a logical inconsistency that may not be intentional and that could cause incorrect loads!MetacelloValidationIssue subclass: #MetacelloValidationError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!!MetacelloValidationError commentStamp: '<historical>' prior: 0!MetacelloValidationError indicates that errors are to be expected if an attempt to use the configuration/version is made!MetacelloValidationIssue subclass: #MetacelloValidationWarning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!!MetacelloValidationWarning commentStamp: '<historical>' prior: 0!MetacelloValidationWarning indicates that there is a logical inconsistency that is not likely to cause any functional problems!Object subclass: #MetacelloVersionDiffReport	instanceVariableNames: 'additions configuration modifications removals from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!Object subclass: #MetacelloVisitedPackages	instanceVariableNames: 'groups packages projects'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!SystemOrganization addCategory: #'STON-Core-Facade'!Object subclass: #STON	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Facade'!!STON commentStamp: 'SvenVanCaekenberghe 10/9/2018 21:14' prior: 0!STON implements serialization and materialization using the Smalltalk Object Notation format.I am a class side facade offering a high level API to write and read objects using STON.U s a g eBasic operations  #toString:  #fromString:  STON toString: DisplayScreen boundingBox.  STON fromString:  'Rectangle{#origin:Point[0,0],#corner:Point[1920,1030]}'.  STON toString: { DateAndTime now. Float pi. 1 to: 10 by: 2. 3 days }.  STON fromString:  '[DateAndTime[''2016-03-15T13:57:59.462422+01:00''],3.141592653589793,Interval{#start:1,#stop:10,#step:2},Duration{#nanos:0,#seconds:259200}]'You can also read from or write to streams  #fromStream:  #put:onStream:There is also the option to do pretty printing (indenting, multi line output)   #toStringPretty:  #put:onStreamPretty:STON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are   - class information (except for lists (Array) and maps (Dictionary))  - proper handling of shared and circular references  - more Smalltalk like syntax (Symbols with #, single qouted Strings, nil instead of null)  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)Parsing JSON is done using #fromString: or #fromStream: with the results being composed of Arrays and Dictionaries.Writing objects as JSON is done using:   #toJsonString[Pretty]:  #put:asJsonOnStream[Pretty]:Note that you can only write Arrays and Dictionaries !!For a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON.Like JSON, STON does not allow for comments. However, a preprocessor option can skip C style comments before parsing.I also define some contants used in the implementation: the class used as list, map and association, as well as the optional class name key (used when reading objects using an unknown class).I m p l e m e n t a t i o nThe 2 key methods are  #stonOn:  #fromSton:which work together with STONWriter and STONReader; read their class comments for all configuration options (you can use the #reader and #writer methods to avoid referring to these classes directly).Several methods are used to support and/or control the implementation  #stonName - defines the external name for a class  #stonAllInstVarNames - defines which instance variable to write  #stonContainSubObjects - shortcut looking into objects for subobjects  #stonShouldWriteNilInstVars - option to skip writing nil valued instance variablesS y n t a x	value	  primitive-value	  object-value	  reference	  nil	primitive-value	  number	  true	  false	  symbol	  string	object-value	  object	  map	  list	object	  classname map	  classname list	reference	  @ int-index-previous-object-value	map	  {}	  { members }	members	  pair	  pair , members	pair	  string : value	  symbol : value	  number : value	list	  []	  [ elements ]	elements	  value 	  value , elements	string	  ''	  ' chars '	chars	  char	  char chars	char	  any-printable-ASCII-character-	    except-'-"-or-\	  \'	  \"	  \\	  \/	  \b	  \f	  \n	  \r	  \t	  \u four-hex-digits	symbol	  # chars-limited	  # ' chars '	chars-limited	  char-limited	  char-limited chars-limited	char-limited	  a-z A-Z 0-9 - _ . /	classname	  uppercase-alpha-char alphanumeric-char	number	  int	  int denominator	  int denominator scale	  int frac	  int exp	  int frac exp	int	  digit	  digit1-9 digits 	  - digit	  - digit1-9 digits	denominator	  / digits	scale	  s digits	frac	  . digits	exp	  e digits	digits	  digit	  digit digits	e	  e	  e+	  e-	  E	  E+	  E-!Object subclass: #STONCStyleCommentsSkipStream	instanceVariableNames: 'stream peekedCharacter delimiter escape'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Reader'!!STONCStyleCommentsSkipStream commentStamp: '' prior: 0!I am STONCStyleCommentsSkipStream, a character ReadStream wrapping another character ReadStream. I skip C style comments, much like a classic C preprocessor.C, C++, Java, JavaScript style comments are either the multiline	/* a comment */	or the single line, up to end of line	// a comment 	I deal with any end of line convention. Multiline comments cannot be nested. You create me #on: another character ReadStream. Here is an example:	(STONCStyleCommentsSkipStream on: 'abc/*comment*/def' readStream) upToEnd.	Comments inside single and double quote delimited strings are ignored. Backslash escapes for single and double quotes inside strings are honored.!Object subclass: #STONJSON	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Facade'!!STONJSON commentStamp: '' prior: 0!I am STONJSON, a class side facade to use STON as a simple JSON parser/writer.STON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are   - class information (except for lists (Array) and maps (Dictionary))  - proper handling of shared and circular references  - more Smalltalk like syntax (Symbols with #, single qouted Strings, nil instead of null)  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)Parsing JSON is done using  #fromString:  #fromStream: with the results being composed of Arrays and Dictionaries.Writing objects as JSON is done using  #toString[Pretty]:  #put:onStream[Pretty]:Note that you can only write Arrays and Dictionaries !! Shared and circular references will be noted and signalled using an exception.E x a m p l e s  STONJSON toString: { 1. -1. Float pi. true. 'JSON' }.  STONJSON fromString: '[1,-1,3.141592653589793,true,"JSON"]'.  STONJSON toStringPretty: { #foo->1. #bar->2 } asDictionary.  STONJSON fromString: '{"foo":1,"bar":2,"sub":{"a":true,"b":false},"flags":[1,8,32]}'. For a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON.!Object subclass: #STONReader	instanceVariableNames: 'readStream objects classes unresolvedReferences stringStream acceptUnknownClasses newLine convertNewLines'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Reader'!!STONReader commentStamp: '' prior: 0!STONReader materializes objects using the Smalltalk Object Notation format.This parser is backwards compatible with standard JSON.Customization options are:- acceptUnknownClasses <Boolean> default is false	if true, unknown class names are allowed, the standard #mapClass (Dictionary) is instanciated and the class name is added under #classNameKey (#className)	if false, unknown class names result in a NotFound error- convertNewLines <Boolean> default is false	if true, any unescaped EOL sequence CR, LF or CRLF inside strings or symbols is read and converted as the chosen EOL sequence	if false, CR, LF and CRLF are read unmodified- newLine <String> default is String cr	sequence to use as EOL!Object subclass: #STONReference	instanceVariableNames: 'index'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Reader'!!STONReference commentStamp: '' prior: 0!STONReference holds a forward reference to another object during materialization.!Object subclass: #STONStreamWriter	instanceVariableNames: 'writer first'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Writer'!!STONStreamWriter commentStamp: '' prior: 0!STONStreamWriter helps in streaming writing STON representations.This is an abstract class.!STONStreamWriter subclass: #STONListWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Writer'!!STONListWriter commentStamp: '' prior: 0!STONArrayWriter helps in writing array based STON representations.!STONListWriter subclass: #STONShortListWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Writer'!!STONShortListWriter commentStamp: '' prior: 0!STONShortArrayWriter helps in writing short array based STON representations.!STONStreamWriter subclass: #STONMapWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core-Writer'!!STONMapWriter commentStamp: '' prior: 0!STONDictionaryWriter helps in writing dictionary based STON representations.!Object subclass: #STONWriter	instanceVariableNames: 'writeStream prettyPrint stonCharacters newLine asciiOnly jsonMode keepNewLines referencePolicy level objects'	classVariableNames: 'STONCharacters STONSimpleSymbolCharacters'	poolDictionaries: ''	category: 'STON-Core-Writer'!!STONWriter commentStamp: '' prior: 0!STONWriter serializes objects using the Smalltalk Object Notation format. Customization options are:- prettyPrint <Boolean> default is false	if true, produce pretty printed output- newLine <String> default is String cr	what sequence to use for EOL- asciiOnly <Boolean> default is false   if true, use \u escapes for all non-ASCII characters   most common control characters are still escaped- jsonMode <Boolean> default is false	if true, the follow changes occur	- strings are delimited with double quotes	- nil is encoded as null	- symbols are treated as strings	- only STON listClass and STON mapClass instances are allowed as composite objects	it is wise to also use either #error or #ignore as referencePolicy to avoid references- referencePolicy <#normal|#ignore|#error> default is #normal	if #normal, track and count object references and use references to implement sharing and break cycles	if #error, track object references and signal STONWriterError when a shared reference is encountered	if #ignore, don't track object references which might loop forever on cycles - keepNewLines <Boolean> default is false	if true, any newline sequence CR, LF or CRLF inside strings or symbols will not be escaped 	but will be written as the newline EOF convention	Note that in default STON mode I only use the following named character escapes: \b \t \n \f \' and \\ while in JSON mode \' is replaced by \"!!ByteArray class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Use a hex representation"		^ self readHexFrom: stonReader parseListSingleton! !!ByteArray methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!ByteArray methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Use a hex representation"		stonWriter writeObject: self listSingleton: self hex! !!Path class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	| elements |	elements := Array streamContents: [ :out |		stonReader parseListDo: [ :each | out nextPut: each ] ].	^ self withAll: elements! !!Path methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter 		writeObject: self 		streamShortList: [ :listWriter | 			self do: [ :each | listWriter add: each ] ]! !!MCFtpRepository methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076'!asRepositorySpecFor: aMetacelloMCProject	| dir |	dir := directory.	(directory at: 1) = $/		ifFalse: [ dir := '/', dir ].	^(aMetacelloMCProject repositorySpec)		description:  'ftp://', host, dir;	 	type: 'ftp';		username: user;		password: password;		yourself! !!MCFtpRepository methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 14:29'!username: aString	"For compatibility with MetacelloRepositorySpec"	^ self user: aString! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloIntegerLessThanSelf: anInteger	^anInteger < self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticIntegerLessThanSelf: anInteger    ^ anInteger < self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticStringLessThanSelf: aString    "string version components are always '<' integer component"    ^ true! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:47'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ aMetacelloVersonComponent metacelloSemanticIntegerLessThanSelf: self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloStringLessThanSelf: aString	"string version components are always '<' integer component"		^true! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloIntegerLessThanSelf: self! !!Integer methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeInteger: self! !!ClassDescription methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects	^ false! !!Association methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	self class == STON associationClass		ifTrue: [ stonWriter writeAssociation: self ]		ifFalse: [ super stonOn: stonWriter ]	! !!MCFetchBitbucketRepository class methodsFor: 'accessing' stamp: 'tobe 5/6/2020 09:35'!basicDescription  ^ 'bitbucket'! !!MCFetchBitbucketRepository class methodsFor: 'accessing' stamp: 'tobe 8/15/2020 09:16'!cacheDirectoryPath  <preference: 'Fetch BitBucket Cache' category: 'Metacello' description: 'Path used when downloading files from BitBucket. Ensure that the folder exists before changing it. Supersedes the "BitBucket Cache" preference.' type:    #'String'>  ^ super cacheDirectoryPath! !!MCFetchBitbucketRepository class methodsFor: 'testing' stamp: 'tobe 5/6/2020 09:35'!isEnabled	^true! !!MCFetchBitbucketRepository class methodsFor: 'private' stamp: 'tobe 5/6/2020 09:35'!projectZipUrlFor: projectPath versionString: versionString  ^ 'https://bitbucket.org/' , projectPath , '/get/' , versionString , '.zip'! !!MCFetchBitbucketRepository methodsFor: 'testing' stamp: 'ct 4/26/2021 18:46'!isProjectPathCaseSensitive	^ false! !!MCFetchBitbucketRepository methodsFor: 'private' stamp: 'tobe 5/6/2020 09:33'!normalizeTagsData: jsonObject  "return a dictionay mapping the tag name to the commit SHA"  | tagDict |  jsonObject    at: 'error'    ifPresent: [ :errorObject |       self        error:          'Error accessing tags for bitbucket project: ' , self projectPath printString            , ' -> ' , (errorObject at: 'message') printString            ,              ((errorObject at: 'detail')                ifNil: [ '' ]                ifNotNil: [ :detail | ' :: ' , detail printString ]) ].  tagDict := Dictionary new.  jsonObject    keysAndValuesDo: [ :tag :tagObject |       | sha |      sha := tagObject at: 'node'.      tagDict at: tag put: sha ].  ^ tagDict! !!MCFetchGithubRepository class methodsFor: 'private' stamp: 'tobe 5/3/2020 20:56'!basicDescription  ^ 'github'! !!MCFetchGithubRepository class methodsFor: 'accessing' stamp: 'tobe 8/15/2020 09:33'!cacheDirectoryPath  <preference: 'Fetch GitHub Cache' category: 'Metacello' description: 'Path used when downloading files from GitHub. Ensure that the folder exists before changing it. Supersedes the "GitHub Cache" preference.' type:    #'String'>  ^ super cacheDirectoryPath! !!MCFetchGithubRepository class methodsFor: 'accessing' stamp: 'tobe 5/7/2020 09:27'!eTagsCache  "To avoid GitHub rate limiting problems, we are caching the ETags for the tag request: https://developer.github.com/v3/#conditional-requests"  ETagsCache ifNil: [ ETagsCache := Dictionary new ].  ^ ETagsCache! !!MCFetchGithubRepository class methodsFor: 'initialization' stamp: 'tobe 5/7/2020 09:27'!flushETagsCache  "mainly needed for tests .... but if you want to pare down object consumption..."  "self flushETagsCache"  ETagsCache := nil! !!MCFetchGithubRepository class methodsFor: 'private' stamp: 'tobe 5/7/2020 09:24'!projectTagsUrlFor: projectPath  ^ 'https://api.github.com/repos/' , projectPath , '/tags'! !!MCFetchGithubRepository class methodsFor: 'private' stamp: 'ct 10/12/2020 19:38'!projectZipUrlFor: projectPath versionString: versionString	^ 'https://api.github.com/repos/' , projectPath , '/zipball/' , versionString! !!MCFetchGithubRepository methodsFor: 'private' stamp: 'tobe 7/13/2020 07:56'!downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current    downloadJSON: tagsUrl    eTagsCache: self class eTagsCache    eTagsKey: self projectPath    username: self class siteUsername    pass: self class sitePassword.  ^ self normalizeTagsData: jsonObject! !!MCFetchGithubRepository methodsFor: 'testing' stamp: 'ct 4/26/2021 18:46'!isProjectPathCaseSensitive	^ false! !!MCFetchGithubRepository methodsFor: 'private' stamp: 'tobe 5/3/2020 20:55'!normalizeTagsData: jsonObject  "return a dictionay mapping the tag name to the commit SHA"  | tagDict |  jsonObject isDictionary    ifTrue: [       jsonObject        at: 'message'        ifPresent: [ :errorString |           self            error:              'Error accessing tags for github project: ' , self projectPath printString                , ' -> ' , errorString printString ] ].  tagDict := Dictionary new.  jsonObject    do: [ :tagObject |       | tag commit |      tag := tagObject at: 'name'.      commit := tagObject at: 'commit'.      tagDict at: tag put: (commit at: 'sha') ].  ^ tagDict! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:56'!basicDescription  ^ self subclassResponsibility! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 8/15/2020 09:01'!cacheDirectory  self resetCacheDirectoryIfInvalid.  repoCacheDirectory ifNil: [ repoCacheDirectory := self defaultCacheDirectory ].  ^ repoCacheDirectory! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 8/15/2020 09:43'!cacheDirectory: aDirectory  "explicitly set repoCacheDirectory"  repoCacheDirectory := aDirectory! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 5/3/2020 21:16'!cacheDirectoryFor: projectPath	| cacheDirectory projectDirectory |		cacheDirectory := self cacheDirectory.	projectDirectory := MetacelloPlatform current directoryFromPath: projectPath relativeTo: cacheDirectory.	MetacelloPlatform current ensureDirectoryExists: projectDirectory.	^ projectDirectory! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 8/15/2020 08:53'!cacheDirectoryPath  ^ MCFileTreeFileUtils current directoryPathString: self cacheDirectory! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 8/15/2020 09:42'!cacheDirectoryPath: aString  self    cacheDirectory:      (aString        ifEmpty: [  ]        ifNotEmpty: [ MetacelloPlatform current fileHandleOn: aString ])! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 5/3/2020 21:17'!defaultCacheDirectory  | defaultDirectory cacheDirectory |  defaultDirectory := MetacelloPlatform current defaultDirectory.  cacheDirectory := MetacelloPlatform current    directoryFromPath: self basicDescription , '-cache'    relativeTo: defaultDirectory.  MetacelloPlatform current ensureDirectoryExists: cacheDirectory.  ^ cacheDirectory! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:53'!description  ^ self basicDescription , '://'! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 8/15/2020 09:02'!downloadCache  repoDownloadCache ifNil: [ repoDownloadCache := Dictionary new ].  ^ repoDownloadCache! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 5/3/2020 21:16'!downloadCacheKey: projectPath version: versionString  ^ projectPath , ':::' , versionString! !!MCFilesystemFetchOnlyRepository class methodsFor: 'initialization' stamp: 'tobe 8/15/2020 09:02'!flushDownloadCache  "self flushDownloadCache"  repoDownloadCache := nil! !!MCFilesystemFetchOnlyRepository class methodsFor: 'utility' stamp: 'tobe 5/6/2020 10:00'!flushProjectEntry: projectPath version: versionString    self downloadCache removeKey: (self downloadCacheKey: projectPath version: versionString) ifAbsent: [  ]! !!MCFilesystemFetchOnlyRepository class methodsFor: 'initialization' stamp: 'tobe 5/6/2020 09:58'!initialize  "self initialize"	(Smalltalk classNamed: #SessionManager)		ifNotNil: [ :c | c default perform: #registerNetworkClassNamed: with: self name ]		ifNil:[ Smalltalk addToStartUpList: self ].  self flushDownloadCache.  self resetCacheDirectoryIfInvalid! !!MCFilesystemFetchOnlyRepository class methodsFor: 'accessing' stamp: 'tobe 5/6/2020 09:57'!isAbstract    ^ true! !!MCFilesystemFetchOnlyRepository class methodsFor: 'testing' stamp: 'tobe 5/6/2020 10:00'!isEnabled	^false! !!MCFilesystemFetchOnlyRepository class methodsFor: 'instance creation' stamp: 'tobe 5/3/2020 20:53'!location: locationUrl    ^ self location: locationUrl version: nil! !!MCFilesystemFetchOnlyRepository class methodsFor: 'instance creation' stamp: 'ct 11/1/2020 21:45'!location: locationUrl username: username password: password	^ (self location: locationUrl)		username: username password: password;		yourself! !!MCFilesystemFetchOnlyRepository class methodsFor: 'instance creation' stamp: 'tobe 5/3/2020 20:53'!location: locationUrl version: versionString    ^ self parseLocation: locationUrl version: versionString! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 5/6/2020 21:27'!parseLocation: locationUrl version: versionString  "self 	parseLocation: 'github://dalehenrich/MetacelloRepository:master/monticello/repos/itory/path'	version: nil     "  | projectPath projectVersion repoPath headerSize desc projectDelim repoDelim versionDelim |  headerSize := self description size.  desc := locationUrl.  desc := desc copyFrom: headerSize + 1 to: desc size.  projectVersion := repoPath := nil.  projectDelim := desc indexOf: $/.  repoDelim := desc indexOf: $/ startingAt: projectDelim + 1.  (versionDelim := desc indexOf: $:) == 0    ifTrue: [       repoDelim == 0        ifTrue: [ projectPath := desc ]        ifFalse: [           projectPath := desc copyFrom: 1 to: repoDelim - 1.          repoPath := desc copyFrom: repoDelim + 1 to: desc size ] ]    ifFalse: [       projectPath := desc copyFrom: 1 to: versionDelim - 1.      repoDelim == 0        ifTrue: [ projectVersion := desc copyFrom: versionDelim + 1 to: desc size ]        ifFalse: [           projectPath := desc copyFrom: 1 to: versionDelim - 1.          self            parseProjectVersionField: [ :pv :rp |               projectVersion := pv.              repoPath := rp ]            desc: desc            versionDelim: versionDelim ] ].  versionString ~~ nil    ifTrue: [ projectVersion := versionString ].  ^ self new    projectPath: projectPath    projectVersion: projectVersion    repoPath: repoPath! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 5/3/2020 20:54'!parseProjectVersionField: parseBlock desc: desc versionDelim: versionDelim  "Issue #234: have to allow for commitish containing slashes"  | strm done escaped repoDelim |  strm := WriteStream on: String new.  repoDelim := versionDelim + 1.  escaped := done := false.  [ done ]    whileFalse: [       | char |      repoDelim > desc size        ifTrue: [ done := true ]        ifFalse: [           char := desc at: repoDelim.          char == $\            ifTrue: [               escaped                ifTrue: [                   "$\ not legal in branch name ... literally ignored"                  escaped := false ]                ifFalse: [ escaped := true ] ]            ifFalse: [               char == $/                ifTrue: [                   escaped                    ifFalse: [ done := true ] ].              done                ifFalse: [ strm nextPut: char ].              escaped := false ].          repoDelim := repoDelim + 1 ] ].  repoDelim := repoDelim - 1.  parseBlock    value: strm contents    value: (desc copyFrom: repoDelim + 1 to: desc size)! !!MCFilesystemFetchOnlyRepository class methodsFor: 'version patterns' stamp: 'tobe 5/6/2020 10:01'!projectVersionFromString: aString  "strip leading $v if present and return an instance of MetacelloVersionNumber"  | versionString |  versionString := aString.  (versionString beginsWith: 'v')    ifTrue: [ versionString := versionString copyFrom: 2 to: versionString size ].  ^ MetacelloVersionNumber fromString: versionString! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 5/3/2020 21:18'!projectZipUrlFor: projectPath versionString: versionString 	^self subclassResponsibility! !!MCFilesystemFetchOnlyRepository class methodsFor: 'private' stamp: 'tobe 8/15/2020 09:01'!resetCacheDirectoryIfInvalid  "Reset if invalid"  repoCacheDirectory notNil    and: [       (MCFileTreeFileUtils current directoryExists: repoCacheDirectory)        ifFalse: [ repoCacheDirectory := nil ] ]! !!MCFilesystemFetchOnlyRepository class methodsFor: 'site credentials' stamp: 'ct 11/16/2020 12:31'!sitePassword	"Default password or access token used to authenticate to all repositories of this repository provider. Optional. Can be overridden using Metacello >> #password:. Depending on the repository provider, the username might be optional if an access token is provided as a password. See https://github.com/Metacello/metacello/pull/534."	^ sitePassword! !!MCFilesystemFetchOnlyRepository class methodsFor: 'site credentials' stamp: 'ct 11/16/2020 12:31'!sitePassword: aString	"Default password or access token used to authenticate to all repositories of this repository provider. Optional. Can be overridden using Metacello >> #password:. Depending on the repository provider, the username might be optional if an access token is provided as a password. See https://github.com/Metacello/metacello/pull/534."	sitePassword := aString! !!MCFilesystemFetchOnlyRepository class methodsFor: 'site credentials' stamp: 'ct 11/16/2020 12:31'!siteUsername	"Default username used to authenticate to all repositories of this repository provider. Optional. Can be overridden using Metacello >> #username:. See https://github.com/Metacello/metacello/pull/534."	^ siteUsername! !!MCFilesystemFetchOnlyRepository class methodsFor: 'site credentials' stamp: 'ct 11/16/2020 12:32'!siteUsername: aString	"Default username used to authenticate to all repositories of this repository provider. Optional. Can be overridden using Metacello >> #username:. See https://github.com/Metacello/metacello/pull/534."	siteUsername := aString! !!MCFilesystemFetchOnlyRepository class methodsFor: 'site credentials' stamp: 'tobe 5/7/2020 09:31'!siteUsername: username sitePassword: pass  "MCFetchBitbucketRepository siteUsername: '' sitePassword: ''"  "MCFetchGitHubRepository siteUsername: '' sitePassword: ''"  self    siteUsername: username;    sitePassword: pass! !!MCFilesystemFetchOnlyRepository class methodsFor: 'system startup' stamp: 'tobe 5/6/2020 10:00'!startUp: resuming    "Flush the GitHub download cache"    resuming        ifTrue: [ self flushDownloadCache ]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 13:12'!allFileNames	^ self repositoryReader allFileNames! !!MCFilesystemFetchOnlyRepository methodsFor: 'packages' stamp: 'tobe 5/7/2020 13:31'!allPackageAndBranchNames	^ self repositoryReader allPackageAndBranchNames! !!MCFilesystemFetchOnlyRepository methodsFor: 'packages' stamp: 'tobe 5/6/2020 10:24'!allPackageNames	^ self repositoryReader allPackageNames! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/7/2020 09:23'!allVersionNames	"https://github.com/dalehenrich/filetree/issues/132"		^ self readableFileNames collect: [ :each | each versionName ] ! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 09:11'!asRepositorySpecFor: aMetacelloMCProject  ^ aMetacelloMCProject repositorySpec    description: self description;    type: self class basicDescription;    yourself! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/6/2020 10:25'!basicStoreVersion: aVersion	self repositoryReader basicStoreVersion: aVersion! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 10/12/2020 07:56'!cacheAllFileNamesDuring: aBlock	^ self repositoryReader cacheAllFileNamesDuring: aBlock! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/7/2020 11:22'!cacheAllFilenames	self repositoryReader cacheAllFilenames! !!MCFilesystemFetchOnlyRepository methodsFor: 'testing' stamp: 'tobe 5/6/2020 21:39'!cacheReferences	^ false! !!MCFilesystemFetchOnlyRepository methodsFor: 'file utils' stamp: 'tobe 5/7/2020 10:16'!canReadFileNamed: aString	^ self repositoryReader canReadFileNamed: aString! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'tobe 5/3/2020 22:18'!canUpgradeTo: anMCGitBasedRepository  ((anMCGitBasedRepository isKindOf: self class) or: [anMCGitBasedRepository isKindOf: MCGitBasedNetworkRepository])    ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath    and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 13:33'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	^ self repositoryReader closestAncestorVersionFor: anAncestry ifNone: errorBlock! !!MCFilesystemFetchOnlyRepository methodsFor: 'descriptions' stamp: 'tobe 5/3/2020 20:58'!description  | desc |  desc := self class description , self projectPath , ':'    , self projectVersionEscaped.  self repoPath isEmpty    ifTrue: [ ^ desc ].  ^ desc , '/' , self repoPath! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 4/22/2021 09:10'!directory  directory    ifNil: [      directory := self        projectDirectoryFrom: self projectPath        version: self projectVersion.      self repoPath isEmpty        ifFalse: [           directory := MetacelloPlatform current            directoryFromPath: (self repoPath copy replaceAll: $/ with: MCFileTreeFileDirectoryUtils pathNameDelimiter)            relativeTo: directory ] ]    ifNotNil: [       (MCFileTreeFileUtils current directoryExists: directory)        ifFalse: [           self flushCache.          ^ self directory ] ].    repositoryReader ifNotNil: [repositoryReader directory: directory].  ^ directory! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/3/2020 20:54'!downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current    downloadJSON: tagsUrl    username: self class siteUsername    pass: self class sitePassword.  ^ self normalizeTagsData: jsonObject! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'tobe 5/18/2020 16:19'!flushCache  "the directory acts like a cache since we download the directory from a git-based repository (github, bitbucket, etc.)"  [	super flushCache.	repositoryReader ifNotNil: [:reader | reader flushCache]  ]    on: Error    do: [ :ex |       Transcript        cr;        show:            'Error for: ' , self description printString , ' during flushCache: '                , ex description printString ].  self class flushDownloadCache.  repositoryReader := nil.  directory := nil! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'tobe 5/7/2020 12:51'!flushForScriptGet    self class flushProjectEntry: self projectPath version: self projectVersion.    directory := nil! !!MCFilesystemFetchOnlyRepository methodsFor: 'gofer-core-accessing' stamp: 'tobe 5/7/2020 13:29'!goferPriority	^ 5! !!MCFilesystemFetchOnlyRepository methodsFor: 'gofer-core-accessing' stamp: 'tobe 5/4/2020 00:23'!goferReferences	| versionNames |	versionNames := [ self allVersionNames ]		on: Error		do: [ :error | ^ GoferRepositoryError signal: error messageText repository: self ].	^ versionNames		collect: [ :each | GoferResolvedReference name: each repository: self ]! !!MCFilesystemFetchOnlyRepository methodsFor: 'gofer-core-accessing' stamp: 'tobe 5/6/2020 10:25'!goferVersionFrom: aVersionReference	^ self repositoryReader goferVersionFrom: aVersionReference! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'ct 4/26/2021 18:38'!hasNoLoadConflicts: anMCGitBasedRepository	| projectPath otherProjectPath |	(anMCGitBasedRepository isKindOf: self class)		ifFalse: [ ^ false ].		projectPath := self projectPath.	otherProjectPath := anMCGitBasedRepository projectPath.	self isProjectPathCaseSensitive ifFalse: [		projectPath := projectPath asLowercase.		otherProjectPath := otherProjectPath asLowercase].		^ projectPath = otherProjectPath		and: [ self repoPath = anMCGitBasedRepository repoPath ]		and: [ self projectVersion = anMCGitBasedRepository projectVersion ]! !!MCFilesystemFetchOnlyRepository methodsFor: 'comparing' stamp: 'tobe 5/3/2020 21:08'!hash    ^ self description hash! !!MCFilesystemFetchOnlyRepository methodsFor: 'versions' stamp: 'tobe 5/7/2020 13:35'!includesVersionNamed: aString 	| comparable |	comparable := ((aString endsWith: '.mcz') and: [ aString size > 4 ])		ifTrue: [ aString allButLast: 4 ]		ifFalse: [ aString ].	^ self allVersionNames includes: comparable! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'tobe 5/6/2020 10:12'!initialize    super initialize.    directory := nil.	"we'll lazily create the directory instance"! !!MCFilesystemFetchOnlyRepository methodsFor: 'testing' stamp: 'ct 4/26/2021 18:45'!isProjectPathCaseSensitive	^ FileDirectory default isCaseSensitive! !!MCFilesystemFetchOnlyRepository methodsFor: 'testing' stamp: 'tobe 5/15/2020 20:27'!isTonelRepo	^ (self directory fileExists: '.properties') and: [		self directory readOnlyFileNamed: '.properties' do: [:stream |			((STONJSON fromStream: stream) at: #format ifAbsent: [nil]) = #tonel]]! !!MCFilesystemFetchOnlyRepository methodsFor: 'testing' stamp: 'tobe 5/18/2020 15:27'!isValid    ^ true! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 12:51'!metacelloProjectClassFor: aScriptEngine    ^ MetacelloMCBaselineProject! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/3/2020 20:56'!normalizeTagsData: jsonObject  ^ self subclassResponsibility! !!MCFilesystemFetchOnlyRepository methodsFor: 'notifying' stamp: 'tobe 5/7/2020 13:36'!notfyList	^ self repositoryReader notifyList! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'ct 11/1/2020 21:50'!password	^ password isEmptyOrNil		ifFalse: [password]		ifTrue: [self class sitePassword]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'ct 11/16/2020 12:42'!password: aString	"Password or access token to authenticate to the repository. Optional. Depending on the repository provider, the username might be optional if an access token is provided as a password. Can be provided via Metacello >> #username: or self class >> #siteUsername:."	password := aString.! !!MCFilesystemFetchOnlyRepository methodsFor: 'utility' stamp: 'ct 11/1/2020 21:56'!projectDirectoryFrom: projectPath version: versionString	| mcPlatform theCacheDirectory projectDirectory downloadCacheKey cachePath pid |	downloadCacheKey := self class		downloadCacheKey: projectPath		version: versionString.	mcPlatform := MetacelloPlatform current.	theCacheDirectory := mcPlatform		directoryFromPath: versionString		relativeTo: (self class cacheDirectoryFor: projectPath).	cachePath := self class downloadCache at: downloadCacheKey ifAbsent: [  ].	(cachePath isNil		or: [ (projectDirectory := mcPlatform				directoryFromPath: cachePath				relativeTo: theCacheDirectory) exists not ])		ifTrue: [ | url archive directory zipFileName |			MetacelloScriptGitBasedDownloadNotification new				projectPath: projectPath;				versionString: versionString;				signal.	"for testing purposes"			mcPlatform ensureDirectoryExists: theCacheDirectory.			url := self class				projectZipUrlFor: projectPath				versionString: versionString.			pid := mcPlatform processPID.			zipFileName := mcPlatform				tempFileFor:					self class basicDescription , '-' , pid , '-'						, (downloadCacheKey select: [ :c | c isAlphaNumeric ])				suffix: '.zip'.			archive := mcPlatform				downloadZipArchive: url				to: zipFileName				username: self username				pass: self password.			directory := mcPlatform				directoryFromPath: (cachePath := archive members first fileName)				relativeTo: theCacheDirectory.			archive close.			directory exists				ifTrue: [ mcPlatform deleteFileNamed: zipFileName ]				ifFalse: [ mcPlatform						extractRepositoryFrom: zipFileName						to: theCacheDirectory fullName ].			self class downloadCache at: downloadCacheKey put: cachePath.			projectDirectory := mcPlatform				directoryFromPath: cachePath				relativeTo: theCacheDirectory ].	^ projectDirectory! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:58'!projectPath    ^ projectPath! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:57'!projectPath: anObject    projectPath := anObject! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'tobe 5/3/2020 20:54'!projectPath: aProjectPath projectVersion: aProjectVersion repoPath: aRepoPath  self projectPath: aProjectPath.  self projectVersion: aProjectVersion.	"Important that projectVersion be set AFTER projectPath"  self repoPath: aRepoPath! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/7/2020 09:30'!projectTagsUrlFor: aProjectPath  ^ self class projectTagsUrlFor: aProjectPath! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:58'!projectVersion    (projectVersion == nil or: [ projectVersion isEmpty ])        ifTrue: [ projectVersion := 'master' ].    ^ projectVersion! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:57'!projectVersion: aString  "Important that projectVersion be set AFTER projectPath, as projectPath needed for resolving projectVersionPattern"  | x |  aString    ifNil: [       projectVersion := aString.      ^ self ].  (x := aString    findDelimiters:      {$#.      $*.      $?}    startingAt: 1) <= aString size    ifTrue: [ self resolveProjectVersionPattern: aString ]    ifFalse: [ projectVersion := aString ]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:58'!projectVersionEscaped  | pv |  pv := self projectVersion.  (projectVersion includes: $/)    ifTrue: [ ^ pv copyReplaceAll: '/' with: '\/' ].  ^ pv! !!MCFilesystemFetchOnlyRepository methodsFor: 'file utils' stamp: 'tobe 5/3/2020 21:31'!readStreamForFileNamed: aString do: aBlock    ^ aBlock value: self directory! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/6/2020 10:25'!readableFileNames	^ self repositoryReader readableFileNames! !!MCFilesystemFetchOnlyRepository methodsFor: 'testing' stamp: 'tobe 5/6/2020 10:25'!readonly	^ true! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 13:36'!refresh	super refresh.	self flushCache! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'ct 11/1/2020 21:51'!repoPath	^ repoPath ifNil: [ | basicDirectory |		" if we were not given a repo path, there may be a .project file with more info "		basicDirectory := self			projectDirectoryFrom: self projectPath			version: self projectVersion.				repoPath := (basicDirectory fileExists: '.project')			ifTrue: [basicDirectory readOnlyFileNamed: '.project' do: [:str | (STONJSON fromStream: str) at: #srcDirectory ifAbsent: ['']]]			ifFalse: ['']]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/3/2020 20:57'!repoPath: anObject    repoPath := anObject! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 12:52'!repositoryBranchName  "for git-based network repos, answer the value of the projectVersion field"  ^ self projectVersion! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 13:25'!repositoryDescription  ^ self description , ' [' , self repositoryVersionString , ':'    , self repositoryBranchName , ']'! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/22/2020 19:59'!repositoryReader		" try accessing the directory once to make sure it exists "	self directory.		^ repositoryReader ifNil: [		repositoryReader := self isTonelRepo			ifTrue: [				Smalltalk					at: #TonelRepository					ifPresent: [: cl | cl new directory: self directory]					ifAbsent: [						MCTonelMissing new signal.						" if the user confirmed our request to install, we can try again "						(Smalltalk at: #TonelRepository) directory: self directory]]			ifFalse: [MCFileTreeRepository new directory: self directory]]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'tobe 5/7/2020 12:52'!repositoryVersionString  "for git-based network repos, answer the SHA associated with the download: a commit SHA or tag SHA"  | versionComponents versionElement pathElements gitBasedPath repositoryDirPath projectDirPath projectDir projectVersionDir |  repositoryDirPath := self directory fullName.  projectDir := self class cacheDirectoryFor: self projectPath.  projectVersionDir := MCFileTreeFileUtils current    directoryFromPath: self projectVersion    relativeTo: projectDir.  projectDirPath := projectVersionDir fullName.  (repositoryDirPath beginsWith: projectDirPath)    ifFalse: [ ^ self projectVersion ].  gitBasedPath := repositoryDirPath    copyFrom: projectDirPath size + 2    to: repositoryDirPath size.  pathElements := gitBasedPath findTokens: '/'.  versionElement := pathElements at: 1.  versionComponents := versionElement findTokens: '-'.  ^ versionComponents last! !!MCFilesystemFetchOnlyRepository methodsFor: 'private' stamp: 'tobe 5/3/2020 21:07'!resolveProjectVersionPattern: aString  "aString must conform to the syntax for MetacelloVersionNumber with the exception that aString may have a leading $v which is stripped before conversion to a MetacelloVersionNumber patterm"  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath    ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (self class projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys    collect: [ :tagName |       | tagVersion |      tagVersion := self class projectVersionFromString: tagName.      tagVersion -> tagName ].  matchingTags := tagAssocs select: [ :assoc | assoc key match: patternString ].  matchingTags isEmpty    ifTrue: [       projectVersion := aString.      ^ self        error:          'No tags matching the pattern ' , aString printString            , ' found for repository description '            , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [ :a :b | a key <= b key ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag value! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'ct 11/1/2020 21:50'!username	^ username isEmptyOrNil		ifFalse: [username]		ifTrue: [self class siteUsername]! !!MCFilesystemFetchOnlyRepository methodsFor: 'accessing' stamp: 'ct 11/16/2020 12:41'!username: aString	"Username to authenticate to the repository. Optional. Can be provided via Metacello >> #username: or self class >> #siteUsername:."	username := aString.! !!MCFilesystemFetchOnlyRepository methodsFor: 'initialize-release' stamp: 'ct 11/1/2020 21:44'!username: aString password: anotherString	self username: aString.	self password: anotherString.! !!MCFilesystemFetchOnlyRepository methodsFor: 'versions' stamp: 'tobe 5/6/2020 10:25'!versionNamed: aMCVersionName	^ self repositoryReader versionNamed: aMCVersionName! !!MCFilesystemFetchOnlyRepository methodsFor: 'versions' stamp: 'tobe 5/6/2020 10:27'!versionNamesForPackageNamed: aString	^ self repositoryReader versionNamesForPackageNamed: aString! !!MCFilesystemFetchOnlyRepository methodsFor: 'private-files' stamp: 'tobe 5/7/2020 13:37'!versionReaderForFileNamed: aString do: aBlock	^ self repositoryReader versionReaderForFileNamed: aString do: aBlock! !!MCFilesystemFetchOnlyRepository methodsFor: 'versions' stamp: 'tobe 5/6/2020 10:27'!versionWithInfo: aVersionInfo ifAbsent: aBlock	^ self repositoryReader versionWithInfo: aVersionInfo ifAbsent: aBlock! !!MCRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!asRepositorySpecFor: aMetacelloMCProject	self subclassResponsibility! !!MCRepository methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 15:04:55'!cacheReferences	^ true! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 7/24/2012 21:46'!flushForScriptGet    "noop"! !!MCRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/11/2009 22:31'!goferPriority	^ 0! !!MCRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/9/2009 20:50'!goferReferences	^ #()! !!MCRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/12/2009 11:29'!goferVersionFrom: aVersionReference	self error: 'Unable to load from ' , self printString! !!MCRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!metacelloProjectClassFor: aScriptEngine    ^ MetacelloMCProject! !!MCRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!projectVersion: aString    "noop"! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 05/09/2014 10:02'!repositoryBranchName  "extract a branch name from the repository ... if possible"  ^ ''! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 09/04/2014 13:49'!repositoryDescription  "return a description that includes a repositoryVersionString and repositoryBranchName if present"  ^ self description! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 09/04/2014 13:45'!repositoryVersionString  "extract a version string from the repository ... if possible"  ^ ''! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/7/2012 13:11'!asMetacelloAttributeList    ^ {self}! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/7/2012 13:44'!asMetacelloAttributePath    ^ MetacelloMethodSectionPath with: {self}! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064'!setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: {self} do: aBlock! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064'!setForVersion: aString withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: {self} version: aString! !!Symbol methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:54'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec    self precedence == 0        ifTrue: [ self error: 'Invalid selector' ].    aMetacelloSpec        setPostLoadDoIt:            (aMetacelloSpec project valueHolderSpec                value: self;                yourself)! !!Symbol methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:55'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec    self precedence == 0        ifTrue: [ self error: 'Invalid selector' ].    aMetacelloSpec        setPreLoadDoIt:            (aMetacelloSpec project valueHolderSpec                value: self;                yourself)! !!Symbol methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeSymbol: self! !!MCWorkingCopy methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!metacelloPackageNameWithBranch	"answer array with package name and package name with branch name"	ancestry ancestors isEmpty		ifTrue: [ 			^ {(package name).			(package name)} ].	^ (GoferVersionReference name: self ancestors first name) metacelloPackageNameWithBranch! !!MCTonelMissing methodsFor: 'priv handling' stamp: 'tobe 5/18/2020 06:45'!defaultAction	(UIManager default confirm: 'Tonel support is missing. Install from github://squeak-smalltalk/squeak-tonel:squeak?')		ifTrue: [			Metacello new				repository: 'github://squeak-smalltalk/squeak-tonel:squeak';				baseline: 'Tonel';				load]		ifFalse: [self error: 'Tonel support is missing.']! !!MCTonelMissing methodsFor: 'priv handling' stamp: 'tobe 5/6/2020 10:16'!isResumable	^ true! !!MetacelloCleanNotification class methodsFor: 'exceptioninstantiator' stamp: '9/28/2017 08:54:38'!signal: aMetacelloVersion	^ self new signal: aMetacelloVersion! !!MetacelloCleanNotification methodsFor: 'signaling' stamp: '9/28/2017 08:54:38'!signal: aMetacelloVersion	self version: aMetacelloVersion.	^ self signal! !!MetacelloCleanNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!version	^ version! !!MetacelloCleanNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!version: anObject	version := anObject! !!MetacelloClearStackCacheNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!cacheNames	^ cacheNames! !!MetacelloClearStackCacheNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!cacheNames: anArray	cacheNames := anArray! !!MetacelloClearStackCacheNotification methodsFor: 'signaling' stamp: '9/28/2017 08:54:38'!signal: anArray	"Signal the occurrence of an exceptional condition with a specified cacheName."	self cacheNames: anArray.	^ self signal! !!MetacelloErrorInProjectConstructionNotification class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!versionString: aString exception: anException    ^ self new        versionString: aString;        exception: anException;        signal! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'exception description' stamp: '9/28/2017 08:54:38'!defaultAction    "Answer false if you want the version recorded in the errorMap.	Answer true if you want to go ahead and throw the error"    ^ false! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!exception	^ exception! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!exception: anObject	exception := anObject! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	^ versionString! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject	versionString := anObject! !!MetacelloIgnorePackageLoaded class methodsFor: 'signalling' stamp: '9/28/2017 08:54:38'!signal: aMetacelloPackageSpec	^(self new packageSpec: aMetacelloPackageSpec) signal! !!MetacelloIgnorePackageLoaded methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!defaultAction  "Default action is to NOT ignore whether or not the package is loaded.    Basically allow for package level ignoreImage. "  ^ false! !!MetacelloIgnorePackageLoaded methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpec   ^packageSpec! !!MetacelloIgnorePackageLoaded methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpec: anObject   packageSpec := anObject! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectPath	^ projectPath! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectPath: anObject	projectPath := anObject! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	^ versionString! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject	versionString := anObject! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!defaultAction  self existingProjectRegistration locked    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/263"      ^ self useIncoming ].  ^ MetacelloConflictingProjectError    signal:      'Load Conflict between existing ' , self existingProjectRegistration printString        , ' and ' , self newProjectRegistration printString! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleConflict: self! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operationString  ^ 'load with conflicts'! !!MetacelloAllowLockedProjectChange methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!break  ^ self allow! !!MetacelloAllowLockedProjectChange methodsFor: 'private' stamp: '9/28/2017 08:54:38'!checkAllowed  "noop ... if user decided to allow lock to be broken, then so be it"! !!MetacelloAllowLockedProjectChange methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!defaultAction  Warning    signal:      'LOCK ENFORCED: Attempt to ' , self operationString printString        , ' new project: ' , self newProjectRegistration printString printString        , ' when existing project: '        , self existingProjectRegistration printString printString        , ' is locked. New project not loaded. Use #onLock: to intercept.'.  ^ self disallow! !!MetacelloAllowLockedProjectChange methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine  ^ aScriptEngine handleLock: self! !!MetacelloAllowLockedProjectChange methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!honor  ^ self disallow! !!MetacelloAllowLockedProjectChange methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operationString  ^ operationString! !!MetacelloAllowLockedProjectChange methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operationString: aString  operationString := aString! !!MetacelloAllowProjectDowngrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!defaultAction  "Default for Downgrade is to disallow, but still should check for locks"  self checkAllowed.  ^ super defaultAction! !!MetacelloAllowProjectDowngrade methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock    ^ onDownGradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistration! !!MetacelloAllowProjectDowngrade methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleDowngrade: self! !!MetacelloAllowProjectDowngrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operationString  ^ 'downgrade to'! !!MetacelloAllowProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!defaultAction    "Default for Upgrade is to allow"    self checkAllowed.    ^ self newProjectRegistration! !!MetacelloAllowProjectUpgrade methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock    ^ onUpgradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistration! !!MetacelloAllowProjectUpgrade methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleUpgrade: self! !!MetacelloAllowProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operationString  ^ 'upgrade to'! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!allow    self checkAllowed.    self resume: self newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!allowEvenIfLocked  "for internal ScriptEngine use only. from the Scripting API use:		onLocked: [:ex | ex allow]		"  self resume: self newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'private' stamp: '9/28/2017 08:54:38'!checkAllowed  self existingProjectRegistration locked    ifTrue: [       self        resume:          (MetacelloAllowLockedProjectChange new            operationString: self operationString;            existingProjectRegistration: self existingProjectRegistration;            newProjectRegistration: self newProjectRegistration;            signal) ]! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!defaultAction    "Result of signal should be the projectRegistration to be used to perform the load ... default is to disallow"    ^ self existingProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!disallow    "default action"    self resume: self existingProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!existingProjectRegistration	^ existingProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!existingProjectRegistration: anObject	existingProjectRegistration := anObject! !!MetacelloResolveProjectUpgrade methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock    self subclassResponsibility! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!newProjectRegistration	^ newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!newProjectRegistration: anObject	newProjectRegistration := anObject! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operationString    self subclassResponsibility! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!useExisting  "to be deprecated: useLoaded"  self disallow! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!useIncoming  self allow! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!useLoaded  self disallow! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!useNew  "to be deprecated: useIncoming"  self allow! !!MetacelloScriptEnsureProjectLoadedForDevelopment methodsFor: 'exception handling' stamp: '9/28/2017 08:54:38'!defaultAction    "Go ahead and download a new copy of configuration because blessing is #development"    ^ true! !!MetacelloScriptEnsureProjectLoadedForDevelopment methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleEnsureProjectLoadedForDevelopment: self! !!MetacelloScriptNotification methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    self subclassResponsibility! !!MetacelloLookupBaselineSpecForEnsureLoad methodsFor: 'exception description' stamp: '9/28/2017 08:54:38'!defaultAction	"Answer <true> if you want to ensure the load of the baseline ... default is to load the baseline"	^ true! !!MetacelloLookupBaselineSpecForEnsureLoad methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine	^ aScriptEngine handleLookupBaselineSpecForEnsureLoad: self! !!MetacelloLookupProjectSpec methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleLookupProjectSpec: self! !!MetacelloLookupProjectSpecForLoad methodsFor: 'exception description' stamp: '9/28/2017 08:54:38'!defaultAction    "Result of signal should be the MetacelloProjectSpecForLoad to be used to perform the load. 	Create a MetacelloProjectSpecForLoad and use the overrideProjectSpec: if you want to supply a different projectSpec"    ^ MetacelloProjectSpecForLoad new        projectSpec: self projectSpec;        yourself! !!MetacelloLookupProjectSpecForLoad methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleLookupProjectSpecForLoad: self! !!MetacelloProjectSpecLoadedNotification methodsFor: 'exception description' stamp: '9/28/2017 08:54:38'!defaultAction    ^ nil! !!MetacelloProjectSpecLoadedNotification methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleProjectSpecLoaded: self! !!MetacelloScriptProjectSpecNotification methodsFor: 'exception description' stamp: '9/28/2017 08:54:38'!defaultAction    "Result of signal should be the projectSpec to be used to perform the load"    ^ self projectSpec! !!MetacelloScriptProjectSpecNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec    ^ projectSpec! !!MetacelloScriptProjectSpecNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec: anObject    projectSpec := anObject! !!MetacelloSkipDirtyPackageLoad class methodsFor: 'signalling' stamp: '9/28/2017 08:54:38'!signal: aMetacelloPackageSpec	^(self new packageSpec: aMetacelloPackageSpec) signal! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!defaultAction	"Default action is to skip the load of a dirty package"	^true! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpec	^packageSpec! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpec: aMetacelloPackageSpec	packageSpec := aMetacelloPackageSpec! !!MetacelloValidationNotification class methodsFor: 'exceptioninstantiator' stamp: '9/28/2017 08:54:38'!signal: aMetacelloValidationIssue	^ self new signal: aMetacelloValidationIssue! !!MetacelloValidationNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!issue	^ issue! !!MetacelloValidationNotification methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!issue: anObject	issue := anObject! !!MetacelloValidationNotification methodsFor: 'signaling' stamp: '9/28/2017 08:54:38'!signal: aMetacelloValidationIssue	self issue: aMetacelloValidationIssue.	^ self signal! !!RunArray class methodsFor: '*STON-Text support' stamp: '5/7/2020 21:10:00'!fromSton: stonReader	"Overwritten to get back the standard object behavior"	^ self new		fromSton: stonReader;		yourself! !!RunArray methodsFor: '*STON-Text support' stamp: '5/7/2020 21:10:00'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		stonReader parseNamedInstVarsFor: self! !!RunArray methodsFor: '*STON-Text support' stamp: '5/7/2020 21:10:00'!stonOn: stonWriter	"Overwritten to get back the standard object behavior"		stonWriter writeObject: self! !!Class class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	| theClassName theClass |	theClassName := stonReader parseListSingleton.	theClass := self environment at: theClassName.	^ theClass! !!Class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter 		writeObject: self 		listSingleton: self name asSymbol! !!Number methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!Number methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeFloat: self asFloat! !!Number methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream nextPutAll: self printString! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!asRepositorySpecFor: aMetacelloMCProject	| desc |	desc := self description.	desc ifNil: [ desc := 'dictionary://Metacello_Dictionary' ].	^(aMetacelloMCProject repositorySpec)		description:  desc;	 	type: 'dictionary';		yourself! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 15:04:55'!cacheReferences	^ false! !!MCDictionaryRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/11/2009 22:31'!goferPriority	^ 10! !!MCDictionaryRepository methodsFor: '*gofer-core-accessing' stamp: 'TestRunner 12/12/2009 11:12'!goferReferences	^ self allVersionInfos collect: [ :each | GoferResolvedReference name: each name repository: self ]! !!MCDictionaryRepository methodsFor: '*gofer-core-accessing' stamp: 'TestRunner 12/13/2009 14:57'!goferVersionFrom: aVersionReference	^ self dictionary detect: [ :version | version info name = aVersionReference name ]! !!MCDictionaryRepository methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076'!possiblyNewerVersionsOfAnyOf: versionNames 	^#()! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!versionInfoFromVersionNamed: aString	| versions |	versions := self dictionary values select: [:version | version info name beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a info name copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b info name copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ versions last info! !!OrderedDictionary class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"My instances are stored as maps."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !!OrderedDictionary methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"I store my instances as maps. When in JSON mode, 	encode me directly, without a class tag, keeping the order."		stonWriter jsonMode 		ifTrue: [ 			stonWriter encodeMap: self ] 		ifFalse: [ 			stonWriter 				writeObject: self 				do: [ stonWriter encodeMap: self ] ]! !!Time class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !!Time methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!Time methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Use an ISO style HH:MM:SS.N representation (with optional nanoseconds)"	 	stonWriter writeObject: self listSingleton: 		(String streamContents: [ :stream |			self print24: true showSeconds: true on: stream ])! !!Set methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonPostReferenceResolution	"When references were resolved in me, the hash of my elements might have changed.	Check if I am still healthy and rehash me if not."		self isHealthy ifFalse: [ self rehash ]! !!DirectoryEntryFile methodsFor: '*monticellofiletree-filedirectory-utilities' stamp: 'dkh 2/16/2012 14:49:00' prior: 26351654!readStreamDo: aBlock	^ directory readOnlyFileNamed: self name do: aBlock! !!Metaclass class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	| theClassName theClass theMetaclass |	theClassName := stonReader parseListSingleton.	theClass := self environment at: theClassName.	theMetaclass := theClass class.	^ theMetaclass! !!Metaclass methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonName	^ #Class! !!Metaclass methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter		writeObject: self 		listSingleton: self instanceSide name asSymbol! !!MetacelloPackageAPIHelpBuilder methodsFor: 'building' stamp: 'dkh 4/10/2011 20:08:41'!buildPackageTopic: pTopic 	| classTopic classes |	classes := (PackageInfo named: pTopic title) classes asSortedCollection: [:cl1 :cl2 | cl1 name < cl2 name].	classes	   do: [:aClass| 		classTopic := MetacelloClassAPIHelpBuilder buildHierarchicalHelpTopicFrom: aClass withSubclasses: false withMethods: true.		pTopic addSubtopic: classTopic	]! !!MCFileTreeWriter class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 13:09'!readerClass    "don't expect this message to be sent"    self shouldNotImplement! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 8/10/2012 05:26'!addString: string at: fileNameOrPath    "fileNameOrPath may have one or two elements"   self addString: string at: fileNameOrPath encodedTo: 'utf8'! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 7/7/2013 15:41:32'!addString: string at: fileNameOrPath encodedTo: ignored    "fileNameOrPath may have one or two elements"    "encodeTo: arg, because FileTree uses UTF8 by default"    | utils fullPath path |    utils := MCFileTreeFileUtils current.    path := MCFileTreePackageStructureStWriter useCypressWriter        ifTrue: [             fullPath := utils                buildPathFrom:                    {(MCFileTreeStCypressWriter monticelloMetaDirName).                    fileNameOrPath}.            utils ensureFilePathExists: fullPath relativeTo: self packageFileDirectory.            fullPath ]        ifFalse: [ fileNameOrPath ].    string isEmpty        ifFalse: [ utils writeStreamFor: path in: self packageFileDirectory do: [ :file | file nextPutAll: string ] ]! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 07:12'!deleteExistingPackageStructureFor: members    "destroy .tree and .pkg directory structure .. otherwise it won't be pretty"    | alternateDirName alternateDir packageDirectoryName |    (self fileUtils directoryExists: self packageFileDirectory)        ifTrue: [ self fileUtils deleteAll: self packageFileDirectory ].    packageDirectoryName := self fileUtils directoryName: self packageFileDirectory.    alternateDirName := (packageDirectoryName endsWith: '.pkg')        ifTrue: [ members first , '.tree' ]        ifFalse: [             (packageDirectoryName endsWith: '.tree')                ifTrue: [ members first , '.pkg' ]                ifFalse: [                     (packageDirectoryName endsWith: '.package')                        ifTrue: [ members first , '.pkg' ] ] ].    alternateDirName        ifNotNil: [             alternateDir := self fileUtils directoryFromPath: alternateDirName relativeTo: stream directory.            (self fileUtils directoryExists: alternateDir)                ifTrue: [ self fileUtils deleteAll: alternateDir ] ]! !!MCFileTreeWriter methodsFor: 'accessing' stamp: 'dkh 8/10/2012 07:05'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 2/16/2012 14:49:00'!flush	! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 14:01'!initializePackageFileDirectoryCache    cachedPackageFileDirectoryEntries := Dictionary new.    self packageFileDirectory entries        do: [ :entry |             entry isDirectory                ifTrue: [ cachedPackageFileDirectoryEntries at: entry name put: (self fileUtils directoryFromEntry: entry) ] ]! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 8/10/2012 07:14'!packageFileDirectory    packageFileDirectory        ifNil: [ packageFileDirectory := self fileUtils directoryFromPath: directory relativeTo: stream directory ].    ^ packageFileDirectory! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 07/07/2013 22:10'!repository  ^ stream! !!MCFileTreeWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:59'!snapshotWriterClass	^ MCFileTreeAbstractStWriter! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 07:16'!subPackageFileDirectoryFor: directoryNameOrPath    ^ cachedPackageFileDirectoryEntries        at: directoryNameOrPath        ifAbsentPut: [             | dir |            dir := self fileUtils directoryFromPath: directoryNameOrPath relativeTo: self packageFileDirectory.            self fileUtils ensureDirectoryExists: dir.            dir ]! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 2/16/2012 14:49:00'!writeSnapshot: aSnapshot	(self snapshotWriterClass on: self) writeDefinitions: aSnapshot definitions! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 14:51'!writeVersion: aVersion    | members |    directory := (members := MCFileTreeRepository parseName: aVersion info name) last.    self deleteExistingPackageStructureFor: members.    self fileUtils ensureDirectoryExists: self packageFileDirectory.    self initializePackageFileDirectoryCache.    super writeVersion: aVersion! !!MetacelloConfigurationHelpBuilder methodsFor: 'building' stamp: 'dkh 4/10/2011 20:08:41'!build	"Start building a help topic from a code description"		topicToBuild := self createTopicFrom: rootToBuildFrom ! !!MetacelloConfigurationHelpBuilder methodsFor: 'private' stamp: 'dkh 4/10/2011 20:08:41'!createTopicFrom: aDescription	| topic |	topic := HelpTopic named: aDescription bookName.	topic key: aDescription key.	topic icon: aDescription icon.	aDescription pages do: [ :pageSelector | topic addSubtopic: (aDescription perform: pageSelector) ].	(MetacelloToolBox configurationClasses asArray		sort: [ :a :b | (MetacelloToolBox baseNameOfConfiguration: a) <= (MetacelloToolBox baseNameOfConfiguration: b) ])		do: [ :class | topic addSubtopic: (MetacelloToolBox  helpTopicFor: class) ].	^ topic! !!MetacelloOldSemanticVersionNumber class methodsFor: 'private' stamp: 'dkh 05/03/2016 07:38'!integerFromString: aString  ^ aString asInteger! !!MetacelloOldSemanticVersionNumber class methodsFor: 'private' stamp: 'dkh 05/03/2016 07:45'!validateVersionNumber: svn against: aString  "no validation"! !!MetacelloSemanticVersionNumber class methodsFor: 'private' stamp: '9/28/2017 08:54:38'!extractNumericComponent: subString forPattern: forPattern    "$. separated components are integers"    | number |    forPattern        ifTrue: [ ^ subString ].    number := [ subString asNumber ]        on: Error        do: [ :ex | ex return: subString ].    ^ number asString = subString        ifTrue: [ number ]        ifFalse: [ subString ]! !!MetacelloSemanticVersionNumber class methodsFor: 'instance creation' stamp: 'dkh 05/03/2016 07:42'!fromString: aString  | svn |  svn := self fromString: aString forPattern: false.  self validateVersionNumber: svn against: aString.  ^ svn! !!MetacelloSemanticVersionNumber class methodsFor: 'instance creation' stamp: 'dkh 05/03/2016 07:12'!fromString: aString forPattern: forPattern  | preRelease build versionString identifierCount normalEnd preReleaseEnd normalComponents preReleaseComponents buildComponents |  normalComponents := OrderedCollection new.  preReleaseComponents := OrderedCollection new.  buildComponents := OrderedCollection new.  preRelease := aString indexOf: $- startingAt: 1.  build := aString indexOf: $+ startingAt: 1.  (build > 0 and: [ preRelease > build ])    ifTrue: [ preRelease := 0 ].  normalEnd := preRelease = 0    ifTrue: [       build = 0        ifTrue: [ aString size ]        ifFalse: [ build - 1 ] ]    ifFalse: [ preRelease - 1 ].  versionString := aString copyFrom: 1 to: normalEnd.  identifierCount := 0.  (versionString findTokens: '.')    do: [ :subString |       | integer |      forPattern        ifTrue: [ integer := subString ]        ifFalse: [           integer := self integerFromString: subString.          integer < 0            ifTrue: [               self                error:                  'invalid version number: normal version component must be integer '                    , subString printString ] ].      normalComponents add: integer.      identifierCount := identifierCount + 1 ].  (forPattern not and: [ identifierCount ~= 3 ])    ifTrue: [ self error: 'invalid version number: normal version must have only 3 components' ].  preReleaseEnd := build = 0    ifTrue: [ aString size ]    ifFalse: [ build - 1 ].  preRelease > 0    ifTrue: [       versionString := aString copyFrom: preRelease + 1 to: preReleaseEnd.      (versionString findTokens: '.')        do: [ :subString |           (forPattern or: [ self isSemanticIdentifier: subString ])            ifFalse: [               self                error:                  'invalid version number: preRelease version component must be one of [0-9A-Za-z-]' ].          preReleaseComponents            add:              (self extractNumericComponent: subString forPattern: forPattern) ] ].  build > 0    ifTrue: [       versionString := aString copyFrom: build + 1 to: aString size.      (versionString findTokens: '.')        do: [ :subString |           (forPattern or: [ self isSemanticIdentifier: subString ])            ifFalse: [               self                error:                  'invalid version number: build version component must be one of [0-9A-Za-z-]' ].          buildComponents            add:              (self extractNumericComponent: subString forPattern: forPattern) ] ].  ^ self new    normalVersion: normalComponents;    preReleaseVersion: preReleaseComponents;    buildVersion: buildComponents;    yourself! !!MetacelloSemanticVersionNumber class methodsFor: 'private' stamp: 'dkh 05/04/2016 06:24'!integerFromString: aString  aString    detect: [ :char | char isDigit not ]    ifNone: [       | integer |      integer := aString asInteger.      ((aString at: 1) = $0 and: [ aString size > 1 ])        ifTrue: [           self            error:              'invalid version number: normal version component must not have leading 0s'                , aString asString ].      ^ integer ].  self    error:      'invalid version number: normal version component must be integer '        , aString asString! !!MetacelloSemanticVersionNumber class methodsFor: 'private' stamp: '9/28/2017 08:54:38'!isSemanticIdentifier: aString    "whether the receiver is composed entirely of alphanumerics"    aString        do: [ :c |             c isAlphaNumeric                ifFalse: [                     c = $-                        ifFalse: [ ^ false ] ] ].    ^ true! !!MetacelloSemanticVersionNumber class methodsFor: 'private' stamp: 'dkh 05/03/2016 07:45'!validateVersionNumber: svn against: aString  svn printString = aString    ifFalse: [       self        error:          'The printString of a semantic version number should be equal to the source version string' ]! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!< aMetacelloVersionNumber    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    ^ self compareLessThan: aMetacelloVersionNumber! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!= aMetacelloVersionNumber    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    ^ self compareEqualTo: aMetacelloVersionNumber! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!approximateBase	| base |	base := self copyFrom: 1 to: self size - 1.	base at: base size put: (base at: base size) + 1.	^base! !!MetacelloSemanticVersionNumber methodsFor: 'converting' stamp: '9/28/2017 08:54:38'!asMetacelloSemanticVersionNumber    ^ self! !!MetacelloSemanticVersionNumber methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!asString	"Answer a string that represents the receiver."	^ self printString! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!buildVersion    buildVersion ifNil: [ buildVersion := #() ].    ^ buildVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!buildVersion: anObject	buildVersion := anObject! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!compareEqualTo: aMetacelloVersionNumber    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    (self compareEqualTo: self normalVersion other: aMetacelloVersionNumber normalVersion)        ifFalse: [ ^ false ].    (self compareEqualTo: self preReleaseVersion other: aMetacelloVersionNumber preReleaseVersion)        ifFalse: [ ^ false ].    ^ self compareEqualTo: self buildVersion other: aMetacelloVersionNumber buildVersion! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!compareEqualTo: myComponents other: otherComponents    | mySize |    mySize := myComponents size.    mySize = otherComponents size        ifFalse: [ ^ false ].    1 to: mySize do: [ :i |         (myComponents at: i) = (otherComponents at: i)            ifFalse: [ ^ false ] ].    ^ true! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!compareLessThan: aMetacelloVersionNumber    | myComponents otherComponents defaultResult |    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    myComponents := self normalVersion.    otherComponents := aMetacelloVersionNumber normalVersion.    defaultResult := true.    (self compareEqualTo: myComponents other: otherComponents)        ifTrue: [ defaultResult := false ]        ifFalse: [             (self compareLessThan: myComponents other: otherComponents version: #'normal')                ifFalse: [ ^ false ] ].    myComponents := self preReleaseVersion.    otherComponents := aMetacelloVersionNumber preReleaseVersion.    (self compareEqualTo: myComponents other: otherComponents)        ifTrue: [             myComponents size > 0                ifTrue: [ defaultResult := false ] ]        ifFalse: [ ^ self compareLessThan: myComponents other: otherComponents version: #'preRelease' ].    myComponents := self buildVersion.    otherComponents := aMetacelloVersionNumber buildVersion.    ^ (self compareEqualTo: myComponents other: otherComponents)        ifTrue: [ defaultResult ]        ifFalse: [ self compareLessThan: myComponents other: otherComponents version: #'build' ]! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!compareLessThan: myComponents other: otherComponents version: version    | mySize aSize commonSize count more |    mySize := myComponents size.    aSize := otherComponents size.    commonSize := mySize min: aSize.    count := 0.    more := true.    [ more and: [ count < commonSize ] ]        whileTrue: [             (myComponents at: count + 1) = (otherComponents at: count + 1)                ifTrue: [ count := count + 1 ]                ifFalse: [ more := false ] ].    count < commonSize        ifTrue: [ ^ (myComponents at: count + 1) metacelloSemanticVersionComponentLessThan: (otherComponents at: count + 1) ].    mySize < aSize        ifTrue: [             mySize = 0                ifTrue: [                     #'preRelease' == version                        ifTrue: [ ^ false ].                    ^ true ].            (myComponents at: commonSize) = (otherComponents at: commonSize)                ifFalse: [ ^ true ].            ^ true ]        ifFalse: [             mySize = aSize                ifTrue: [ ^ false ].            aSize = 0                ifTrue: [                     #'build' == version                        ifTrue: [ ^ false ].                    ^ true ].            (myComponents at: commonSize) = (otherComponents at: commonSize)                ifFalse: [ ^ false ].            ^ true ]! !!MetacelloSemanticVersionNumber methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize new j |	newSize := stop - start + 1.	new := self species new: newSize.	j := 0.	start to: stop do: [:i |		new at: j + 1 put: (self at: i).		j := j + 1 ].	^new! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementMajorVersion  self decrementNormalVersionAt: 1! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementMinorVersion  self decrementNormalVersionAt: 2! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementMinorVersionNumber  self decrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!decrementNormalVersionAt: index  | int col |  col := self normalVersion.  int := col at: index.  int > 0    ifTrue: [ col at: index put: int - 1 ]! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementPatchVersion  self decrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'enumerating' stamp: '9/28/2017 08:54:38'!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!MetacelloSemanticVersionNumber methodsFor: 'enumerating' stamp: '9/28/2017 08:54:38'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!hash    ^ self versionComponents hash! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementMajorVersion  self incrementNormalVersionAt: 1! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementMinorVersion  self incrementNormalVersionAt: 2! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementMinorVersionNumber  self incrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!incrementNormalVersionAt: index  | int col |  col := self normalVersion.  int := col at: index.  col at: index put: int + 1! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementPatchVersion  self incrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!match: aVersionPattern    "Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence. "    | patternVersion mySize patternSize components |    patternVersion := (self class fromString: aVersionPattern forPattern: true) versionComponents.    components := self versionComponents.    mySize := components size.    patternSize := patternVersion size.    mySize = patternSize        ifFalse: [             mySize < patternSize                ifTrue: [ ^ false ].            (patternVersion at: patternSize) ~= '?'                ifTrue: [ ^ false ].            mySize := patternSize ].    1 to: mySize do: [ :i |         | pattern |        pattern := (patternVersion at: i) asString.        pattern = '?'            ifTrue: [                 i = mySize                    ifFalse: [ ^ self error: 'Invalid version match pattern: ' , aVersionPattern printString ] ]            ifFalse: [                 (pattern match: (components at: i) asString)                    ifFalse: [ ^ false ] ] ].    ^ true! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!normalVersion    normalVersion ifNil: [ normalVersion := #() ].    ^ normalVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!normalVersion: anObject	normalVersion := anObject! !!MetacelloSemanticVersionNumber methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy  normalVersion := normalVersion copy.  preReleaseVersion := preReleaseVersion copy.  buildVersion := buildVersion copy! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!preReleaseVersion    preReleaseVersion ifNil: [ preReleaseVersion := #() ].    ^ preReleaseVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!preReleaseVersion: anObject	preReleaseVersion := anObject! !!MetacelloSemanticVersionNumber methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!print: components prefix: prefixChar on: aStream    | beforeFirst |    beforeFirst := true.    components        do: [ :component |             beforeFirst                ifTrue: [                     beforeFirst := false.                    prefixChar ifNotNil: [ aStream nextPut: prefixChar ] ]                ifFalse: [ aStream nextPut: $. ].            aStream nextPutAll: component asString ]! !!MetacelloSemanticVersionNumber methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream    self print: self normalVersion prefix: nil on: aStream.    self print: self preReleaseVersion prefix: $- on: aStream.    self print: self buildVersion prefix: $+ on: aStream! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!versionComponents    ^ self normalVersion , self preReleaseVersion , self buildVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	| strm |	strm := WriteStream on: String new.	self printOn: strm.	^strm contents! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!~> aMetacelloVersionNumber	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!allPackagesForSpecNamed: aStringOrArray	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, answers an empty list"	^self allPackagesForSpecNamed: aStringOrArray ifAbsent: [ ^#() ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!allPackagesForSpecNamed: aStringOrArray ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, aBlock is evaluated"	^aStringOrArray 		resolvePackageSpecsNamedForMetacelloMCVersion: self 		visited: MetacelloVisitedPackages new 		ifAbsent: aBlock! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!allPackagesForSpecs: pkgSpecs visited: visited 	| coll |	coll := Dictionary new.	pkgSpecs		do: [:pkgSpec | (pkgSpec resolveToAllPackagesIn: self spec visited: visited)				do: [:pkg | coll at: pkg name put: pkg ]].	^ coll values asOrderedCollection! !!MetacelloMCVersion methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!cacheRepository: repository 	"by default cacheRepository is an MCDictionaryRepository"		self loaderPolicy cacheRepository: repository! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!computeVersionStatus	"		#allLoadedToSpec - all projects and packages are loaded and match specification		#loadedToSpec - all loaded projects and packages match specifications (at least one package loaded)		#loadedMatchConstraints - all loaded projects and packages match constraints (at least one package loaded)		#somethingLoaded - at least one package loaded	"	self spec computeVersionStatus: [ :status | ^ status ].	^ #noStatus! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!currentlyLoadedClassesInVersion	^self spec currentlyLoadedClassesInVersion! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!currentlyLoadedExtensionClassesInVersion	^self spec currentlyLoadedExtensionClassesInVersion! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!defaultPackageNamesToLoad	"Answer the list of packages and projects to be loaded --> packages already loaded"		^ self defaultPackageNamesToLoad: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!defaultPackageNamesToLoad: defaultList	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		^ self packageAndProjectNamesToLoad: defaultList loader: self loader! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!doFetchRequiredFromArray: anArray	| oldPolicy oldBypassProgress displayString |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Fetching ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[ 	| ans |		ans := self fetchRequiredFromArray: anArray.		Transcript cr; show: '...finished ', self versionNumber printString.		^ans ]			ensure: [ 				MetacelloPlatform current bypassProgressBars: oldBypassProgress.				loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!doLoadRequiredFromArray: anArray	| displayString oldPolicy oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Loading ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	| fetchLoader |		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).		MetacelloPlatform current			do:  [  fetchLoader doLoad ]			displaying: 'Loading ', displayString.		Transcript cr; show: '...finished ', self versionNumber printString.		^fetchLoader ]		ensure: [ 			MetacelloPlatform current bypassProgressBars: oldBypassProgress.			loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!doRecordRequiredFromArray: anArray	| originalLoader oldPolicy displayString oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Recording ', displayString, '...'.	originalLoader := self versionSpec loader.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	MetacelloPlatform current			do:  [ | ans |				self versionSpec loader: originalLoader recordingSpecLoader.				ans := (self executeLoadFromArray: anArray) copy.				Transcript cr; show: '...finished ', self versionNumber printString.				^ans ]			displaying: 'Recording ', displayString ]				ensure: [					MetacelloPlatform current bypassProgressBars: oldBypassProgress.					self versionSpec loader: originalLoader.					loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!executeLoadFromArray: anArray	| loader |	loader := MetacelloMCVersionSpecLoader on: self spec.	loader required: anArray.	loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ].	^loader load! !!MetacelloMCVersion methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!fetch	^self doFetchRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!fetch: required	^required fetchRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!fetchRequiredFromArray: anArray	| originalLoader displayString newLoader |	originalLoader := self versionSpec loader.	newLoader := originalLoader fetchingSpecLoader.	displayString := newLoader actionLabel , self versionNumber printString , ' of ' , self spec projectLabel.	MetacelloPlatform current		do: [ 			[ 			self versionSpec loader: newLoader.			MetacelloPlatform current				useStackCacheDuring: [ :dict | ^ self executeLoadFromArray: anArray ]				defaultDictionary: Dictionary new ] ensure: [ self versionSpec loader: originalLoader ] ]		displaying: displayString! !!MetacelloMCVersion methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ignoreImage: aBool 	"by default ignoreImage is false"		self loaderPolicy ignoreImage: aBool! !!MetacelloMCVersion methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!load	^self doLoadRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!load: required	^required loadRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!loadRequiredFromArray: anArray	| displayString |	displayString := 'Loading ', self versionNumber printString, ' of ', self spec projectLabel.	MetacelloPlatform current		do: [ ^self executeLoadFromArray: anArray ]		displaying: displayString! !!MetacelloMCVersion methodsFor: 'private' stamp: '9/28/2017 08:53:29'!loader: aLoader	self versionSpec loader: aLoader! !!MetacelloMCVersion methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loaderPolicy	loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].	^ loaderPolicy! !!MetacelloMCVersion methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!packageAndProjectNamesToLoad: defaultList loader: aLoader	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		| loadedPackageNames projectMap loadedProjectNames list |	loadedPackageNames := ((self packages select: [:pkg | pkg isPackageLoaded: aLoader ]) 		collect: [:pkg | pkg name ]) asSet, 			defaultList.	projectMap := Dictionary new.	self  projects do: [:prj | 		prj className ~~ nil			ifTrue: [ | coll loaded |				coll := projectMap at: prj className ifAbsent: [					coll := OrderedCollection new.					projectMap at: prj className put: coll.					coll].				(loaded := prj loadedPackageNames: aLoader) isEmpty 					ifFalse: [  coll add: prj -> (loaded -> prj loadPackageList) ]]].	loadedProjectNames := Set new.	projectMap keysAndValuesDo: [:prjClass :coll |		coll size <= 1			ifTrue: [ coll do: [:assoc | loadedProjectNames add: assoc key name ]]			ifFalse: [ 				"multiple project references against the same configuration ... only count project as loaded				 if there is an exact match for loaded projects...				 See http://code.google.com/p/metacello/issues/detail?id=86"				coll do: [:assoc | | loaded packageList |					loaded := assoc value key. "loaded packages from project"					packageList := assoc value value. "loadlist for project"					(packageList difference: loaded) isEmpty						ifTrue: [ loadedProjectNames add: assoc key name ]]]].	list := loadedPackageNames, loadedProjectNames.	list isEmpty ifTrue: [ ^self spec defaultPackageNames].	^list! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!packages	"Answers the list of packages associated with this version"	| packages |	packages := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:pkg | packages add: pkg ] groupDo: [:ignored | ].	^packages! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!packagesForSpecNamed: aString	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including only the package. #requires: and #includes:			fields in the package are ignored.	   If the spec is a project, answers an empty list.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"If there is no spec named <aString>, answers an empty list"	^self packagesForSpecNamed: aString ifAbsent: [ ^#() ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!packagesForSpecNamed: aString ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including only the package. #requires: and #includes:			fields in the package are ignored.	   If the spec is a project, answers an empty list.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"If there is no spec named <aString>, aBlock is evaluated"	| pkgSpec |	pkgSpec := self spec packageNamed: aString ifAbsent: aBlock.	^pkgSpec resolveToPackagesIn: self spec visited: MetacelloVisitedPackages new! !!MetacelloMCVersion methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!record	^self doRecordRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!record: required	^required recordRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositoryOverrides: repositoriesCollection 	self loaderPolicy overrideRepositories: repositoriesCollection! !!MetacelloMCVersion methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!silently: aBool 	"by default silently is false"		self loaderPolicy silently: aBool! !!MetacelloVersion class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!fromSpec: aMetacelloVersionSpec    ^ (self new versionNumber: aMetacelloVersionSpec versionNumber)        spec: aMetacelloVersionSpec;        yourself! !!MetacelloVersion class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!fromString: aString	^self new versionNumber: aString asMetacelloVersionNumber! !!MetacelloVersion methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!< aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber < aMetacelloVersion versionNumber! !!MetacelloVersion methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!= aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber = aMetacelloVersion versionNumber! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!author	^self spec author value! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!basicSpec    ^ self spec! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!blessing    ^ self basicSpec blessing value! !!MetacelloVersion methodsFor: 'private' stamp: '9/28/2017 08:54:38'!computeVersionStatus    ^ #'noStatus'! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!description    ^ self basicSpec description value! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!difference: aMetacelloVersion	"Return a a dictionary of additions, removals and modifications"		^self spec difference: aMetacelloVersion spec! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!expandToLoadableSpecNames: nameList	"Just like #resolveToLoadableSpecs:, but returns list of spec names instead of specs"		^self spec expandToLoadableSpecNames: nameList! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!groups	"Answers the list of groups associated with this version"		| groups |	groups := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:ignored | ] groupDo: [:grp | groups add: grp ].	^groups! !!MetacelloVersion methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!hash	^self versionNumber hash! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!importedVersions	importedVersions == nil ifTrue: [ importedVersions := #() ].	^importedVersions! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!importedVersions: aCollection	importedVersions := aCollection! !!MetacelloVersion methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isAllLoadedToSpec	"all projects and packages are loaded and match specification"		^self spec isAllLoadedToSpec! !!MetacelloVersion methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isLoadedMatchConstraints	"all loaded projects and packages match constraints"		^self spec isLoadedMatchConstraints! !!MetacelloVersion methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isLoadedToSpec	"all loaded projects and packages match specifications"		^self spec isLoadedToSpec! !!MetacelloVersion methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isPossibleBaseline	^self spec isPossibleBaseline! !!MetacelloVersion methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isSomethingLoaded	"at least one project or package has been loaded"		^self spec isSomethingLoaded! !!MetacelloVersion methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!load	^self subclassResponsibility! !!MetacelloVersion methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!load: required	^self subclassResponsibility! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!loader	^self spec loader! !!MetacelloVersion methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!name	^self versionString! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNamed: aString	^self packageNamed: aString ifAbsent: [ ^nil ].! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNamed: aString ifAbsent: aBlock	| pkg |	(pkg := self spec packageNamed: aString ifAbsent: []) == nil		ifTrue: [ ^aBlock value ].	^pkg referencedSpec! !!MetacelloVersion methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream    | label vs |    (#(structural broken) includes: self blessing) not        ifTrue: [             (vs := self versionStatus) == #'somethingLoaded'                ifTrue: [ aStream nextPutAll: '<>' ].            vs == #'loadedMatchConstraints'                ifTrue: [ aStream nextPutAll: '>=' ].            vs == #'loadedToSpec'                ifTrue: [ aStream nextPut: $~ ] ].    self versionNumber printOn: aStream.    self basicSpec ~~ nil        ifTrue: [             (label := self projectLabel) isEmpty                ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ]! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!project    ^ self basicSpec project! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectLabel    ^ self basicSpec projectLabel! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!projects	"Answers the list of projects associated with this version"	| projects |	projects := OrderedCollection new.	self spec projectDo: [:prj | projects add: prj projectReference ] packageDo: [:ignored | ] groupDo: [:ignored | ].	^projects! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!resolveToLoadableSpecs: nameList	"Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	^self spec resolveToLoadableSpecs: nameList! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!spec	^spec! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!spec: aMetacellVersionSpec	spec := aMetacellVersionSpec! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!timestamp    ^ self basicSpec timestamp value! !!MetacelloVersion methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!unload	^self spec unload! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionKey    "version printString, without the versionStatus decorations, suitable for using as a unique key for the 	 receiver in a dictionary"    ^ String        streamContents: [ :aStream |             | label |            self versionNumber printOn: aStream.            self basicSpec ~~ nil                ifTrue: [                     (label := self projectLabel) isEmpty                        ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ] ]! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionNumber	^versionNumber! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionNumber: aVersionNumber	versionNumber := aVersionNumber! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionNumberFrom: aString    ^ self versionNumber class fromString: aString! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionSpec	^self spec! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionStatus	versionStatus == nil ifTrue: [ versionStatus := self computeVersionStatus].	^versionStatus! !!MetacelloVersion methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionStatus: aSymbol	versionStatus := aSymbol! !!MetacelloVersion methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionString	^self versionNumber versionString! !!MetacelloVersion methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!~> aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber ~> aMetacelloVersion versionNumber! !!MetacelloVersionNumber class methodsFor: 'private' stamp: '9/28/2017 08:54:38'!extractNumericComponent: subString	"$. separated components are integers"	| number |	number := [subString asNumber] 						on: Error 						do: [:ex | ex return: subString ].	^number asString = subString		ifTrue: [ number ]		ifFalse: [ subString ]! !!MetacelloVersionNumber class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!fromString: aString	| new components |	components := OrderedCollection new.	(aString findTokens: '.') do: [:subString | | strs |		strs := subString findTokens: '-'.		"first subString token could be an integer"		components add: (self extractNumericComponent: strs first).		strs size > 1			ifTrue: [				"remaining are uncoditionally Strings, because of leading $-"				components addAll: strs allButFirst ]].	new := self new: components size.	1 to: components size do: [:i | new at: i put: (components at: i) ].	^new! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!< aMetacelloVersionNumber	| condensed aCondensed |	aMetacelloVersionNumber species = self species		ifFalse: [ ^ false ].	condensed := self collapseZeros.	aCondensed := aMetacelloVersionNumber collapseZeros.	(condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ])		ifTrue: [ ^ condensed compareLessThan: aCondensed ].	^ self compareLessThan: aMetacelloVersionNumber! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!= aMetacelloVersionNumber	| condensed aCondensed |	aMetacelloVersionNumber species = self species		ifFalse: [ ^ false ].	condensed := self collapseZeros.	aCondensed := aMetacelloVersionNumber collapseZeros.	(condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ])		ifTrue: [ ^ condensed compareEqualTo: aCondensed ].	^ self compareEqualTo: aMetacelloVersionNumber! !!MetacelloVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!approximateBase	| base |	base := self copyFrom: 1 to: self size - 1.	base at: base size put: (base at: base size) + 1.	^base! !!MetacelloVersionNumber methodsFor: 'converting' stamp: '9/28/2017 08:54:38'!asMetacelloVersionNumber	^self! !!MetacelloVersionNumber methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!asString	"Answer a string that represents the receiver."	^ self printString! !!MetacelloVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!collapseZeros	"the rule must be that zeros can be collapsed as long as the series of zeros ends in a string term"	| collection newSize new j lastElementIsStringOrZero canCollapse |	(self size = 0 or: [ self at: 1 ]) == 0		ifTrue: [ ^ self ].	collection := OrderedCollection new.	lastElementIsStringOrZero := true.	canCollapse := true.	self size to: 1 by: -1 do: [ :i | 		| element |		element := self at: i.		(canCollapse and: [ element == 0 ])			ifTrue: [ 				lastElementIsStringOrZero					ifFalse: [ 						canCollapse := false.						collection addFirst: element.]]			ifFalse: [ 				collection addFirst: element.				canCollapse := lastElementIsStringOrZero := element isString ] ].	collection size = self size		ifTrue: [ ^ self ].	newSize := collection size.	new := self species new: newSize.	j := 0.	collection		do: [ :element | 			new at: j + 1 put: element.			j := j + 1 ].	^ new! !!MetacelloVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!compareEqualTo: aMetacelloVersionNumber	| mySize |	aMetacelloVersionNumber species = self species ifFalse: [ ^false ].	mySize := self size.	mySize = aMetacelloVersionNumber size 		ifFalse: [ ^false ].	1 to: mySize do: [:i |		(self at: i) = (aMetacelloVersionNumber at: i) ifFalse: [ ^false ]].	^true! !!MetacelloVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!compareLessThan: aMetacelloVersionNumber	| mySize aSize commonSize count more |	mySize := self size.	aSize := aMetacelloVersionNumber size.	commonSize :=  mySize min: aSize.	count := 0.	more := true.	[ more and: [ count < commonSize ]] whileTrue: [		(self at: count + 1) = (aMetacelloVersionNumber at: count + 1)			ifTrue: [ count := count + 1 ]			ifFalse: [ more := false ]].	count < commonSize		ifTrue: [ 			^(self at: count + 1) 				metacelloVersionComponentLessThan: (aMetacelloVersionNumber at: count + 1) ].	mySize < aSize		ifTrue: [ 			mySize = 0 ifTrue: [ ^true ].			"if the versions at commonSize are equal and the next version slot in aMetacelloVersionNumber 			 is a string, then it's considered that I'm > aMetacelloVersionNumber			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^true ]. 			^(aMetacelloVersionNumber at: commonSize+1) isString not]		ifFalse: [ 			mySize = aSize ifTrue: [ ^false ].			aSize <= 0 ifTrue: [ ^false ].			"if the versions at commonSize are equal and the next version slot is a string, 			 then it's considered that I'm < aMetacelloVersionNumber			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^false ].			 ^(self at: commonSize+1) isString]! !!MetacelloVersionNumber methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize new j |	newSize := stop - start + 1.	new := self species new: newSize.	j := 0.	start to: stop do: [:i |		new at: j + 1 put: (self at: i).		j := j + 1 ].	^new! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementMajorVersion  self decrementVersionAt: 1! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementMinorVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self decrementVersionAt: 2! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [ :index | 		(int := self at: index) isString			ifFalse: [ 				int > 0					ifTrue: [ self at: index put: int - 1 ].				^ self ] ]! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!decrementPatchVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self size < 3    ifTrue: [ self at: 3 put: 0 ].  self decrementVersionAt: 3! !!MetacelloVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!decrementVersionAt: index  | int |  int := self at: index.  (int := self at: index) isString    ifFalse: [       int > 0        ifTrue: [ self at: index put: int - 1 ] ]! !!MetacelloVersionNumber methodsFor: 'enumerating' stamp: '9/28/2017 08:54:38'!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!MetacelloVersionNumber methodsFor: 'enumerating' stamp: '9/28/2017 08:54:38'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!hash"Returns a numeric hash key for the receiver."| mySize interval hashValue |(mySize := self size) == 0  ifTrue: [ ^15243 ]."Choose an interval so that we sample at most 5 elements of the receiver"interval := ((mySize - 1) // 4) max: 1.hashValue := 4459.1 to: mySize by: interval do: [ :i | | anElement |  anElement := self at: i.  (anElement isKindOf: SequenceableCollection)    ifTrue: [      hashValue := (hashValue bitShift: -1) bitXor: anElement size.      ]    ifFalse: [      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.      ].  ].^ hashValue abs! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementMajorVersion  self incrementVersionAt: 1! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementMinorVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self incrementVersionAt: 2! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [:index | 		(int := self at: index) isString 			ifFalse: [ 				self at: index put: int + 1.				^self ]].! !!MetacelloVersionNumber methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!incrementPatchVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self size < 3    ifTrue: [ self at: 3 put: 0 ].  self incrementVersionAt: 3! !!MetacelloVersionNumber methodsFor: 'private' stamp: '9/28/2017 08:54:38'!incrementVersionAt: index  | int |  int := self at: index.  (int := self at: index) isString    ifFalse: [ self at: index put: int + 1 ]! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!match: aVersionPattern	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence. "		| patternVersion mySize patternSize |	patternVersion := aVersionPattern asMetacelloVersionNumber.	mySize := self size.	patternSize := patternVersion size.	mySize = patternSize 		ifFalse: [ 			mySize < patternSize ifTrue: [ ^false ].			(patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].			mySize := patternSize ].	1 to: mySize do: [:i | | pattern |		pattern := (patternVersion at: i) asString.		pattern = '?'			ifTrue: [i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ', aVersionPattern printString ]]			ifFalse: [ (pattern match: (self at: i) asString)  ifFalse: [ ^false ]]].	^true"  '1.1.1' asMetacelloVersionNumber match: '*.*.*'. -> true  '1.1.1' asMetacelloVersionNumber match: '*.#.*'. -> true  '1.10.1' asMetacelloVersionNumber match: '*.#.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.?'. -> true  '1.0' asMetacelloVersionNumber match: '1.?'. -> true  '2.0' asMetacelloVersionNumber match: '1.?'. -> false  '1.1.1' asMetacelloVersionNumber match: '?'. -> true  '1' asMetacelloVersionNumber match: '*.?'. -> false  '1-alpha5.0' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1-alpha15.0.1' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1.1' asMetacelloVersionNumber match: '?.?'. -> ERROR: invalid version match pattern"! !!MetacelloVersionNumber methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [				each isString					ifTrue: [ aStream nextPut: $- ]					ifFalse: [ aStream nextPut: $. ] ].		aStream nextPutAll: each asString ]! !!MetacelloVersionNumber methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	| strm |	strm := WriteStream on: String new.	self printOn: strm.	^strm contents! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: '9/28/2017 08:54:38'!~> aMetacelloVersionNumber	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]! !!MCDirectoryRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!asRepositorySpecFor: aMetacelloMCProject  ""  ^ directory asRepositorySpecFor: aMetacelloMCProject! !!MCDirectoryRepository methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 15:04:55'!cacheReferences	^ false! !!MCDirectoryRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/11/2009 22:32'!goferPriority	^ 5! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 14:27'!defaultPackageExtension    ".tree, .pkg, .package are the only formats supported at the moment:	.tree         - original structure	.pkg          - snapshot structure	.package - cypress structure"    defaultPackageExtension        ifNil: [             defaultPackageExtension := MCFileTreePackageStructureStWriter useCypressWriter                ifTrue: [ '.package' ]                ifFalse: [ '.pkg' ] ].    ^ defaultPackageExtension! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 14:36'!defaultPackageExtension: aString    ".tree and .pkg are the only two formats supported at the moment"    "self defaultPackageExtension:'.package'"    (#('.tree' '.pkg' '.package') includes: aString)        ifFalse: [ self error: 'Unsupported package extension: ' , aString printString ].    defaultPackageExtension := aString! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!defaultPropertyFileExtension  defaultPropertyFileExtension    ifNil: [ defaultPropertyFileExtension := '.json' ].  ^ defaultPropertyFileExtension! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!defaultPropertyFileExtension: aString  "self defaultPropertyFileExtension:'.ston'"  self validatePropertyFileExtension: aString.  defaultPropertyFileExtension := aString! !!MCFileTreeRepository class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:49:00'!description    ^ 'filetree://'! !!MCFileTreeRepository class methodsFor: 'utility' stamp: 'dkh 2/29/2012 09:40:37'!parseName: aString    ^ self parseName: aString extension: self defaultPackageExtension! !!MCFileTreeRepository class methodsFor: 'utility' stamp: 'dkh 2/16/2012 14:49:00'!parseName: aString extension: extension    "picked up from GoferVersionReference>>parseName:"    | info basicName package branch author versionNumber packageName |    basicName := aString last isDigit        ifTrue: [ aString ]        ifFalse: [ (aString copyUpToLast: $.) copyUpTo: $( ].    package := basicName copyUpToLast: $-.    (package includes: $.)        ifFalse: [ branch := '' ]        ifTrue: [             branch := '.' , (package copyAfter: $.).            package := package copyUpTo: $. ].    author := (basicName copyAfterLast: $-) copyUpToLast: $..    versionNumber := (basicName copyAfterLast: $-) copyAfterLast: $..    (versionNumber notEmpty and: [ versionNumber allSatisfy: [ :each | each isDigit ] ])        ifTrue: [ versionNumber := versionNumber asNumber ]        ifFalse: [ versionNumber := 0 ].    packageName := package , branch.    ^ {packageName.    author.    versionNumber.    (packageName , extension)}! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!validatePropertyFileExtension: aString  "see Issue #90: https://github.com/dalehenrich/filetree/issues/90"  (#('.json' '.ston') includes: aString)    ifFalse: [ self error: 'Unsupported property file extension: ' , aString printString ]! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 6/16/2012 09:03'!allFileNames	versionNameToFileNameMap := Dictionary new.	^(self directory entries select: [:entry | entry isDirectory and: [self canReadFileNamed: entry name]]) collect: [:entry | | vName |		vName := self versionNameFromFileName: entry name.		versionNameToFileNameMap at: vName put: entry name.		vName asMCVersionName]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 11:24'!allVersionNames	"https://github.com/dalehenrich/filetree/issues/132"	^ self readableFileNames collect: [ :each | each versionName ] ! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!asRepositorySpecFor: aMetacelloMCProject    ^ aMetacelloMCProject repositorySpec        description: self description;        type: 'filetree';        yourself! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 4/5/2012 10:33'!basicStoreVersion: aVersion  self readonly    ifTrue: [       ^ self        error:          'The filetree repository: ' , self description printString            , ' was created read only.' ].  MCFileTreeWriter fileOut: aVersion on: self! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 10:59'!cache	^cache := Dictionary new! !!MCFileTreeRepository methodsFor: 'private' stamp: 'DS 5/6/2015 11:02'!cacheAllFileNamesDuring: aBlock 	"https://github.com/dalehenrich/filetree/issues/132"	| cacheInvalidated |	cacheInvalidated := false.	cacheInvalidationFlag ifNil: [cacheInvalidationFlag := true.		cacheInvalidated := true.		allFileNamesCache := nil.].		^ [super cacheAllFileNamesDuring: aBlock]		ensure: [cacheInvalidated ifTrue: [cacheInvalidationFlag := nil]]! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!cachedFileNames	^ #()! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/29/2012 10:15'!canReadFileNamed: aString    ^ (aString endsWith: self packageExtension)        or: [             (aString endsWith: '.tree')                or: [                     "Cypress format"                    aString endsWith: '.package' ] ]! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!defaultRepositoryProperties  ^ Dictionary new    at: 'packageExtension' put: self class defaultPackageExtension;    at: 'propertyFileExtension' put: self propertyFileExtension;    yourself! !!MCFileTreeRepository methodsFor: 'descriptions' stamp: 'dkh 2/16/2012 14:49:00'!description    ^ self class description , super description! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 3/7/2012 17:09:47'!directory: aDirectory  super directory: aDirectory.  repositoryProperties := nil.	"force properties to be reloaded from new location"  self repositoryProperties	"NOW"! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 6/16/2012 09:02'!fileDirectoryOn: directoryPath    ^ self fileUtils directoryFromPath: directoryPath relativeTo: self directory! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 8/10/2012 14:55:31.237'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 07/10/2013 11:43:55'!flushCache  "force properties to be reread ... if the directory exists, otherwise let nature   take it's course"  super flushCache.  directory    ifNotNil: [       (MCFileTreeFileUtils current directoryExists: directory)        ifTrue: [           repositoryProperties := nil.          self repositoryProperties ] ]! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/29/2012 12:12'!goferVersionFrom: aVersionReference    "until we no longer find .tree directories in the wild"    (((self directory entries select: [:entry | entry isDirectory and: [self canReadFileNamed: entry name]]) collect: [ :entry | self fileDirectoryOn: entry name ])        select: [ :packageDirectory | self fileUtils directoryExists:packageDirectory ])        collect: [ :packageDirectory |             (self versionInfoForPackageDirectory: packageDirectory) name = aVersionReference name                ifTrue: [ ^ self loadVersionFromFileNamed: (self fileUtils directoryName: packageDirectory) ] ].    ^ nil! !!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 5/16/2012 21:21:27'!metacelloProjectClassFor: aScriptEngine    aScriptEngine versionString isEmptyOrNil        ifFalse: [             "If we have a version in the script, then a BaselineOf is not being referenced...use a MetacelloMCProject	    	 see https://github.com/dalehenrich/metacello-work/issues/7"            ^ super metacelloProjectClassFor: aScriptEngine ].    ^ MetacelloMCBaselineProject! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 6/27/2012 20:14'!packageDescriptionFromPackageDirectory: packageDirectory    | filename info extension |    filename := self fileUtils current directoryName: packageDirectory.    extension := filename copyFrom: (filename lastIndexOf: $.) to: filename size.    ^ ((self packageExtension ~= '.package'        and: [             (self fileUtils filePathExists: 'version' relativeTo: packageDirectory)                and: [ self fileUtils filePathExists: 'package' relativeTo: packageDirectory ] ])        or: [             | dir |            dir := self fileUtils                directoryFromPath: MCFileTreeStCypressWriter monticelloMetaDirName                relativeTo: packageDirectory.            self fileUtils directoryExists: dir ])        ifTrue: [             info := self versionInfoForPackageDirectory: packageDirectory.            self parseName: info name extension: extension ]        ifFalse: [             {(filename copyFrom: 1 to: (filename lastIndexOf: $.) - 1).            'cypress'.            1.            filename} ]! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 2/16/2012 14:49:00'!packageDescriptionsFromReadableFileNames    ^ ((self readableFileNames collect: [ :fileName | self fileDirectoryOn: fileName ])        select: [ :packageDirectory | self fileUtils directoryExists: packageDirectory ])        collect: [ :packageDirectory | self packageDescriptionFromPackageDirectory: packageDirectory ]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 2/29/2012 10:11'!packageExtension  ^ self repositoryProperties    at: 'packageExtension'    ifAbsent: [ self class defaultPackageExtension ]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 2/29/2012 11:39'!parseName: aString extension: extension    ^ self class parseName: aString extension: extension! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 07/10/2013 11:43:55'!propertyFileExtension  ^ self repositoryProperties    at: 'propertyFileExtension'    ifAbsent: [ self class defaultPropertyFileExtension ]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 07/10/2013 11:43:55'!propertyFileExtension: propertyFileExtension  self class validatePropertyFileExtension: propertyFileExtension.  self repositoryProperties    at: 'propertyFileExtension'    put: propertyFileExtension.  self writeRepositoryProperties! !!MCFileTreeRepository methodsFor: 'i/o' stamp: 'dkh 2/16/2012 14:49:00'!readStreamForFileNamed: aString do: aBlock    ^ aBlock value: self directory! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 11:28'!readableFileNames	"https://github.com/dalehenrich/filetree/issues/132"	^self allFileNames asArray! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!readonly    readonly ifNil: [ readonly := false ].    ^ readonly! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!readonly: anObject	readonly := anObject! !!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 05/15/2014 20:47'!repositoryBranchName  "extract a branch name from the repository ... if possible"  (MetacelloPlatform current gitBranchNameFor: self directory fullName)    ifNotNil: [ :sha | ^ sha ].  ^ super repositoryBranchName! !!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 09/04/2014 13:48'!repositoryDescription  ^ self description , ' [' , self repositoryVersionString , ':'    , self repositoryBranchName , ']'! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 8/10/2012 07:54'!repositoryProperties  repositoryProperties    ifNil: [       repositoryProperties := Dictionary new.      (self fileUtils directoryExists: directory)        ifFalse: [           self            error:              'filetree:// repository '                ,                  (self fileUtils directoryPathString: self directory) printString                , ' does not exist.' ].      (self directory entries        detect: [ :entry | entry name = '.filetree' ]        ifNone: [  ])        ifNil: [           repositoryProperties := self defaultRepositoryProperties.          self writeRepositoryProperties ]        ifNotNil: [ :configEntry |           configEntry            readStreamDo: [ :fileStream | repositoryProperties := MCFileTreeJsonParser parseStream: fileStream ] ] ].  ^ repositoryProperties! !!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 05/15/2014 20:48'!repositoryVersionString  "extract a version string from the repository ... if possible"  (MetacelloPlatform current gitCommitShaFor: self directory fullName)    ifNotNil: [ :sha | ^ sha ].  ^ super repositoryVersionString! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!versionFromFileNamed: aString	^ self loadVersionFromFileNamed: (versionNameToFileNameMap at: aString ifAbsent: [aString])! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 8/10/2012 07:56'!versionInfoForPackageDirectory: packageDirectory    ^ ((MCReader readerClassForFileNamed: (self fileUtils directoryName: packageDirectory))        on: (self fileUtils parentDirectoryOf: packageDirectory)        fileName: (self fileUtils directoryName: packageDirectory))        loadVersionInfo;        info! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!versionInfoFromFileNamed: aString	^ self loadVersionInfoFromFileNamed: (versionNameToFileNameMap at: aString ifAbsent: [aString])! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!versionNameFromFileName: aString	| description |	description := self packageDescriptionFromPackageDirectory: (self fileDirectoryOn: aString).	^ description first , '-' , description second , '.' , description third printString! !!MCFileTreeRepository methodsFor: 'versions' stamp: 'dkh 6/12/2012 17:33:23'!versionNamed: aMCVersionName	^super versionNamed: (versionNameToFileNameMap at: aMCVersionName ifAbsent: [aMCVersionName])! !!MCFileTreeRepository methodsFor: 'interface' stamp: 'dkh 2/16/2012 14:49:00'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	(self allFileNamesForVersionNamed: aVersionInfo versionName)		ifNotEmpty: [ :aCollection | ^ self versionFromFileNamed: aCollection first ].	^ errorBlock value! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 8/10/2012 09:44'!writeRepositoryProperties  self fileUtils    writeStreamFor: '.filetree'    in: self directory    do: [ :fileStream |       | keyCount propertyCount |      repositoryProperties        ifNil: [ repositoryProperties := self defaultRepositoryProperties ].      keyCount := repositoryProperties size.      propertyCount := 0.      fileStream lineEndConvention: #'lf'.      fileStream nextPutAll: '{'.      repositoryProperties        keysAndValuesDo: [ :propertyName :propertyValue |           propertyCount := propertyCount + 1.          fileStream            nextPut: $";            nextPutAll: propertyName asString;            nextPutAll: '" : "';            nextPutAll: propertyValue asString;            nextPut: $";            yourself.          propertyCount < keyCount            ifTrue: [               fileStream                nextPutAll: ',';                cr ] ].      fileStream nextPutAll: ' }' ]! !!MCFileTreeRepository methodsFor: 'i/o' stamp: 'dkh 2/16/2012 14:49:00'!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	self error: 'we do not open a single stream, but write multiple files'! !!MCBitbucketRepository class methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:19'!basicDescription  ^ 'bitbucket'! !!MCBitbucketRepository class methodsFor: 'accessing' stamp: 'topa 5/5/2015 11:23'!cacheDirectoryPath  <preference: 'BitBucket Cache' category: 'Metacello' description: '' type:    #'String'>  ^ super cacheDirectoryPath! !!MCBitbucketRepository class methodsFor: 'testing' stamp: 'JohanBrichau 10/11/2014 02:04'!isEnabled	^true! !!MCBitbucketRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 14:31'!projectTagsUrlFor: projectPath  ^ 'https://bitbucket.org/api/1.0/repositories/' , projectPath , '/tags'! !!MCBitbucketRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 13:24'!projectZipUrlFor: projectPath versionString: versionString  ^ 'https://bitbucket.org/' , projectPath , '/get/' , versionString , '.zip'! !!MCBitbucketRepository methodsFor: 'private' stamp: 'dkh 10/14/2014 15:21'!normalizeTagsData: jsonObject  "return a dictionay mapping the tag name to the commit SHA"  | tagDict |  jsonObject    at: 'error'    ifPresent: [ :errorObject |       self        error:          'Error accessing tags for bitbucket project: ' , self projectPath printString            , ' -> ' , (errorObject at: 'message') printString            ,              ((errorObject at: 'detail')                ifNil: [ '' ]                ifNotNil: [ :detail | ' :: ' , detail printString ]) ].  tagDict := Dictionary new.  jsonObject    keysAndValuesDo: [ :tag :tagObject |       | sha |      sha := tagObject at: 'node'.      tagDict at: tag put: sha ].  ^ tagDict! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!basicDescription  ^ self subclassResponsibility! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!cacheDirectory  self resetCacheDirectoryIfInvalid.  repoCacheDirectory ifNil: [ repoCacheDirectory := self defaultCacheDirectory ].  ^ repoCacheDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!cacheDirectory: aDirectory  "explicitly set repoCacheDirectory"  repoCacheDirectory := aDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!cacheDirectoryFor: projectPath	| cacheDirectory projectDirectory |		cacheDirectory := self cacheDirectory.	projectDirectory := MetacelloPlatform current directoryFromPath: projectPath relativeTo: cacheDirectory.	MetacelloPlatform current ensureDirectoryExists: projectDirectory.	^ projectDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!cacheDirectoryPath  ^ MCFileTreeFileUtils current directoryPathString: self cacheDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!cacheDirectoryPath: aString  self    cacheDirectory:      (aString        ifEmpty: [  ]        ifNotEmpty: [ MetacelloPlatform current fileHandleOn: aString ])! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!defaultCacheDirectory  | defaultDirectory cacheDirectory |  defaultDirectory := MetacelloPlatform current defaultDirectory.  cacheDirectory := MetacelloPlatform current    directoryFromPath: self basicDescription , '-cache'    relativeTo: defaultDirectory.  MetacelloPlatform current ensureDirectoryExists: cacheDirectory.  ^ cacheDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!description  ^ self basicDescription , '://'! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!downloadCache  repoDownloadCache ifNil: [ repoDownloadCache := Dictionary new ].  ^ repoDownloadCache! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!downloadCacheKey: projectPath version: versionString  ^ projectPath , ':::' , versionString! !!MCGitBasedNetworkRepository class methodsFor: 'initialization' stamp: '9/28/2017 08:53:52'!flushDownloadCache  "self flushDownloadCache"  repoDownloadCache := nil! !!MCGitBasedNetworkRepository class methodsFor: 'utility' stamp: '9/28/2017 08:53:52'!flushProjectEntry: projectPath version: versionString    self downloadCache removeKey: (self downloadCacheKey: projectPath version: versionString) ifAbsent: [  ]! !!MCGitBasedNetworkRepository class methodsFor: 'initialization' stamp: 'EstebanLorenzano 10/2/2017 10:42'!initialize  "self initialize"	(Smalltalk classNamed: #SessionManager)		ifNotNil: [ :c | c default perform: #registerNetworkClassNamed: with: self name ]		ifNil:[ Smalltalk addToStartUpList: self ].  self flushDownloadCache.  self resetCacheDirectoryIfInvalid! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!isAbstract    "abstract as far as creating new repositories interactively? yes"    ^ true! !!MCGitBasedNetworkRepository class methodsFor: 'testing' stamp: '9/28/2017 08:53:52'!isEnabled	^false! !!MCGitBasedNetworkRepository class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:52'!location: locationUrl    ^ self location: locationUrl version: nil! !!MCGitBasedNetworkRepository class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:52'!location: locationUrl version: versionString    ^ self parseLocation: locationUrl version: versionString! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!parseLocation: locationUrl version: versionString  "self 	parseLocation: 'github://dalehenrich/MetacelloRepository:master/monticello/repos/itory/path'	version: nil     "  | projectPath projectVersion repoPath headerSize desc projectDelim repoDelim versionDelim |  headerSize := self description size.  desc := locationUrl.  desc := desc copyFrom: headerSize + 1 to: desc size.  projectVersion := repoPath := nil.  projectDelim := desc indexOf: $/.  repoDelim := desc indexOf: $/ startingAt: projectDelim + 1.  (versionDelim := desc indexOf: $:) == 0    ifTrue: [       repoDelim == 0        ifTrue: [ projectPath := desc ]        ifFalse: [           projectPath := desc copyFrom: 1 to: repoDelim - 1.          repoPath := desc copyFrom: repoDelim + 1 to: desc size ] ]    ifFalse: [       projectPath := desc copyFrom: 1 to: versionDelim - 1.      repoDelim == 0        ifTrue: [ projectVersion := desc copyFrom: versionDelim + 1 to: desc size ]        ifFalse: [           projectPath := desc copyFrom: 1 to: versionDelim - 1.          self            parseProjectVersionField: [ :pv :rp |               projectVersion := pv.              repoPath := rp ]            desc: desc            versionDelim: versionDelim ] ].  versionString ~~ nil    ifTrue: [ projectVersion := versionString ].  ^ self new    projectPath: projectPath    projectVersion: projectVersion    repoPath: repoPath! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!parseProjectVersionField: parseBlock desc: desc versionDelim: versionDelim  "Issue #234: have to allow for commitish containing slashes"  | strm done escaped repoDelim |  strm := WriteStream on: String new.  repoDelim := versionDelim + 1.  escaped := done := false.  [ done ]    whileFalse: [       | char |      repoDelim > desc size        ifTrue: [ done := true ]        ifFalse: [           char := desc at: repoDelim.          char == $\            ifTrue: [               escaped                ifTrue: [                   "$\ not legal in branch name ... literally ignored"                  escaped := false ]                ifFalse: [ escaped := true ] ]            ifFalse: [               char == $/                ifTrue: [                   escaped                    ifFalse: [ done := true ] ].              done                ifFalse: [ strm nextPut: char ].              escaped := false ].          repoDelim := repoDelim + 1 ] ].  repoDelim := repoDelim - 1.  parseBlock    value: strm contents    value: (desc copyFrom: repoDelim + 1 to: desc size)! !!MCGitBasedNetworkRepository class methodsFor: 'utility' stamp: 'ct 10/12/2020 23:07'!projectDirectoryFrom: projectPath version: versionString	| mcPlatform theCacheDirectory projectDirectory downloadCacheKey cachePath pid |	downloadCacheKey := self		downloadCacheKey: projectPath		version: versionString.	mcPlatform := MetacelloPlatform current.	theCacheDirectory := mcPlatform		directoryFromPath: versionString		relativeTo: (self cacheDirectoryFor: projectPath).	cachePath := self downloadCache at: downloadCacheKey ifAbsent: [  ].	(cachePath isNil		or: [ (projectDirectory := mcPlatform				directoryFromPath: cachePath				relativeTo: theCacheDirectory) exists not ])		ifTrue: [ | url archive directory zipFileName |			MetacelloScriptGitBasedDownloadNotification new				projectPath: projectPath;				versionString: versionString;				signal.	"for testing purposes"			mcPlatform ensureDirectoryExists: theCacheDirectory.			url := self				projectZipUrlFor: projectPath				versionString: versionString.			pid := mcPlatform processPID.			zipFileName := mcPlatform				tempFileFor:					self basicDescription , '-' , pid , '-'						, (downloadCacheKey select: [ :c | c isAlphaNumeric ])				suffix: '.zip'.			archive := mcPlatform				downloadZipArchive: url				to: zipFileName				username: self siteUsername				pass: self sitePassword.			directory := mcPlatform				directoryFromPath: (cachePath := archive members first fileName)				relativeTo: theCacheDirectory.			false				ifTrue: [					"temporary patch for https://github.com/Metacello/metacello/issues/504"					archive close ].			directory exists				ifTrue: [ mcPlatform deleteFileNamed: zipFileName ]				ifFalse: [ mcPlatform						extractRepositoryFrom: zipFileName						to: theCacheDirectory fullName ].			self downloadCache at: downloadCacheKey put: cachePath.			projectDirectory := mcPlatform				directoryFromPath: cachePath				relativeTo: theCacheDirectory ].	^ projectDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!projectTagsUrlFor: aProjectPath  self subclassResponsibility! !!MCGitBasedNetworkRepository class methodsFor: 'version patterns' stamp: '9/28/2017 08:53:52'!projectVersionFromString: aString  "strip leading $v if present and return an instance of MetacelloVersionNumber"  | versionString |  versionString := aString.  (versionString beginsWith: 'v')    ifTrue: [ versionString := versionString copyFrom: 2 to: versionString size ].  ^ MetacelloVersionNumber fromString: versionString! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!projectZipUrlFor: projectPath versionString: versionString  self subclassResponsibility! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: '9/28/2017 08:53:52'!resetCacheDirectoryIfInvalid  "Reset if invalid"  repoCacheDirectory notNil    and: [       (MCFileTreeFileUtils current directoryExists: repoCacheDirectory)        ifFalse: [ repoCacheDirectory := nil ] ]! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: '9/28/2017 08:53:52'!sitePassword  ^ sitePassword! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: '9/28/2017 08:53:52'!sitePassword: aString  sitePassword := aString! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: '9/28/2017 08:53:52'!siteUsername  ^ siteUsername! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: '9/28/2017 08:53:52'!siteUsername: aString  siteUsername := aString! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: '9/28/2017 08:53:52'!siteUsername: username sitePassword: pass  "MCBitbucketRepository siteUsername: '' sitePassword: ''"  "MCGitHubRepository siteUsername: '' sitePassword: ''"  self    siteUsername: username;    sitePassword: pass! !!MCGitBasedNetworkRepository class methodsFor: 'system startup' stamp: '9/28/2017 08:53:52'!startUp: resuming    "Flush the GitHub download cache"    resuming        ifTrue: [ self flushDownloadCache ]! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!asRepositorySpecFor: aMetacelloMCProject  ^ aMetacelloMCProject repositorySpec    description: self description;    type: self class basicDescription;    yourself! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:52'!canUpgradeTo: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class)    ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath    and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!MCGitBasedNetworkRepository methodsFor: 'descriptions' stamp: '9/28/2017 08:53:52'!description  | desc |  desc := self class description , self projectPath , ':'    , self projectVersionEscaped.  self repoPath isEmpty    ifTrue: [ ^ desc ].  ^ desc , '/' , self repoPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!directory  directory    ifNil: [       directory := self class        projectDirectoryFrom: self projectPath        version: self projectVersion.      self repoPath isEmpty        ifFalse: [           directory := MetacelloPlatform current            directoryFromPath: self repoPath            relativeTo: directory ] ]    ifNotNil: [       (MCFileTreeFileUtils current directoryExists: directory)        ifFalse: [           self flushCache.          ^ self directory ] ].  ^ directory! !!MCGitBasedNetworkRepository methodsFor: 'descriptions' stamp: '9/28/2017 08:53:52'!directoryDescription    ^ self directory pathName! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: '9/28/2017 08:53:52'!downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current    downloadJSON: tagsUrl    username: self class siteUsername    pass: self class sitePassword.  ^ self normalizeTagsData: jsonObject! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:52'!flushCache  "the directory acts like a cache since we download the directory from a git-based repository (github, bitbucket, etc.)"  [ super flushCache ]    on: Error    do: [ :ex |       Transcript        cr;        show:            'Error for: ' , self description printString , ' during flushCache: '                , ex description printString ].  self class flushDownloadCache.  directory := nil! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:52'!flushForScriptGet    self class flushProjectEntry: self projectPath version: self projectVersion.    directory := nil! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:52'!hasNoLoadConflicts: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class)    ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath    and: [       self repoPath = anMCGitBasedRepository repoPath        and: [ self projectVersion = anMCGitBasedRepository projectVersion ] ]! !!MCGitBasedNetworkRepository methodsFor: 'comparing' stamp: '9/28/2017 08:53:52'!hash    ^ self description hash! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:52'!initialize    super initialize.    directory := nil.	"we'll lazily create the directory instance"    self readonly: true! !!MCGitBasedNetworkRepository methodsFor: 'testing' stamp: '9/28/2017 08:53:52'!isValid    ^ true! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!metacelloProjectClassFor: aScriptEngine    ^ MetacelloMCBaselineProject! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: '9/28/2017 08:53:52'!normalizeTagsData: jsonObject  ^ self subclassResponsibility! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectPath    ^ projectPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectPath: anObject    projectPath := anObject! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:52'!projectPath: aProjectPath projectVersion: aProjectVersion repoPath: aRepoPath  self projectPath: aProjectPath.  self projectVersion: aProjectVersion.	"Important that projectVersion be set AFTER projectPath"  self repoPath: aRepoPath! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: '9/28/2017 08:53:52'!projectTagsUrlFor: aProjectPath  ^ self class projectTagsUrlFor: aProjectPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectVersion    (projectVersion == nil or: [ projectVersion isEmpty ])        ifTrue: [ projectVersion := 'master' ].    ^ projectVersion! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectVersion: aString  "Important that projectVersion be set AFTER projectPath, as projectPath needed for resolving projectVersionPattern"  | x |  aString    ifNil: [       projectVersion := aString.      ^ self ].  (x := aString    findDelimiters:      {$#.      $*.      $?}    startingAt: 1) <= aString size    ifTrue: [ self resolveProjectVersionPattern: aString ]    ifFalse: [ projectVersion := aString ]! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectVersionEscaped  | pv |  pv := self projectVersion.  (projectVersion includes: $/)    ifTrue: [ ^ pv copyReplaceAll: '/' with: '\/' ].  ^ pv! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectVersionPattern  "do not set projectVersionPattern unless it _is_ a pattern: includes $#, %*, or $?"  projectVersionPattern ifNil: [ ^ self projectVersion ].  ^ projectVersionPattern! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!projectVersionPattern: aString  "do not set projectVersionPattern unless it _is_ a pattern: includes $#, %*, or $?"  projectVersionPattern := aString! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!repoPath  repoPath ifNil: [ repoPath := '' ].  ^ repoPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!repoPath: anObject    repoPath := anObject! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!repositoryBranchName  "for git-based network repos, answer the value of the projectVersion field"  ^ self projectVersion! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: '9/28/2017 08:53:52'!repositoryVersionString  "for git-based network repos, answer the SHA associated with the download: a commit SHA or tag SHA"  | versionComponents versionElement pathElements gitBasedPath repositoryDirPath projectDirPath projectDir projectVersionDir |  repositoryDirPath := self directory fullName.  projectDir := self class cacheDirectoryFor: self projectPath.  projectVersionDir := MCFileTreeFileUtils current    directoryFromPath: self projectVersion    relativeTo: projectDir.  projectDirPath := projectVersionDir fullName.  (repositoryDirPath beginsWith: projectDirPath)    ifFalse: [ ^ self projectVersion ].  gitBasedPath := repositoryDirPath    copyFrom: projectDirPath size + 2    to: repositoryDirPath size.  pathElements := gitBasedPath findTokens: '/'.  versionElement := pathElements at: 1.  versionComponents := versionElement findTokens: '-'.  ^ versionComponents last! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: '9/28/2017 08:53:52'!resolveProjectVersionPattern: aString  "aString must conform to the syntax for MetacelloVersionNumber with the exception that aString may have a leading $v which is stripped before conversion to a MetacelloVersionNumber patterm"  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath    ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (self class projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys    collect: [ :tagName |       | tagVersion |      tagVersion := self class projectVersionFromString: tagName.      tagVersion -> tagName ].  matchingTags := tagAssocs select: [ :assoc | assoc key match: patternString ].  matchingTags isEmpty    ifTrue: [       projectVersion := aString.      ^ self        error:          'No tags matching the pattern ' , aString printString            , ' found for repository description '            , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [ :a :b | a key <= b key ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag value! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:20'!basicDescription  ^ 'github'! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:17'!cacheDirectory  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  self resetCacheDirectoryIfInvalid.  CacheDirectory ifNil: [ CacheDirectory := self defaultCacheDirectory ].  ^ CacheDirectory! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:17'!cacheDirectory: aDirectory  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  CacheDirectory := aDirectory! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'topa 5/5/2015 11:24'!cacheDirectoryPath  <preference: 'GitHub Cache' category: 'Metacello' description: '' type:    #'String'>  ^ super cacheDirectoryPath! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:17'!downloadCache  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  DownloadCache ifNil: [ DownloadCache := Dictionary new ].  ^ DownloadCache! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 03/18/2015 06:35'!eTagsCache  "To avoid GitHub rate limiting problems, we are caching the ETags for the tag request: https://developer.github.com/v3/#conditional-requests"  ETagsCache ifNil: [ ETagsCache := Dictionary new ].  ^ ETagsCache! !!MCGitHubRepository class methodsFor: 'initialization' stamp: 'dkh 09/29/2014 12:17'!flushDownloadCache  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  "self flushDownloadCache"  DownloadCache := nil! !!MCGitHubRepository class methodsFor: 'initialization' stamp: 'dkh 03/18/2015 07:35'!flushETagsCache  "mainly needed for tests .... but if you want to pare down object consumption..."  "self flushETagsCache"  ETagsCache := nil! !!MCGitHubRepository class methodsFor: 'testing' stamp: 'JohanBrichau 10/11/2014 02:04'!isEnabled	^true! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 14:26'!projectTagsUrlFor: projectPath  ^ 'https://api.github.com/repos/' , projectPath , '/tags'! !!MCGitHubRepository class methodsFor: 'private' stamp: 'ct 10/12/2020 19:38'!projectZipUrlFor: projectPath versionString: versionString	^ 'https://api.github.com/repos/' , projectPath , '/zipball/' , versionString! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:17'!resetCacheDirectoryIfInvalid  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  "Reset if invalid"  CacheDirectory notNil    and: [       (MCFileTreeFileUtils current directoryExists: CacheDirectory)        ifFalse: [ CacheDirectory := nil ] ]! !!MCGitHubRepository methodsFor: 'private' stamp: 'dkh 03/18/2015 07:39'!downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current    downloadJSON: tagsUrl    eTagsCache: self class eTagsCache    eTagsKey: self projectPath    username: self class siteUsername    pass: self class sitePassword.  ^ self normalizeTagsData: jsonObject! !!MCGitHubRepository methodsFor: 'private' stamp: 'dkh 10/14/2014 15:18'!normalizeTagsData: jsonObject  "return a dictionay mapping the tag name to the commit SHA"  | tagDict |  jsonObject isDictionary    ifTrue: [       jsonObject        at: 'message'        ifPresent: [ :errorString |           self            error:              'Error accessing tags for github project: ' , self projectPath printString                , ' -> ' , errorString printString ] ].  tagDict := Dictionary new.  jsonObject    do: [ :tagObject |       | tag commit |      tag := tagObject at: 'name'.      commit := tagObject at: 'commit'.      tagDict at: tag put: (commit at: 'sha') ].  ^ tagDict! !!MCVersionLoader methodsFor: '*gofer-core-accessing' stamp: 'lr 12/18/2009 12:43'!goferHasVersions	^ versions isEmpty not! !!MCVersionLoader methodsFor: '*gofer-core-accessing' stamp: 'lr 12/18/2009 12:43'!goferVersions	^ versions! !!MCVersionLoader methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!versions	^versions! !!Array methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    | indent |    aStream        nextPutAll: '[';        lf.    indent := startIndent + 1.    1 to: self size do: [ :index |         | item |        item := self at: index.        aStream tab: indent.        item writeCypressJsonOn: aStream forHtml: forHtml indent: indent.        index < self size            ifTrue: [                 aStream                    nextPutAll: ',';                    lf ] ].    self size = 0        ifTrue: [ aStream tab: indent ].    aStream nextPutAll: ' ]'! !!MetacelloMethodSectionPath methodsFor: 'conversion' stamp: '9/28/2017 08:54:38'!asAttributeOrPath    self size = 1        ifTrue: [             | attribute |            attribute := self at: 1.            ^ attribute size = 1                ifTrue: [ attribute at: 1 ]                ifFalse: [ attribute ] ].    ^ self! !!MetacelloMethodSectionPath methodsFor: 'conversion' stamp: '9/28/2017 08:54:38'!asMetacelloAttributePath    ^ self! !!Color class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	| representation |	representation := stonReader parseMapOrListRepresentation.	^ representation isArray		ifTrue: [ 			self named: representation first ]		ifFalse: [ 			(representation includesKey: #rgb)				ifTrue: [ 					self basicNew setRGB: (representation at: #rgb); setAlpha: 1.0 "backwards compatibility" ]				ifFalse: [ 					self 						r: (representation at: #red) 						g: (representation at: #green) 						b: (representation at: #blue) 						alpha: (representation at: #alpha) ] ]! !!Color methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects	^ false! !!Color methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	| name |	(self isTranslucent or: [ (name := self name) = #unnamed ])		ifTrue: [ 			stonWriter writeObject: self streamMap: [ :map |				#(red green blue alpha) do: [ :each | 					map at: each put: ((self perform: each) roundTo: 0.001) ] ] ]		ifFalse: [ 			stonWriter writeObject: self listSingleton: name ]! !!DateAndTime class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !!DateAndTime methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloConfig: aMetacelloConfig    aMetacelloConfig setTimestampWithString: self printString! !!DateAndTime methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self printString;			yourself)! !!DateAndTime methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!DateAndTime methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Use an ISO representation with all details YYYY-MM-DDTHH:MM:SS.N+TZ (with optional nanoseconds and timezone offset)"		stonWriter writeObject: self listSingleton: 		(String streamContents: [ :stream |			self printOn: stream withLeadingSpace: false ])! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 18:06'!asMetacelloSemanticVersionNumber    ^ MetacelloSemanticVersionNumber fromString: ''! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: ''! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloRegistrationHash    ^ self hash! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!registrationsCompareEqual: aMetacelloProjectSpec    ^ self = aMetacelloProjectSpec! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: self! !!UndefinedObject methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!UndefinedObject methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeNull! !!UndefinedObject methodsFor: '*monticellofiletree-core' stamp: 'topa 7/22/2013 01:03'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream nextPutAll: 'null'.! !!Text class methodsFor: '*STON-Text support' stamp: '5/7/2020 21:10:00'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		^ self new		fromSton: stonReader;		yourself! !!Text methodsFor: '*STON-Text support' stamp: '5/7/2020 21:10:00'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		stonReader parseNamedInstVarsFor: self! !!Text methodsFor: '*STON-Text support' stamp: '5/7/2020 21:10:00'!stonOn: stonWriter	"Overwritten to get back the standard object behavior"		stonWriter writeObject: self! !!FileDirectory methodsFor: '*metacello-platform' stamp: 'dkh 2/25/2013 17:18'!asRepositorySpecFor: aMetacelloMCProject  ""  ^ aMetacelloMCProject repositorySpec    description: self fullName;    type: 'directory';    yourself! !!FileDirectory methodsFor: '*monticellofiletree-filedirectory-utilities' stamp: 'dkh 8/10/2012 09:10'!fileTreeUtilityClass    ^ MCFileTreeFileDirectoryUtils! !!GoferRepositoryError class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 19:15'!signal: aString repository: aRepository	^ self new repository: aRepository; signal: aString! !!GoferRepositoryError methodsFor: 'private' stamp: 'lr 12/9/2009 22:32'!isResumable	^ true! !!GoferRepositoryError methodsFor: 'accessing' stamp: 'lr 12/9/2009 19:14'!repository	^ repository! !!GoferRepositoryError methodsFor: 'accessing' stamp: 'lr 12/9/2009 19:14'!repository: aRepository	repository := aRepository! !!MetacelloCannotUpdateReleasedVersionError methodsFor: 'private' stamp: '9/28/2017 08:54:38'!isResumable	"Determine whether an exception is resumable."	^ true! !!MetacelloNameNotDefinedError methodsFor: 'Accessing' stamp: '9/28/2017 08:54:38'!isResumable  "Pharo and Squeak compatibility"  ^ true! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!description    "Return a textual description of the exception."    ^ 'Could not resolve: ' , packageSpec name , ' [' , packageSpec file , ']' , ' in' , self repositoryString        ,            (repositoryError == nil                ifTrue: [ '' ]                ifFalse: [                     "report repository error to user here, since failure here is likely to be due to earlier repository error"                    ' ERROR: ' , repositoryError description printString ])! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpec	^ packageSpec! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpec: anObject	packageSpec := anObject! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositories	^ repositories! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositories: anObject	repositories := anObject! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositoryError	^ repositoryError! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositoryError: anObject	repositoryError := anObject! !!MetacelloPackageSpecResolutionError methodsFor: 'private' stamp: '9/28/2017 08:54:38'!repositoryString    | repositoryString |    repositoryString := ''.    self repositories do: [ :repo | repositoryString := repositoryString , ' ' , repo description ].    ^ repositoryString! !!MetacelloPackageSpecResolutionError methodsFor: 'Signaling' stamp: '9/28/2017 08:54:38'!signal  "GemStone needs this to print exception correctly"  self messageText: self description.  ^ super signal! !!MetacelloProjectSpecLoadConflict methodsFor: 'private' stamp: '9/28/2017 08:54:38'!isResumable	"Determine whether an exception is resumable."	^ true! !!MetacelloProjectSpecLoadConflict methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!possibleVersions    "not applicable to a Conflict error"    self shouldNotImplement! !!MetacelloProjectSpecLoadConflict methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString    "not applicable to a Conflict error"    self shouldNotImplement! !!MetacelloProjectSpecLoadError class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!projectSpec: aMetacelloMCProjectSpec	^self new		projectSpec: aMetacelloMCProjectSpec;		yourself! !!MetacelloProjectSpecLoadError methodsFor: 'private' stamp: '9/28/2017 08:54:38'!isResumable	"Determine whether an exception is resumable."	^ false! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!possibleVersions    ^ self versionDoesNotExistException possibleVersions! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec	^projectSpec! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec: aMetacelloMCProjectSpec	projectSpec := aMetacelloMCProjectSpec! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionDoesNotExistException	^ versionDoesNotExistException! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionDoesNotExistException: anObject	versionDoesNotExistException := anObject! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString    ^ self versionDoesNotExistException versionString! !!MetacelloValidationFailure class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!issues: anObject message: aString    ^ self new        issues: anObject;        signal: aString! !!MetacelloValidationFailure methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!issues	^ issues! !!MetacelloValidationFailure methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!issues: anObject	issues := anObject! !!MetacelloSymbolicVersionDoesNotExistError methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!description    "Return a textual description of the exception."    ^ 'The symbolic version ' , self versionString printString , ' is not defined in ' , self project label        , ' for the current platform. Possible symbolic version values include: ' , self possibleVersions printString! !!MetacelloSymbolicVersionDoesNotExistError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!possibleVersions    ^ self project symbolicVersionSymbols! !!MetacelloSymbolicVersionNotDefinedError methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!description    "Return a textual description of the exception."    ^ 'The symbolic version ' , self versionString printString , ' is EXPLICITLY not defined in ' , self project label        , ' for the current platform (i.e., symbolic version defined as #notDefined).'! !!MetacelloVersionDefinitionError methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!description    "Return a textual description of the exception."    ^ 'The version ' , self versionString printString , ' is not defined in ' , self project label        , ' for the current platform, because an exception occurred while creating the version:. '        , self exception description , '. Evaluate the following to see the error: ''['        , self project configuration class name asString        ,            ' project ] 	on: MetacelloErrorInProjectConstructionNotification 	do: [:ex | ex resume: true ].'''        ,            'Possible versions include: ' , self possibleVersions printString! !!MetacelloVersionDefinitionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!exception	^ exception! !!MetacelloVersionDefinitionError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!exception: anObject	exception := anObject! !!MetacelloVersionDoesNotExistError class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!project: aMetacelloProject versionString: aVersionString	^(self new)		project: aMetacelloProject;		versionString: aVersionString;		yourself! !!MetacelloVersionDoesNotExistError methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!description    "Return a textual description of the exception."    ^ 'Version ' , self versionString printString , ' is not defined in ' , self project label        , '. Possible versions include: ' , self possibleVersions printString! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!possibleVersions    ^ self project symbolicVersionSymbols , (self project versions collect: [ :each | each versionString ])! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project	^ project! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project: anObject	project := anObject! !!MetacelloVersionDoesNotExistError methodsFor: 'Signaling' stamp: '9/28/2017 08:54:38'!signal  "GemStone needs this to print exception correctly"  self messageText: self description.  ^ super signal! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	^ versionString! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject	versionString := anObject! !!STONReaderError class methodsFor: 'instance creation' stamp: '5/7/2020 21:03:38'!signal: aString streamPosition: streamPosition 	^ self new		streamPosition: streamPosition;		signal: aString;		yourself! !!STONReaderError methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!messageText	^ streamPosition 		ifNil: [ 			super messageText ] 		ifNotNil: [ :pos | 			'At character <1P>: <2P>' expandMacrosWith: pos with: super messageText ]! !!STONReaderError methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!streamPosition	^ streamPosition! !!STONReaderError methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!streamPosition: aNumber	streamPosition := aNumber! !!SequenceableCollection class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Overwritten to use #streamContents: and #nextPut:"		^ self streamContents: [ :stream |		stonReader parseListDo: [ :each |			stream nextPut: each ] ]! !!SequenceableCollection methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Instances of STON listClass will be encoded directly, without a class tag.	Other (sub)classes will be encoded with a class tag and will use a list representation. "	self class == STON listClass		ifTrue: [ stonWriter writeList: self ]		ifFalse: [ super stonOn: stonWriter ]! !!Character class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	^ stonReader parseListSingleton first! !!Character methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeObject: self listSingleton: self asString! !!MCFileTreeAbstractReader class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 17:43'!monticelloMetaDirName    ^ '.'! !!MCFileTreeAbstractReader class methodsFor: 'reading' stamp: 'dkh 2/16/2012 14:49:00'!on: s fileName: f	^ (self on: s)		packageDirectory: f;		yourself! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 3/1/2012 12:09'!addClassAndMethodDefinitionsFromDirectory: aDirectory    self subclassResponsibility! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 14:00'!addClassAndMethodDefinitionsFromDirectoryEntries: entries    | timestamp |    self noMethodMetaData        ifTrue: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].    entries        do: [ :element |             element isDirectory                ifTrue: [                     | directory |                    directory := self fileUtils directoryFromEntry: element.                    ((self separateMethodMetaAndSource or: [ self noMethodMetaData ])                        ifTrue: [ directory entries select: [ :entry | entry name endsWith: '.st' ] ]                        ifFalse: [ directory entries ])                        do: [ :file |                             | definition |                            (definition := self definitionFromFile: file inDirectory: directory)                                ifNotNil: [                                     definition isMethodDefinition                                        ifTrue: [                                             self separateMethodMetaAndSource                                                ifTrue: [                                                     directory                                                        fileNamed: definition selector asString , '.meta'                                                        do: [ :fileStream | definition setTimeStamp: (Utilities fixStamp: fileStream contents) ] ].                                            self noMethodMetaData                                                ifTrue: [ definition setTimeStamp: timestamp ] ].                                    definitions add: definition ] ] ] ]! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 2/16/2012 14:49:00'!addDefinitionFromFile: directoryEntry inDirectory: aDirectory    (self definitionFromFile: directoryEntry inDirectory: aDirectory) ifNotNil: [ :def | definitions add: def ]! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!basicVersion	^ (MCVersion new)		setPackage: self package			info: self info			snapshot: self snapshot			dependencies: self dependencies;		yourself! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:39'!definitionFromFile: directoryEntry inDirectory: aDirectory    | defs reader |    directoryEntry ifNil: [ ^ nil ].    self fileUtils        readStreamFor: directoryEntry name        in: aDirectory        do: [ :fileStream |             | methodDefinition |            reader := MCStReader on: fileStream.            (defs := reader definitions) size <= 1                ifFalse: [ self error: 'we should be writing exactly 1 definition per file' ] ].    defs size = 0        ifTrue: [ ^ nil ].    ^ defs first! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 8/10/2012 05:39'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeAbstractReader methodsFor: 'testing' stamp: 'dkh 8/10/2012 05:44'!hasMonticelloMetadata    | metaDir |    ^ ((self fileUtils        directoryExists:            (metaDir := self fileUtils                directoryFromPath: MCFileTreeStCypressWriter monticelloMetaDirName                relativeTo: packageDirectory))        and: [ self fileUtils filePathExists: 'version' relativeTo: metaDir ])        or: [             (self fileUtils filePathExists: 'version' relativeTo: packageDirectory)                and: [ self fileUtils filePathExists: 'package' relativeTo: packageDirectory ] ]! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'topa 8/29/2013 00:58'!loadDefinitions    | entries |    definitions := OrderedCollection new.    entries := packageDirectory entries.    self        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'categories' ] ifNone: [  ])            inDirectory: packageDirectory;        addClassAndMethodDefinitionsFromDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'initializers' ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry |               (entry name beginsWith: 'preamble') and: [	        (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry |              (entry name beginsWith: 'postscript') and: [	        (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'preambleOfRemoval' ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'postscriptOfRemoval' ] ifNone: [  ])            inDirectory: packageDirectory.! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:18'!loadDependencies    | dependencyDir directoryPath |    directoryPath := self monticelloMetaDirName , self fileUtils pathNameDelimiter asString , 'dependencies'.    dependencyDir := self fileUtils directoryFromPath: directoryPath relativeTo: packageDirectory.    (self fileUtils directoryExists: dependencyDir)        ifFalse: [ ^ dependencies := #() ].    dependencies := OrderedCollection new.    dependencyDir entries        do: [ :entry |             dependencies                add:                    (MCVersionDependency                        package: (MCPackage named: entry name)                        info:                            (self extractInfoFrom: (self parseMember: 'dependencies' , self fileUtils pathNameDelimiter asString , entry name))) ].    dependencies := dependencies asArray! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 4/4/2012 17:43'!monticelloMetaDirName    ^ self class monticelloMetaDirName! !!MCFileTreeAbstractReader methodsFor: 'testing' stamp: 'dkh 3/1/2012 10:11'!noMethodMetaData    ^ self packageProperties at: 'noMethodMetaData' ifAbsent: [ false ]! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 8/10/2012 05:46'!packageDirectory: aDirectoryName    packageDirectory := self fileUtils directoryFromPath: aDirectoryName relativeTo: stream! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 3/1/2012 11:56'!packageProperties    packageProperties        ifNil: [             packageProperties := Dictionary new.            (packageDirectory entries detect: [ :entry | entry name = '.filetree' ] ifNone: [  ])                ifNotNil: [ :configEntry |                     configEntry                        readStreamDo: [ :fileStream |                             | jsonObject structureVersion |                            [                             (jsonObject := MCFileTreeJsonParser parseStream: fileStream) isFloat                                ifTrue: [                                     "							0.0 - original structure							0.1 - separate files for method metaData (timestamp) and source							0.2 - no method metaData file"                                    packageProperties := Dictionary new.                                    structureVersion := jsonObject printShowingDecimalPlaces: 1.                                    packageProperties at: 'noMethodMetaData' put: structureVersion = '0.2'.                                    packageProperties at: 'separateMethodMetaAndSource' put: structureVersion = '0.1' ]                                ifFalse: [                                     packageProperties := jsonObject.                                    ((packageProperties at: 'noMethodMetaData' ifAbsent: [ false ])                                        and: [ packageProperties at: 'separateMethodMetaAndSource' ifAbsent: [ false ] ])                                        ifTrue: [ self error: 'noMethodMetaData and separateMethodMetaAndSource cannot both be true' ] ] ]                                on: Error                                do: [ :ex |                                     Transcript                                        cr;                                        show:                                                'Error reading package properties (.filetree): ' , packageDirectory pathName , ' :: ' , ex description ] ] ] ].    ^ packageProperties! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:43'!parseMember: fileName    | directory tokens |    directory := self fileUtils directoryFromPath: self monticelloMetaDirName relativeTo: packageDirectory.    self fileUtils readStreamFor: fileName in: directory do: [ :fileStream | tokens := self scanner scan: fileStream ].    ^ self associate: tokens! !!MCFileTreeAbstractReader methodsFor: 'testing' stamp: 'dkh 3/1/2012 10:10'!separateMethodMetaAndSource    ^ self packageProperties at: 'separateMethodMetaAndSource' ifAbsent: [ false ]! !!MCFileTreeStReader class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 12:04'!extension	^ 'tree'! !!MCFileTreeStReader methodsFor: 'utilities' stamp: 'dkh 3/1/2012 12:18'!addClassAndMethodDefinitionsFromDirectory: aDirectory    self addClassAndMethodDefinitionsFromDirectoryEntries: aDirectory entries! !!MCFileTreeStCypressReader class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 14:19'!extension    ^ 'package'! !!MCFileTreeStCypressReader class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 17:44'!monticelloMetaDirName    ^ MCFileTreeStCypressWriter monticelloMetaDirName! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 7/22/2013 01:41'!addClassAndMethodDefinitionsFromDirectory: aDirectory    aDirectory entries        do: [ :entry |             (entry name endsWith: '.trait')                ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].            (entry name endsWith: '.class')                ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].            (entry name endsWith: '.extension')                ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ]! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 13:48'!addClassAndMethodDefinitionsFromEntry: classEntry    | classDirectory classPropertiesDict classComment entries methodPropertiesDict |    classDirectory := self fileUtils directoryFromEntry: classEntry.    ((entries := classDirectory entries) detect: [:entry | self isPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ].    methodPropertiesDict := Dictionary new.    (entries detect: [ :entry | self isMethodPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry |             propertyEntry                readStreamDo: [ :fileStream |                     "Issue 33: https://github.com/dalehenrich/filetree/issues/33"                    methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    self addClassDefinitionFrom: classPropertiesDict comment: classComment withSqueakLineEndings.    self        addMethodDefinitionsForClass: (classPropertiesDict at: 'name')        methodProperties: methodPropertiesDict        in: entries! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:51'!addClassDefinitionFrom: classPropertiesDict comment: classComment  | categoryName className |  className := classPropertiesDict at: 'name'.  categoryName := classPropertiesDict    at: 'category'    ifAbsent: [ self packageNameFromPackageDirectory ].  self validateClassCategory: categoryName for: className.  definitions    add:      (MCClassDefinition        name: className        superclassName: (classPropertiesDict at: 'super')        traitComposition: (classPropertiesDict at: 'traitcomposition' ifAbsent: [ '{}' ])        classTraitComposition: (classPropertiesDict at: 'classtraitcomposition' ifAbsent: [ '{}' ])        category: categoryName        instVarNames: (classPropertiesDict at: 'instvars' ifAbsent: [ #() ])        classVarNames: (classPropertiesDict at: 'classvars' ifAbsent: [ #() ])        poolDictionaryNames: (classPropertiesDict at: 'pools' ifAbsent: [ #() ])        classInstVarNames:          (classPropertiesDict at: 'classinstvars' ifAbsent: [ #() ])        type: (classPropertiesDict at: 'type' ifAbsent: [ 'normal' ]) asSymbol        comment: classComment        commentStamp: (classPropertiesDict at: 'commentStamp' ifAbsent: [ '' ]))! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:56'!addExtensionClassAndMethodDefinitionsFromEntry: classEntry  | classDirectory classPropertiesDict methodPropertiesDict entries |  classDirectory := self fileUtils directoryFromEntry: classEntry.  ((entries := classDirectory entries)    detect: [ :entry | self isPropertyFile: entry ]    ifNone: [  ])    ifNotNil: [ :propertyEntry |       propertyEntry        readStreamDo: [ :fileStream |           classPropertiesDict := MCFileTreeJsonParser            parseStream: fileStream ] ].  methodPropertiesDict := Dictionary new.  (entries detect: [ :entry | self isMethodPropertyFile: entry ] ifNone: [  ])    ifNotNil: [ :propertyEntry |       propertyEntry        readStreamDo: [ :fileStream |           "Issue 33: https://github.com/dalehenrich/filetree/issues/33"          methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].  self    addMethodDefinitionsForClass: (classPropertiesDict at: 'name')    methodProperties: methodPropertiesDict    in: entries    extensionMethod: true! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:55'!addMethodDefinitionsForClass: className methodProperties: methodProperties in: entries  ^ self    addMethodDefinitionsForClass: className    methodProperties: methodProperties    in: entries    extensionMethod: false! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:56'!addMethodDefinitionsForClass: className methodProperties: methodProperties in: entries extensionMethod: extensionMethod    entries        do: [ :entry |             | classIsMeta |            classIsMeta := false.            entry name = 'class'                ifTrue: [ classIsMeta := true ].            (entry name = 'instance' or: [ entry name = 'class' ])                ifTrue: [                     ((self fileUtils directoryFromEntry: entry) entries select: [ :each | each name endsWith: '.st' ])                        do: [ :methodEntry |                             methodEntry                                readStreamDo: [ :fileStream |                                     | category source timestamp selector |                                    category := fileStream nextLine.                                    source := fileStream upToEnd.                                    selector := self methodSelectorFor: source.                                    timestamp := methodProperties                                        at:                                            (classIsMeta                                                ifTrue: [ 'class' ]                                                ifFalse: [ 'instance' ])                                        ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"                                    timestamp                                        ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].                                    extensionMethod                                      ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].                                    definitions                                        add:                                            (MCMethodDefinition                                                className: className                                                classIsMeta: classIsMeta                                                selector: selector                                                category: category                                                timeStamp: timestamp                                                source: source) ] ] ] ]! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 7/22/2013 14:41'!addTraitAndMethodDefinitionsFromEntry: classEntry    | classDirectory classPropertiesDict classComment entries methodPropertiesDict |    classDirectory := self fileUtils directoryFromEntry: classEntry.    ((entries := classDirectory entries) detect: [:entry | self isPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ]        ifNil: [ classComment := '' ].    methodPropertiesDict := Dictionary new.    (entries detect: [ :entry | self isMethodPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry |             propertyEntry                readStreamDo: [ :fileStream |                     "Issue 33: https://github.com/dalehenrich/filetree/issues/33"                    methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    self addTraitDefinitionFrom: classPropertiesDict comment: classComment withSqueakLineEndings.    self        addMethodDefinitionsForClass: (classPropertiesDict at: 'name')        methodProperties: methodPropertiesDict        in: entries! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 7/22/2013 15:15'!addTraitDefinitionFrom: traitPropertiesDict comment: traitComment    definitions        add:            (MCTraitDefinition                name: (traitPropertiesDict at: 'name')                traitComposition: (traitPropertiesDict at: 'traitcomposition' ifAbsent: [ '{}' ])                category: (traitPropertiesDict at: 'category' ifAbsent: [ self packageNameFromPackageDirectory ])                comment: traitComment                commentStamp: (traitPropertiesDict at: 'commentStamp' ifAbsent: [ '' ])).    traitPropertiesDict at: 'classtraitcomposition' ifPresent: [:classTraitComposition |        definitions             add:                (MCClassTraitDefinition                    baseTraitName: (traitPropertiesDict at: 'name')                    classTraitComposition: classTraitComposition)].! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: 'dkh 6/27/2012 20:19'!basicVersion    self hasMonticelloMetadata        ifTrue: [ ^ super basicVersion ].    ^ MCVersion new        setPackage: self package            info: self info            snapshot: self snapshot            dependencies: #();        yourself! !!MCFileTreeStCypressReader methodsFor: 'private' stamp: 'dkh 6/16/2013 12:47:20'!isMethodPropertyFile: entry	^ entry name = 'methodProperties.ston' or: [ entry name = 'methodProperties.json']! !!MCFileTreeStCypressReader methodsFor: 'private' stamp: 'dkh 6/16/2013 12:47:20'!isPropertyFile: entry	^ entry name = 'properties.ston' or: [ entry name = 'properties.json']! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 8/29/2013 00:57'!loadDefinitions    | entries directory |    definitions := OrderedCollection new.    directory := self fileUtils directoryFromPath: self monticelloMetaDirName relativeTo: packageDirectory.    (self fileUtils directoryExists: directory)        ifTrue: [             entries := directory entries.            self                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'categories' ] ifNone: [  ])                inDirectory: directory ].    self addClassAndMethodDefinitionsFromDirectory: packageDirectory.    (self fileUtils directoryExists: directory)        ifTrue: [             self                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'initializers' ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry |                    (entry name beginsWith: 'preamble') and: [                   (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry |                   (entry name beginsWith: 'postscript') and: [                   (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'preambleOfRemoval' ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'postscriptOfRemoval' ] ifNone: [  ])                inDirectory: directory. ]! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: 'dkh 6/27/2012 20:21'!loadPackage    self hasMonticelloMetadata        ifTrue: [ ^ super loadPackage ].    package := MCPackage named: self packageNameFromPackageDirectory! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: '08/08/2013 15:01'!loadVersionInfo  self hasMonticelloMetadata    ifTrue: [ ^ info := self extractInfoFrom: (self parseMember: 'version') ].  info := MCVersionInfo    name: self packageNameFromPackageDirectory , '-cypress.1'    id: UUID new    message: 'fabricated from a Cypress format repository'    date: Date today    time: Time now    author: ''    ancestors: #()    stepChildren: #()! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'ChristopheDemarey 5/31/2013 23:28'!methodSelectorFor: source    ^ Object parserClass new parseSelector: source! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: 'dkh 8/10/2012 14:55'!packageNameFromPackageDirectory    | filename |    filename := self fileUtils directoryName: packageDirectory.    ^ filename copyFrom: 1 to: (filename lastIndexOf: $.) - 1! !!MCFileTreeStCypressReader methodsFor: 'validation' stamp: 'dkh 01/31/2015 12:20'!validateClassCategory: categoryName for: className  "https://github.com/dalehenrich/filetree/issues/136"  "class category must match the package name ... guard against manual editing mistakes"  | prefix |  prefix := self packageNameFromPackageDirectory.  (self verifyCategory: categoryName matches: prefix)    ifTrue: [ ^ self ].  self    error:      'Class category name ' , categoryName printString , ' for the class '        , className printString , ' is inconsistent with the package name '        , prefix printString! !!MCFileTreeStCypressReader methodsFor: 'validation' stamp: 'dkh 01/31/2015 13:41'!validateExtensionMethodCategory: categoryName for: className selector: selector  "https://github.com/dalehenrich/filetree/issues/136"  "method category must match the package name for extension methods... guard against manual editing mistakes"  "extracted from PackageInfo>>isForeignClassExtension:"  | prefix prefixSize catSize |  prefix := '*' , self packageNameFromPackageDirectory asLowercase.  categoryName    ifNotNil: [       (categoryName isEmpty not        and: [           categoryName first = $*            and: [               "asLowercase needed in GemStone 3.1.0.6?"              self verifyCategory: categoryName asLowercase matches: prefix ] ])        ifTrue: [ ^ self ] ].  self    error:      'Method protocol ' , categoryName printString , ' for the method '        , selector asString printString , ' in class ' , className printString        , ' is inconsistent with the package name ' , prefix printString! !!MCFileTreeStCypressReader methodsFor: 'validation' stamp: 'dkh 01/31/2015 15:14'!verifyCategory: categoryName matches: basicPackageName  "https://github.com/dalehenrich/filetree/issues/136"  "copied from PackageInfo>>category:matches: and GoferVersionReference>>parseName:"  | prefixSize catSize packagePrefix |  categoryName ifNil: [ ^ false ].  packagePrefix := basicPackageName.  (packagePrefix includes: $.)    ifTrue: [       "exclude branch name"      packagePrefix := packagePrefix copyUpTo: $. ].  catSize := categoryName size.  prefixSize := packagePrefix size.  catSize < prefixSize    ifTrue: [ ^ false ].  (categoryName findString: packagePrefix startingAt: 1 caseSensitive: false)    = 1    ifFalse: [ ^ false ].  ^ (categoryName at: packagePrefix size + 1 ifAbsent: [ ^ true ]) = $-! !!MCFileTreeStSnapshotReader class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 12:06'!extension    ^ 'pkg'! !!MCFileTreeStSnapshotReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 14:03'!addClassAndMethodDefinitionsFromDirectory: aDirectory    | snapshot classes entries extensions |    snapshot := self fileUtils directoryFromPath: 'snapshot' relativeTo: aDirectory.    classes := self fileUtils directoryFromPath: 'classes' relativeTo: snapshot.    (self fileUtils directoryExists: classes)        ifTrue: [             self addClassAndMethodDefinitionsFromDirectoryEntries: (entries := classes entries).	"load .st files from subdirectories (*.class) of snapshot/classes ... class defintions"            entries                do: [ :classDirectoryEntry |                     | classDirectory |                    classDirectory := self fileUtils directoryFromEntry: classDirectoryEntry.                    self addClassAndMethodDefinitionsFromDirectoryEntries: classDirectory entries	"load .st files from subdirectories (class or instance) of snapshot/classes/*.class ... method definitions" ] ].    extensions := self fileUtils directoryFromPath: 'extensions' relativeTo: snapshot.    (self fileUtils directoryExists: extensions)        ifTrue: [             extensions entries                do: [ :classDirectoryEntry |                     | classDirectory |                    classDirectory := self fileUtils directoryFromEntry: classDirectoryEntry.                    self addClassAndMethodDefinitionsFromDirectoryEntries: classDirectory entries	"load .st files from subdirectories (class or instance) of snapshot/extensions/*.class ... method definitions" ] ]! !!Dictionary class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Instances of STON mapClass will be read directly and won't arrive here.	Other (sub)classes will use this method."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !!Dictionary methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Instances of STON mapClass will be encoded directly, without a class tag.	Other (sub)classes will be encoded with a class tag and will use a map representation. "		self class == STON mapClass		ifTrue: [ 			stonWriter writeMap: self ]		ifFalse: [ 			stonWriter 				writeObject: self 				do: [ stonWriter encodeMap: self ] ]! !!Dictionary methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonPostReferenceResolution	"When references were resolved in me, the hash of my keys might have changed.	Check if I am still healthy and rehash me if not."		self isHealthy ifFalse: [ self rehash ]! !!Dictionary methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonForHtmlOn: aStream    self writeCypressJsonOn: aStream forHtml: true indent: 0! !!Dictionary methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream    self writeCypressJsonOn: aStream forHtml: false indent: 0.    aStream lf! !!Dictionary methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    | indent keys |    indent := startIndent.    aStream        nextPutAll: '{';        lf.    indent := indent + 1.    keys := self keys sort: [ :a :b | a <= b ].    1 to: keys size do: [ :index |         | key value |        key := keys at: index.        value := self at: key.        aStream tab: indent.        key writeCypressJsonOn: aStream forHtml: forHtml indent: indent.        aStream nextPutAll: ' : '.        value writeCypressJsonOn: aStream forHtml: forHtml indent: indent.        index < self size            ifTrue: [                 aStream                    nextPutAll: ',';                    lf ] ].    self size = 0        ifTrue: [ aStream tab: indent ].    aStream nextPutAll: ' }'! !!Fraction methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeFraction: self! !!MCFileBasedRepository methodsFor: '*gofer-core-accessing' stamp: 'TestRunner 12/12/2009 11:12'!goferReferences	| versionNames |	versionNames := [ self allVersionNames ]		on: Error		do: [ :error | ^ GoferRepositoryError signal: error messageText repository: self ].	^ versionNames		collect: [ :each | GoferResolvedReference name: each repository: self ]! !!MCFileBasedRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/12/2009 11:29'!goferVersionFrom: aVersionReference	^ self loadVersionFromFileNamed: aVersionReference name , '.mcz'! !!MCFileBasedRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!versionInfoFromVersionNamed: aString	| versions |	versions := self allVersionNames		select: [ :each | each beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ self versionInfoFromFileNamed: versions last , '.mcz'! !!BlockClosure methodsFor: '*metacello-core-scripting' stamp: 'dkh 7/16/2012 10:51'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeBlock: self do: projectSpecBlock! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setBaseline: aString withInMetacelloConfig: aMetacelloConfig    aMetacelloConfig setBaseline: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setConfiguration: aString withInMetacelloConfig: aMetacelloConfig    aMetacelloConfig setConfiguration: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithBlock: self! !!BlockClosure methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!valueSupplyingMetacelloAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[(caption includesSubstring: each first caseSensitive: false) or:						[(each first match: caption) or:						[(String includesSelector: #matchesRegex:) and: 						[ [ caption matchesRegex: each first ] on: Error do: [:ignored | false ]]]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!MCMethodDefinition methodsFor: '*monticellofiletree-core' stamp: 'dkh 2/16/2012 14:49:00'!setTimeStamp: aString    ^ timeStamp := aString! !!Bag class methodsFor: '*STON-Core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Read a map representation containing element/occurences pairs"		| bag |	bag := self new.	stonReader parseMapDo: [ :key :value |		bag add: key withOccurrences: value ].	^ bag! !!Bag methodsFor: '*STON-Core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Use a map with element-occurences pairs as representation"	stonWriter 		writeObject: self 		do: [ stonWriter encodeMap: contents ]! !!ScaledDecimal methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeScaledDecimal: self! !!Date class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Read a ISO YYYY-MM-DD format.	Since my current implementation is time zone offset sensitive, the offset has to be taken into account.	A missing offset results in the local timezone offset to be used"		| readStream date |	readStream := stonReader parseListSingleton readStream.	date := self readFrom: readStream.	readStream atEnd		ifFalse: [ | offset |			offset := DateAndTime readTimezoneOffsetFrom: readStream.			offset = date offset 				ifFalse: [ date start: (date start translateTo: offset) ] ].	^ date! !!Date methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!Date methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Use an ISO style YYYY-MM-DD representation.	Since my current implementation is time zone offset sensitive, the offset has to be included."	| representation |	representation := self offset isZero		ifTrue: [ 			String new: 11 streamContents: [ :out | 				self printOn: out format: #(3 2 1 $- 1 1 2).				out nextPut: $Z ] ]		ifFalse: [ 			String new: 32 streamContents: [ :out | 				self printOn: out format: #(3 2 1 $- 1 1 2).				out nextPut: (self offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).				self offset hours abs printOn: out base: 10 length: 2 padded: true.				out nextPut: $:.				self offset minutes abs printOn: out base: 10 length: 2 padded: true.				self offset seconds = 0 					ifFalse:[ 						out nextPut: $:; print: self offset seconds abs truncated ] ] ].	stonWriter writeObject: self listSingleton: representation! !!MetacelloClassAPIHelpBuilder methodsFor: 'private building' stamp: 'dkh 4/10/2011 20:08:41'!buildSubnodesForMethods	| class pragmas classSide stream |	class := rootToBuildFrom class.	pragmas := (Pragma allNamed: #apiDocumentation in: class) asArray sort: [ :a :b | a selector <= b selector ].	pragmas isEmpty ifTrue: [ ^self ].	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	classSide := HelpTopic named: 'Class side'.	topicToBuild addSubtopic: classSide.	pragmas		do: [ :pragma | 			| topic comments methodComment |			topic := HelpTopic named: pragma selector asString.			classSide addSubtopic: topic.			stream := String new writeStream.			stream				nextPutAll: class name;				nextPutAll: '>>';				nextPutAll: pragma selector asString;				cr;				cr.			comments := class commentsAt: pragma selector.			methodComment := comments size = 0				ifTrue: [ 'Method has no comment.' ]				ifFalse: [ comments first ].			stream nextPutAll: methodComment.			topic contents: stream contents ]! !!MetacelloConfigurationHelp class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!bookName 	^'Metacello Configurations'! !!MetacelloConfigurationHelp class methodsFor: 'defaults' stamp: 'dkh 4/10/2011 20:08:41'!builder	^MetacelloConfigurationHelpBuilder! !!MetacelloConfigurationHelp class methodsFor: 'pages' stamp: 'dkh 4/10/2011 20:08:41'!icon	^HelpIcons iconNamed: #packageIcon! !!MetacelloConfigurationHelp class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!key	^'Metacello Configuration help'! !!MetacelloConfigurationHelp class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!pages	^#()! !!MetacelloAPIDocumentation class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!bookName	^'API Documentation'! !!MetacelloAPIDocumentation class methodsFor: 'defaults' stamp: 'dkh 4/10/2011 20:08:41'!builder	^MetacelloPackageAPIHelpBuilder! !!MetacelloAPIDocumentation class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!packages	^#('Metacello-Base' 'Metacello-ToolBox' 'Metacello-MC-Validation')! !!MetacelloHelp class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!bookName 	^'Metacello'! !!MetacelloHelp class methodsFor: 'pages' stamp: 'dkh 4/10/2011 20:08:41'!features	^HelpTopic 			title: 'Features'		contents: 'Metacello is consistent with the following features of a package management system.		DECLARATIVE MODELINGA Metacello project has named versions consisting of lists of explicit Monticello package versions. Dependencies are explicitly expressed in terms of named versions of required projects. A required project is a reference to another Metacello project.DISTRIBUTED REPOSITORIESMetacello project metadata is represented as instance methods in a class therefore the Metacello project metadata is stored in a Monticello package. As a result, it is easy for distributed groups of developers to collaborate on ad hoc projects.OPTIMISTIC DEVELOPMENTWith Monticello-based packages, concurrent updates to the project metadata can be easily managed. Parallel versions of the metadata can be merged just like parallel versions of the code base itself.	Additionally, the following three points are important considerations for Metacello:CROSS PLATFORM OPERATIONMetacello must run on all platforms that support Monticello: currently Squeak, Pharo and GLASS.CONDITIONAL MONTICELLO PACKAGE LOADINGFor projects that are expected to run on multiple platforms, it is essential that platform-specific Monticello packages can be conditionally loaded. At the moment, conditional loading is specified based upon the following attributes:#common - Code that is common across all platforms.#squeakCommon - Code that is common to Squeak and Pharo.#squeak - Code that is specific to Squeak.#pharo - Code that is specific to Pharo.#gemstone - Code that is specific to GemStone.It should be possible to inject project-specific attributes, so code that is dependent upon attributes not covered by the standard list can be conditionally loaded. For example, in GLASS, different Monticello package versions are loaded based on which version of GemStone/S is running (i.e., version 2.0 versus 3.0).COMPATIBLE WITH MC2It must be possible to manage Metacello projects that are based on alternate Distributed Source Code Management systems like Monticello2.MIT LICENSED						'! !!MetacelloHelp class methodsFor: 'pages' stamp: 'dkh 4/10/2011 20:08:41'!gettingStarted	^HelpTopic 			title: 'Getting Started'		contents: 'If you have a porject that you''d like to use Metacello with, you should start by taking the Metacello tutorial to familiar yourself with the configuration specification language. First load the tutorial code:	ConfigurationOfMetacello project latestVersion load: #(''Tutorial'').take the ProfStef-based toturial:	ProfStef goOn: MetacelloConfigurationTutorialPart1.	ProfStef goOn: MetacelloConfigurationTutorialPart2.or take the image-based-tutorial:	http://code.google.com/p/metacello/wiki/TutorialThen you should run through the Development process tutorial:	ProfStef goOn: MetacelloDevelopmentProcess.Other online resources:	http://code.google.com/p/metacello/	http://forum.world.st/Monticello-Metacello-f1460836.html	http://groups.google.com/group/metacello	http://code.google.com/p/metacello/wiki/APIReference	'! !!MetacelloHelp class methodsFor: 'pages' stamp: 'dkh 4/10/2011 20:08:41'!icon	^HelpIcons iconNamed: #packageIcon! !!MetacelloHelp class methodsFor: 'pages' stamp: 'dkh 4/10/2011 20:08:41'!introduction	^HelpTopic 			title: 'Introduction'		contents: 'Metacello is a package management system for Monticello. A package management system is a collection of tools to automate the process of installing, upgrading, configuring, and removing software packages from a computer. Distributions of Linux and other Unix-like systems typically consist of hundreds or even thousands of distinct software packages; in the former case a package management system is nice, in the latter case it is essential.Packages are distributions of software and metadata such as the software''s full name, description of its purpose, version number, vendor, checksum, and a list of dependencies necessary for the software to run properly. Upon installation, metadata is stored in a local package database.A package management system provides a consistent method of installing software' ! !!MetacelloHelp class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!key	^'Metacello help'! !!MetacelloHelp class methodsFor: 'accessing' stamp: 'dkh 4/10/2011 20:08:41'!pages	^#(introduction features gettingStarted)! !!MCFileTreeAbstractStWriter class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!monticelloMetaDirName    ^ '.'! !!MCFileTreeAbstractStWriter class methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!on: aStream    MCFileTreePackageStructureStWriter useCypressWriter        ifTrue: [ ^ MCFileTreeStCypressWriter new stream: aStream ].    ^ (MCFileTreePackageStructureStWriter useSnapShotWriter        ifTrue: [ MCFileTreeStSnapshotWriter ]        ifFalse: [ MCFileTreeStWriter ]) new stream: aStream! !!MCFileTreeAbstractStWriter class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!readerClass	^ MCStReader! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!directoryForDirectoryNamed: directoryNameOrPath    ^ directoryNameOrPath = '.'        ifTrue: [ stream packageFileDirectory ]        ifFalse: [ stream subPackageFileDirectoryFor: directoryNameOrPath ]! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!fileNameForSelector: selector    ^ (selector == #'/'        ifTrue: [ 'encoded slash' ]        ifFalse: [             (selector includes: $/)                ifTrue: [ 'encoded' , selector copyReplaceAll: '/' with: ' slash ' ]                ifFalse: [ selector ] ]) asString! !!MCFileTreeAbstractStWriter methodsFor: 'accessing' stamp: 'dkh 08/10/2012 02:55:31'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'topa 7/22/2013 00:13'!initialize    stWriter := MCFileTreePackageStructureStWriter new        initializers: (initializers := Set new);        yourself.    orderedClassNames := OrderedCollection new.    orderedTraitNames := OrderedCollection new.! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!monticelloMetaDirName    ^ self class monticelloMetaDirName! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 07/07/2013 22:12'!repository  ^ stream repository! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!setFileStream: file    stWriter stream: file! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitClassDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 14:35'!visitClassTraitDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitMetaclassDefinition: definition    "handled by class definition"! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitMethodDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitOrganizationDefinition: defintion    self        writeInDirectoryName: self monticelloMetaDirName        fileName: 'categories'        extension: '.st'        visit: [ defintion categories do: [ :cat | stWriter writeCategory: cat ] ]! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'topa 8/29/2013 21:09'!visitScriptDefinition: definition    self        writeInDirectoryName: self monticelloMetaDirName        fileName: definition scriptSelector asString        extension: '.st'        visit: [ stWriter writeScriptDefinition: definition ]! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 00:05'!visitTraitDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writeBasicDefinitions: aCollection    "the correct initialization order is unknown if some classes are missing in the image"    self writePropertiesFile.    stWriter acceptVisitor: self forDefinitions: aCollection.    self writeInitializers! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 13:55'!writeClassDefinition: definition    stWriter writeClassDefinition: definition.    (definition hasClassInstanceVariables or: [definition hasClassTraitComposition])        ifTrue: [ stWriter writeMetaclassDefinition: definition ].    definition hasComment        ifTrue: [ stWriter writeClassComment: definition ]! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 13:26'!writeClassTraitDefinition: definition    stWriter visitClassTraitDefinition: definition.! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writeDefinitions: aCollection    "the correct initialization order is unknown if some classes are missing in the image"    self writeBasicDefinitions: aCollection! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 04/07/2012 10:32'!writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    self fileUtils        writeStreamFor: fileName , ext        in: directory        do: [ :fileStream |             fileStream lineEndConvention: #'lf'.            self setFileStream: fileStream.            visitBlock value ]! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writeInitializers    self        writeInDirectoryName: self monticelloMetaDirName        fileName: 'initializers'        extension: '.st'        visit: [             stWriter                writePresentInitializers;                writeAbsentInitializers ]! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!writeMethodDefinition: definition    stWriter visitMethodDefinition: definition! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writePropertiesFile    self        writeInDirectoryName: '.'        fileName: ''        extension: '.filetree'        visit: [ stWriter writeProperties ]! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 00:16'!writeTraitDefinition: definition    stWriter writeClassDefinition: definition.    definition hasComment         ifTrue: [stWriter writeClassComment: definition].! !!MCFileTreeStCypressWriter class methodsFor: 'accessing' stamp: 'dkh 9/8/2013 07:16:04'!fileNameForSelector: selector  ^ (selector includes: $:)    ifTrue: [       selector        collect: [ :each |           each = $:            ifTrue: [ $. ]            ifFalse: [ each ] ] ]    ifFalse: [       (self specials includes: selector first)        ifFalse: [ selector ]        ifTrue: [           | output specials |          specials := self specials.          output := String new writeStream.          output nextPut: $^.          selector            do: [ :each |               output                nextPutAll:                  ((specials includes: each)                    ifTrue: [ specials at: each ]                    ifFalse: [ each asString ]) ]            separatedBy: [ output nextPut: $. ].          output contents ] ]! !!MCFileTreeStCypressWriter class methodsFor: 'private' stamp: 'PeterMcLain 10/02/2012 14:47'!initializeSpecials    | map |    map := Dictionary new.    map        at: $+ put: 'plus';        at: $- put: 'minus';        at: $= put: 'equals';        at: $< put: 'less';        at: $> put: 'more';        at: $% put: 'percent';        at: $& put: 'and';        at: $| put: 'pipe';        at: $* put: 'star';        at: $/ put: 'slash';        at: $\ put: 'backslash';        at: $~ put: 'tilde';        at: $? put: 'wat';        at: $, put: 'comma';        at: $@ put: 'at'.    map keys do: [ :key | map at: (map at: key) put: key ].    ^ map! !!MCFileTreeStCypressWriter class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 15:05'!monticelloMetaDirName    ^ 'monticello.meta'! !!MCFileTreeStCypressWriter class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 11:27'!specials    ^ specials ifNil: [ specials := self initializeSpecials ]! !!MCFileTreeStCypressWriter methodsFor: 'private' stamp: 'dkh 02/13/2013 17:04'!fileNameForSelector: selector  ^ self class fileNameForSelector: selector! !!MCFileTreeStCypressWriter methodsFor: 'private' stamp: 'dkh 08/08/2013 18:37'!fileNameMapFor: aMethodDefinitionCollection  "https://github.com/dalehenrich/filetree/issues/92"  "answer a dictionary that maps each definition selector to a filename that is guaranteed unique on case insensitive file systems.  Segregate instance and class side methods. Key is true for class method map, false for instance method map"  | map filenameMetaMap |  map := Dictionary new.  aMethodDefinitionCollection    do: [ :mDef |       | sel col metaKey methMap |      "sort into bins by lowercase selector. "      metaKey := mDef classIsMeta.      methMap := map        at: metaKey        ifAbsent: [ map at: metaKey put: Dictionary new ].      sel := mDef selector asLowercase.      col := methMap        at: sel        ifAbsent: [ methMap at: sel put: OrderedCollection new ].      col add: mDef ].  filenameMetaMap := Dictionary new.  map    keysAndValuesDo: [ :metaKey :methMap |       | filenameMap |      filenameMap := filenameMetaMap        at: metaKey        ifAbsent: [ filenameMetaMap at: metaKey put: Dictionary new ].      methMap values        do: [ :col |           | selector sortedCol |          col size = 1            ifTrue: [               | def |              "no need to distinguish filename"              def := col at: 1.              filenameMap                at: def selector                put: (self fileNameForSelector: def selector) ]            ifFalse: [               "tack on postfix to guarantee  file names are uniique on case insensitive file systems"              sortedCol := col sorted: [ :a :b | a name <= b name ].              1 to: sortedCol size do: [ :index |                 | def filename |                def := sortedCol at: index.                filename := self fileNameForSelector: def selector.                filename := filename , '..' , index printString.                filenameMap at: def selector put: filename ] ] ] ].  ^ filenameMetaMap! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: 'dkh 07/07/2013 22:15'!propertyFileExtension  ^ self repository propertyFileExtension! !!MCFileTreeStCypressWriter methodsFor: 'private' stamp: 'dkh 4/4/2012 14:01'!setFileStream: aStream    super setFileStream: aStream.    fileStream := aStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 03/22/2013 11:30'!writeClassComment: definition    fileStream nextPutAll: definition comment withUnixLineEndings! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 03/22/2013 13:51'!writeClassDefinition: definition    | properties |    properties := Dictionary new.    properties at: 'name' put: definition className.    properties at: 'super' put: definition superclassName.    definition traitCompositionString        ifNotNil: [ :property |             "Issue #48: https://github.com/dalehenrich/filetree/issues/48"            property ~= '{}'                ifTrue: [ properties at: 'traitcomposition' put: property ] ].    definition classTraitCompositionString        ifNotNil: [ :property |             "Issue #48: https://github.com/dalehenrich/filetree/issues/48"            property ~= '{}'                ifTrue: [ properties at: 'classtraitcomposition' put: property ] ].    properties at: 'category' put: definition category.    properties at: 'instvars' put: definition instVarNames asArray.    properties at: 'classvars' put: definition classVarNames asArray.    properties at: 'pools' put: definition poolDictionaries asArray.    properties at: 'classinstvars' put: definition classInstVarNames asArray.    properties at: 'type' put: definition type asString.    properties at: 'commentStamp' put: definition commentStamp.    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/07/2013 22:13'!writeClassDefinition: definition to: classPath  self    writeInDirectoryName: classPath    fileName: 'README'    extension: '.md'    visit: [ self writeClassComment: definition ].  self    writeInDirectoryName: classPath    fileName: 'properties'    extension: self propertyFileExtension    visit: [ self writeClassDefinition: definition ].  self    writeInDirectoryName: classPath    fileName: 'methodProperties'    extension: self propertyFileExtension    visit: [       self        writeMethodProperties:          (self methodDefinitions at: definition className ifAbsent: [ #() ]) ]! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: '08/08/2013 16:08'!writeDefinitions: aCollection  | classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |  self writeBasicDefinitions: aCollection.  extensionClasses := OrderedCollection new.  extensionMethodDefinitions := OrderedCollection new.  methodHolders := self classDefinitions, self traitDefinitions.  self methodDefinitions    keysAndValuesDo: [ :className :extensionMethods |       methodHolders        at: className        ifAbsent: [           extensionClasses add: className.          extensionMethodDefinitions addAll: extensionMethods ] ].  extensionClasses    do: [ :className | self methodDefinitions removeKey: className ].    self writeMethodHolderDefinitions: self traitDefinitions extension: '.trait' to: '' do: [ :definition :classPath |	self writeTraitDefinition: definition to: classPath. ].  self    writeMethodHolderDefinitions: self classDefinitions    extension: '.class'    to: ''    do: [ :definition :classPath | self writeClassDefinition: definition to: classPath ].  classDirExtension := '.extension'.  extensionMethodMap := Dictionary new.  extensionMethodDefinitions    do: [ :methodDefinition |       | classPath methodPath |      (extensionMethodMap        at: methodDefinition className        ifAbsent: [ extensionMethodMap at: methodDefinition className put: OrderedCollection new ])        add: methodDefinition.      classPath := methodDefinition className , classDirExtension        , self fileUtils pathNameDelimiter asString.      self writeExtensionClassDefinition: methodDefinition to: classPath ].  extensionMethodMap    keysAndValuesDo: [ :className :classMethodDefinitions |       | classPath filenameMetaMap |      filenameMetaMap := self fileNameMapFor: classMethodDefinitions.      classMethodDefinitions        do: [ :methodDefinition |           | filename methodPath |          filename := (filenameMetaMap at: methodDefinition classIsMeta)            at: methodDefinition selector.          classPath := methodDefinition className , classDirExtension            , self fileUtils pathNameDelimiter asString.          methodPath := classPath            ,              (methodDefinition classIsMeta                ifTrue: [ 'class' ]                ifFalse: [ 'instance' ])            , self fileUtils pathNameDelimiter asString.          self            writeMethodDefinition: methodDefinition            to: methodPath            filename: filename ].      classPath := className , classDirExtension        , self fileUtils pathNameDelimiter asString.      self        writeInDirectoryName: classPath        fileName: 'methodProperties'        extension: self propertyFileExtension        visit: [ self writeMethodProperties: classMethodDefinitions ] ]! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 4/4/2012 17:52'!writeExtensionClassDefinition: definition    | properties |    properties := Dictionary new.    properties at: 'name' put: definition className.    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/07/2013 22:14'!writeExtensionClassDefinition: definition to: classPath  self    writeInDirectoryName: classPath    fileName: 'properties'    extension: self propertyFileExtension    visit: [ self writeExtensionClassDefinition: definition ]! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 03/22/2013 11:30'!writeMethodDefinition: definition    fileStream        nextPutAll: definition category;        lf;        nextPutAll: definition source withUnixLineEndings! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/18/2013 17:01'!writeMethodDefinition: methodDefinition to: methodPath  self shouldNotImplement! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/18/2013 16:34'!writeMethodDefinition: methodDefinition to: methodPath filename: filename  self    writeInDirectoryName: methodPath    fileName: filename    extension: '.st'    visit: [ self writeMethodDefinition: methodDefinition ]! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: 'dkh 6/12/2012 17:33:23'!writeMethodProperties: classMethodDefinitions    "Issue 33: https://github.com/dalehenrich/filetree/issues/33"    | properties classMethodsMap instanceMethodMap |    properties := Dictionary new.    properties at: 'class' put: (classMethodsMap := Dictionary new).    properties at: 'instance' put: (instanceMethodMap := Dictionary new).    classMethodDefinitions        do: [ :methodDefinition |             (methodDefinition classIsMeta                ifTrue: [ classMethodsMap ]                ifFalse: [ instanceMethodMap ]) at: methodDefinition selector asString put: methodDefinition timeStamp ].    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: 'dkh 07/07/2013 22:14'!writePropertiesFile  | properties |  properties := Dictionary new.  properties at: 'noMethodMetaData' put: true.  properties at: 'separateMethodMetaAndSource' put: false.  properties at: 'useCypressPropertiesFile' put: true.  self    writeInDirectoryName: '.'    fileName: ''    extension: '.filetree'    visit: [ properties writeCypressJsonOn: fileStream ].  self    writeInDirectoryName: '.'    fileName: 'properties'    extension: self propertyFileExtension    visit: [ Dictionary new writeCypressJsonOn: fileStream ]! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 14:54'!writeTraitDefinition: definition    | properties compositionString |    properties := Dictionary new.    properties at: 'name' put: definition className.    definition traitCompositionString        ifNotNil: [ :property |             property ~= '{}'                ifTrue: [ properties at: 'traitcomposition' put: property ] ].    " handle the classTrait case "    compositionString := self classTraitDefinitions at: definition className ifPresent: [:classTraitDefinition |	classTraitDefinition classTraitCompositionString ].    compositionString ifNil: [ compositionString := definition classTraitCompositionString ].    compositionString~= '{}'                ifTrue: [ properties at: 'classtraitcomposition' put: compositionString ] .    properties at: 'category' put: definition category.    properties at: 'commentStamp' put: definition commentStamp.    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 14:47'!writeTraitDefinition: definition to: classPath  self    writeInDirectoryName: classPath    fileName: 'README'    extension: '.md'    visit: [ self writeClassComment: definition ].  self    writeInDirectoryName: classPath    fileName: 'properties'    extension: self propertyFileExtension    visit: [ self writeTraitDefinition: definition ].  self    writeInDirectoryName: classPath    fileName: 'methodProperties'    extension: self propertyFileExtension    visit: [       self        writeMethodProperties:          (self methodDefinitions at: definition className ifAbsent: [ #() ]) ]! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!classDefinitions    classDefinitions ifNil: [ classDefinitions := Dictionary new ].    ^ classDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 08/08/2013 19:02:56'!classTraitDefinitions    classTraitDefinitions ifNil: [ classTraitDefinitions := Dictionary new ].    ^ classTraitDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!methodDefinitions    methodDefinitions ifNil: [ methodDefinitions := Dictionary new ].    ^ methodDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 08/08/2013 19:02:56'!traitDefinitions    traitDefinitions ifNil: [ traitDefinitions := Dictionary new ].    ^ traitDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitClassDefinition: definition    orderedClassNames add: definition className.    self classDefinitions at: definition className put: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 08/08/2013 19:02:56'!visitClassTraitDefinition: definition    orderedTraitNames add: definition className, ' classTrait'.    self classTraitDefinitions at: definition className put: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitMethodDefinition: definition    (self methodDefinitions        at: definition className        ifAbsent: [ self methodDefinitions at: definition className put: OrderedCollection new ]) add: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 08/08/2013 19:02:56'!visitTraitDefinition: definition    orderedTraitNames add: definition className.    self traitDefinitions at: definition className put: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!writeClassDefinition: definition to: classPath    self        writeInDirectoryName: classPath        fileName: definition className        extension: '.st'        visit: [ self writeClassDefinition: definition ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 08/08/2013 19:02:56'!writeClassTraitDefinition: definition to: traitPath    self        writeInDirectoryName: traitPath        fileName: definition className, '_classTrait'        extension: '.st'        visit: [ self writeClassTraitDefinition: definition ]! !!MCFileTreeStSnapshotWriter methodsFor: 'initialize-release' stamp: 'dkh 08/08/2013 18:34'!writeDefinitions: aCollection  | basePath extensionClasses extensionMethodDefinitions methodHolders |  self writeBasicDefinitions: aCollection.  basePath := 'snapshot' , self fileUtils pathNameDelimiter asString , 'classes'    , self fileUtils pathNameDelimiter asString.  extensionClasses := OrderedCollection new.  extensionMethodDefinitions := OrderedCollection new.  methodHolders := self classDefinitions, self traitDefinitions..  self methodDefinitions    keysAndValuesDo: [ :className :extensionMethods |       methodHolders        at: className        ifAbsent: [           extensionClasses add: className.          extensionMethodDefinitions addAll: extensionMethods ] ].  extensionClasses    do: [ :className | self methodDefinitions removeKey: className ].    self writeMethodHolderDefinitions: self traitDefinitions extension: '.trait' to: basePath do: [ :definition :classPath |	self writeTraitDefinition: definition to: classPath.	self classTraitDefinitions at: definition className ifPresent: [:classTraitDefinition |		self writeClassTraitDefinition: classTraitDefinition to: classPath ] ].  self    writeMethodHolderDefinitions: self classDefinitions    extension: '.class'    to: basePath    do: [ :definition :classPath | self writeClassDefinition: definition to: classPath ].  basePath := 'snapshot' , self fileUtils pathNameDelimiter asString    , 'extensions' , self fileUtils pathNameDelimiter asString.  extensionMethodDefinitions    do: [ :methodDefinition |       | methodPath |      methodPath := basePath , methodDefinition className , '.class'        , self fileUtils pathNameDelimiter asString        ,          (methodDefinition classIsMeta            ifTrue: [ 'class' ]            ifFalse: [ 'instance' ])        , self fileUtils pathNameDelimiter asString.      self writeMethodDefinition: methodDefinition to: methodPath ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!writeMethodDefinition: methodDefinition to: methodPath    | filename |    filename := self fileNameForSelector: methodDefinition selector.    self        writeInDirectoryName: methodPath        fileName: filename        extension: '.st'        visit: [ self writeMethodDefinition: methodDefinition ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: '08/08/2013 15:40'!writeMethodHolderDefinitions: aCollection extension: extension to: basePath do: aBlock  aCollection    keysAndValuesDo: [ :className :definition |       | classPath instanceMethodPath classMethodPath filenameMetaMap theMethodDefinitions |      classPath := basePath , definition className , extension        , self fileUtils pathNameDelimiter asString.      aBlock value: definition value: classPath.      instanceMethodPath := classPath , 'instance'        , self fileUtils pathNameDelimiter asString.      classMethodPath := classPath , 'class'        , self fileUtils pathNameDelimiter asString.      theMethodDefinitions := self methodDefinitions        at: className        ifAbsent: [ #() ].      filenameMetaMap := self fileNameMapFor: theMethodDefinitions.      theMethodDefinitions        do: [ :methodDefinition |           | filename |          filename := (filenameMetaMap at: methodDefinition classIsMeta)            at: methodDefinition selector.          methodDefinition classIsMeta            ifTrue: [               self                writeMethodDefinition: methodDefinition                to: classMethodPath                filename: filename ]            ifFalse: [               self                writeMethodDefinition: methodDefinition                to: instanceMethodPath                filename: filename ] ] ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 08/08/2013 19:02:56'!writeTraitDefinition: definition to: traitPath    self        writeInDirectoryName: traitPath        fileName: definition className        extension: '.st'        visit: [ self writeTraitDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'dkh 2/29/2012 14:52'!visitClassDefinition: definition    orderedClassNames add: definition className.    self        writeInDirectoryName: definition className        fileName: definition className        extension: '.st'        visit: [ self writeClassDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 13:36'!visitClassTraitDefinition: definition    orderedTraitNames add: definition className, ' classTrait'.    self        writeInDirectoryName: definition className        fileName: definition className, '_classTrait'        extension: '.st'        visit: [ self writeClassTraitDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'dkh 2/29/2012 14:55'!visitMethodDefinition: definition    | filename directoryname |    directoryname := definition classIsMeta        ifTrue: [ definition className , '_class' ]        ifFalse: [ definition className ].    filename := self fileNameForSelector: definition selector.    self        writeInDirectoryName: directoryname        fileName: filename        extension: '.st'        visit: [ self writeMethodDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 01:12'!visitTraitDefinition: definition    orderedTraitNames add: definition className.    self        writeInDirectoryName: definition className        fileName: definition className        extension: '.st'        visit: [ self writeTraitDefinition: definition ]! !!Boolean methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!Boolean methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeBoolean: self! !!Boolean methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream nextPutAll: self printString! !!Collection class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"For collections we chose to instanciate based a list of elements using #add:	This is not the best or most correct solution for all subclasses though,	so some will revert to standard object behavior or chose another solution."		| collection |	collection := self new.	stonReader parseListDo: [ :each |		collection add: each ].	^ collection! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:45'!addToMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each addToMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/7/2012 13:10'!asMetacelloAttributeList    ^ self! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/8/2012 05:30'!asMetacelloAttributePath    ^ MetacelloMethodSectionPath withAll: self! !!Collection methodsFor: '*metacello-core-scripting' stamp: 'dkh 9/5/2012 06:26:03.064'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeCollection: self do: projectSpecBlock! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: self.! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:46'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each mergeIntoMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: self.! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:42'!removeFromMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each removeFromMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock    ^ aMetacelloMCVersion        allPackagesForSpecs: (self collect: [ :ea | aMetacelloMCVersion packageNamed: ea ifAbsent: aBlock ])        visited: visited! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064'!setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: self do: aBlock! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064'!setForVersion: aString withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: self version: aString! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 11/17/2013 17:19'!setImportInVersionSpec: aMetacelloVersionSpec  aMetacelloVersionSpec setImport: self asArray! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/23/2009 08:46'!setIncludesInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setIncludes: self asArray.! !!Collection methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 15:04:55'!setLoadsInMetacelloProject: aMetacelloPackageSpec	aMetacelloPackageSpec setLoads: self asArray.! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 10:08'!setRequiresInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setRequires: self asArray.! !!Collection methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"For collections we chose to write a list of elements as delivered by #do:	This is not the best or most correct solution for all subclasses though,	so some will revert to standard object behavior or chose another solution"		stonWriter writeObject: self do: [		stonWriter encodeList: self ]! !!MCHttpRepository methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!asRepositorySpecFor: aMetacelloMCProject	^(aMetacelloMCProject repositorySpec)		description:  self description;	 	type: 'http';		yourself! !!MCHttpRepository methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 14:28'!username: aString	"For compatibility with MetacelloRepositorySpec"	^ self user: aString! !!Interval class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		^ self new		fromSton: stonReader;		yourself! !!Interval methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		stonReader parseNamedInstVarsFor: self! !!Interval methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Overwritten to get back the standard object behavior"	stonWriter writeObject: self! !!MCFileTreePackageStructureStWriter class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 10:37'!useCypressWriter    "MCFileTreeRepository defaultPackageExtension:'.package'"    "MCFileTreeRepository defaultPackageExtension:'.pkg'"    ^ true! !!MCFileTreePackageStructureStWriter class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 10:30'!useSnapShotWriter    ^ MCFileTreeRepository defaultPackageExtension = '.pkg'! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:46'!absentInitializers	^ initializers reject: [ :each | Smalltalk hasClassNamed: each key ]! !!MCFileTreePackageStructureStWriter methodsFor: 'visiting' stamp: 'dkh 2/29/2012 13:46'!acceptVisitor: aVisitor forDefinitions: aCollection	(MCDependencySorter sortItems: aCollection)		do: [ :ea | ea accept: aVisitor ]		displayingProgress: 'Writing definitions...'! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:45'!initializers: aCollection	initializers := aCollection! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:46'!presentInitializers	^ initializers select: [ :each | Smalltalk hasClassNamed: each key ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 13:45'!writeAbsentInitializers	(self absentInitializers asSortedCollection: [ :a :b | a key <= b key ])		do: [ :association | stream nextPutAll: association value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 14:48'!writeClassDefinition: definition    self chunkContents: [ :s | definition printDefinitionOn: s ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 13:42'!writeDefinitions: aCollection	"the correct initialization order is unknown if some classes are missing in the image"	initializers := Set new.	self		acceptVisitor: self forDefinitions: aCollection;		writePresentInitializers;		writeAbsentInitializers! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 6/12/2012 17:33:23'!writeMethodInitializer: aMethodDefinition	| initializationStream |		aMethodDefinition isInitializer 		ifTrue: [			initializationStream := String new writeStream.						initializationStream nextChunkPut: aMethodDefinition className, ' initialize'; cr.			initializers add: (aMethodDefinition className->initializationStream)].! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/16/2012 14:49:00'!writeMethodPreamble: definition    stream        cr;        nextPut: $!!;        nextPutAll: definition fullClassName;        nextPutAll: ' methodsFor: ';        nextPutAll: definition category asString printString;        nextPutAll: '!!';        cr! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 13:45'!writePresentInitializers	| orderedClasses presentInitializers |	presentInitializers := self presentInitializers.	orderedClasses := (ChangeSet		superclassOrder: (presentInitializers collect: [ :each | Smalltalk classNamed: each key ]))		collect: [ :each | each name ].	orderedClasses		do: [ :className | stream nextPutAll: (presentInitializers detect: [ :each | each key = className ]) value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 3/1/2012 14:21'!writeProperties    stream        nextPut: ${;        cr;        nextPutAll: '    "noMethodMetaData" : true,';        cr;        nextPutAll: '    "separateMethodMetaAndSource" : false';        cr;        nextPut: $};        cr! !!SystemOrganizer methodsFor: '*Gofer-Core-Accessing' stamp: 'dkh 4/18/2011 13:41' prior: 97180543!environment	^Smalltalk! !!SystemOrganizer methodsFor: '*Gofer-Core-Accessing' stamp: 'sd 9/12/2010 19:12'!goferClassesInCategory: category	^ (self listAtCategoryNamed: category) collect: [ :className | self environment at: className ]! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 18:06'!asMetacelloSemanticVersionNumber    ^ MetacelloSemanticVersionNumber fromString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: self! !!String methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!cypressEscape    ^ self encodeForHTTP! !!String methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!cypressUnescape    ^ self unescapePercents! !!String methodsFor: '*metacello-core-scripting' stamp: 'dkh 7/16/2012 10:51'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeString: self do: projectSpecBlock! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/5/2012 19:01:24'!metacelloIntegerLessThanSelf: anInteger	"integer version components are always '>' string component"	^false! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticIntegerLessThanSelf: anInteger    "integer version components are always '>' string component"    ^ true! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/21/2012 20:43'!metacelloSemanticStringLessThanSelf: aString    ^ aString < self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/21/2012 20:43'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ aMetacelloVersonComponent metacelloSemanticStringLessThanSelf: self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/5/2012 19:01:24'!metacelloStringLessThanSelf: aString	^aString < self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/5/2012 19:01:24'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloStringLessThanSelf: self! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock    ^ aMetacelloMCVersion        allPackagesForSpecs: {(aMetacelloMCVersion packageNamed: self ifAbsent: aBlock)}        visited: visited! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 11/17/2013 17:19'!setImportInVersionSpec: aMetacelloVersionSpec  aMetacelloVersionSpec setImport: {self}! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setIncludesInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setIncludes: { self }.! !!String methodsFor: '*metacello-mc' stamp: 'ct 11/7/2020 15:04:55'!setLoadsInMetacelloProject: aMetacelloPackageSpec	aMetacelloPackageSpec setLoads: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec    self asSymbol setPostLoadDoItInMetacelloSpec: aMetacelloSpec! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec    self asSymbol setPreLoadDoItInMetacelloSpec: aMetacelloSpec! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setRequiresInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setRequires: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects 	^ false! !!String methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeString: self! !!String methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream        nextPutAll: '"';        nextPutAll:                (forHtml                        ifTrue: [ self cypressEscape ]                        ifFalse: [ self ]);        nextPutAll: '"'! !!BaselineOf class methodsFor: 'accessing' stamp: 'dkh 10/11/2014 15:43'!validate  "Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."  "self validate"  <apiDocumentation>  self ensureMetacello.  ^ ((Smalltalk at: #'MetacelloToolBox')    validateBaseline: self    debug: #()    recurse: false) explore! !!BaselineOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!projectClass    ^ MetacelloMCBaselineProject! !!BaselineOf methodsFor: 'accessing' stamp: 'dkh 6/22/2012 12:09'!versionNumberClass    ^ MetacelloVersionNumber! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 05/08/2013 11:39'!bootstrapMetacelloFrom: repositoryUrl  "Corresponds to version 1.0.0-beta.32.6"  "KEEP MetacelloConfigTemplate class>>ensureMetacelloBaseConfiguration in synch!!"  | platformPkg |  self ensureGoferVersion: 'Gofer-Core-lr.115' repositoryUrl: repositoryUrl.  #('Metacello-Core-dkh.678' 'Metacello-MC-dkh.674')    do: [ :pkg | self bootstrapPackage: pkg from: repositoryUrl ].  platformPkg := Smalltalk    at: #'SystemVersion'    ifPresent: [ :cl |       | versionString |      versionString := cl current version.      (versionString beginsWith: 'Squeak')        ifTrue: [           (versionString beginsWith: 'Squeak3')            ifTrue: [ 'Metacello-Platform.squeak-dkh.5' ]            ifFalse: [ 'Metacello-Platform.squeak-dkh.22' ] ]        ifFalse: [           (versionString beginsWith: 'Pharo')            ifTrue: [               self bootstrapPackage: 'Metacello-PharoCommonPlatform-dkh.2' from: repositoryUrl.              (versionString beginsWith: 'Pharo2')                ifTrue: [ 'Metacello-Platform.pharo20-dkh.33' ]                ifFalse: [ 'Metacello-Platform.pharo-dkh.34' ] ] ] ].  self bootstrapPackage: platformPkg from: repositoryUrl! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 9/4/2012 17:09'!bootstrapPackage: aString from: aPath    | repository version |    repository := (MCCacheRepository default includesVersionNamed: aString)        ifTrue: [ MCCacheRepository default ]        ifFalse: [ MCHttpRepository location: aPath user: '' password: '' ].    self        retry: [             repository                versionReaderForFileNamed: aString , '.mcz'                do: [ :reader |                     version := reader version.                    version load.                    version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 6/10/2012 22:01'!ensureGoferVersion: goferVersion repositoryUrl: repositoryUrl    "load the p=file goferVersion if Gofer isn't loaded or an earlier version of Gofer is currently loaded"    | goferVersionNumber wc pName |    (Smalltalk at: #'Gofer' ifAbsent: [  ]) == nil        ifTrue: [ ^ self bootstrapPackage: goferVersion from: repositoryUrl ].    goferVersionNumber := (goferVersion copyAfterLast: $.) asNumber.    wc := [ ((Smalltalk at: #'GoferPackageReference') name: 'Gofer') workingCopy ]        on: Error        do: [ :ex | ex return: ((Smalltalk at: #'GoferPackageReference') name: 'Gofer-Core') workingCopy ].    pName := wc ancestry ancestors first name.    (pName copyAfterLast: $.) asNumber <= goferVersionNumber        ifTrue: [ self bootstrapPackage: goferVersion from: repositoryUrl ]! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 6/11/2012 11:05'!ensureMetacello    "Bootstrap Metacello and load the 'botstrap' group"    self ensureMetacello: #('batch')! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 06/28/2013 16:07'!ensureMetacello: loadList  "Bootstrap Metacello, retry using alternate repository, if primary repository is not accessible"  Smalltalk    at: #'MetacelloProject'    ifAbsent: [       | version error gofer |      (Array        with: 'http://smalltalkhub.com/mc/dkh/metacello/main'        with: 'http://seaside.gemtalksystems.com/ss/metacello')        do: [ :repositoryUrl |           "bootstrap Metacello"          [           self bootstrapMetacelloFrom: repositoryUrl.          Smalltalk            at: #'ConfigurationOfMetacello'            ifAbsent: [               self                retry: [                   gofer := (Smalltalk at: #'Gofer') new.                  gofer                    perform: #'url:' with: repositoryUrl;                    perform: #'package:' with: 'ConfigurationOfMetacello';                    perform: #'load' ] ].          version := (Smalltalk at: #'ConfigurationOfMetacello') project            version: #'previewBootstrap'.          version load: loadList.          self            retry: [               gofer := (Smalltalk at: #'Gofer') new.              Smalltalk                at: #'ConfigurationOfMetacelloPreview'                ifAbsent: [                   gofer                    perform: #'url:' with: repositoryUrl;                    perform: #'package:'                      with: 'ConfigurationOfMetacelloPreview';                    perform: #'load' ] ].          version := (Smalltalk at: #'ConfigurationOfMetacelloPreview') project            version: #'stable'.	"load latest from GitHub"          version load: loadList.          ^ self ]            on: Error            do: [ :ex |               error := ex.              Transcript                cr;                show: 'failed ensureMetacello using ';                show: repositoryUrl printString;                show: ' : ';                show: ex description printString;                show: '...retrying'.	"try again"              ex return: nil ] ].	"shouldn't get here unless the load failed ... throw an error"      self        error:          'retry with alternate repository failed: ' , error description printString ]! !!ConfigurationOf class methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!project	^self new project! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 9/4/2012 17:09'!retry: aBlock    self retry: aBlock retryCount: 3! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 9/4/2012 20:50'!retry: aBlock retryCount: retryCount    | count |    count := 1.    [ true ]        whileTrue: [             [             aBlock value.            ^ self ]                on: Error                do: [ :ex |                     count < retryCount                        ifTrue: [                             Transcript                                cr;                                show: 'RETRYING AFTER:';                                cr;                                show: ex description printString.                            (Delay forSeconds: 5) wait ]                        ifFalse: [                             Transcript                                cr;                                show: 'FAILED RETRYING:';                                cr;                                show: ex description printString.                            ex pass ] ].            count := count + 1 ]! !!ConfigurationOf class methodsFor: 'unloading Metacello' stamp: 'dkh 5/31/2012 17:57:13'!unloadMetacello	"Unload the classes that implement Metacello. Metacello is not needed once a project has been loaded, so it can safely be unloaded."	"self unloadMetacello"	<apiDocumentation>	| gofer |	gofer := (Smalltalk at: #Gofer) new.	MCWorkingCopy allManagers do: [:wc |		((wc packageName beginsWith: 'Metacello') or: [ wc packageName beginsWith: 'OB-Metacello' ])			ifTrue: [ gofer package: wc packageName ]].	gofer unload.! !!ConfigurationOf class methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOf methodsFor: 'defaults' stamp: 'dkh 5/31/2012 17:57:13'!bleedingEdge 	"override if different behavior desired.	 Use:		self versionDoesNotExistError: #bleedingEdge	 if #bleedingEdge version is disallowed."	<defaultSymbolicVersion: #bleedingEdge>		^self defaultBleedingEdgeVersion! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!ConfigurationOf methodsFor: 'defaults' stamp: 'dkh 5/31/2012 17:57:13'!defaultBleedingEdgeVersion	| bleedingEdgeVersion |	bleedingEdgeVersion := (self project map values select: [ :version | version blessing == #baseline ])		detectMax: [ :version | version ].	bleedingEdgeVersion ifNil: [ ^#'notDefined' ].	^ bleedingEdgeVersion versionString! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 6/22/2012 14:31'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := self projectClass new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            project versionNumberClass: self versionNumberClass.            project class versionConstructorClass on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!project: aProject	project ifNil: [ self class ensureMetacello ].	project := aProject! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!projectClass    ^ MetacelloMCProject! !!ConfigurationOf methodsFor: 'private' stamp: 'dkh 5/31/2012 17:57:13'!versionDoesNotExistError: versionStringOrSymbol	((Smalltalk at: #MetacelloSymbolicVersionDoesNotExistError) project: self project versionString: versionStringOrSymbol) signal! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 6/22/2012 12:09'!versionNumberClass    ^ MetacelloSemanticVersionNumber! !!Gofer class methodsFor: 'private' stamp: 'lr 1/5/2010 10:45'!gofer	"Create a Gofer instance of Gofer."	^ self new		renggli: 'gofer';		package: 'Gofer-Core';		package: 'Gofer-Tests';		yourself! !!Gofer class methodsFor: 'instance creation' stamp: 'lr 11/6/2009 10:50'!it	^ self new! !!Gofer class methodsFor: 'instance creation' stamp: 'lr 8/20/2009 09:54'!new	^ self basicNew initialize! !!Gofer class methodsFor: 'private' stamp: 'lr 1/12/2010 19:39'!upgrade	"Update Gofer to the latest version using itself."		| working |	[ self gofer load ]		on: Error		do: [ :err | err retry ].	self new unload		unregister: (MCWorkingCopy 			forPackage: (MCPackage named: 'Gofer')).	self gofer recompile; cleanup! !!Gofer methodsFor: 'deprecated' stamp: 'lr 12/14/2009 20:08'!addPackage: aString	self deprecated: 'Instead of #addPackage: simply use #package:'.	self package: aString! !!Gofer methodsFor: 'deprecated' stamp: 'lr 12/14/2009 20:08'!addPackage: aString constraint: aBlock	self deprecated: 'Instead of #addPackage:constraint: simply use #package:constraint:'.	self package: aString constraint: aBlock! !!Gofer methodsFor: 'deprecated' stamp: 'lr 12/14/2009 20:08'!addVersion: aString	self deprecated: 'Instead of #addVersion: simply use #version:'.	self version: aString! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:17'!allResolved	"Answer all sorted references within the configured repositories."		| resolved |	resolved := OrderedCollection new.	self repositories		do: [ :repository | resolved addAll: (self allResolvedIn: repository) ].	^ resolved asSortedCollection asArray! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:17'!allResolvedIn: aRepository	"Answer all sorted references within aRepository. For efficiency cache the references."	^ (resolvedReferencesCache ifNil: [ resolvedReferencesCache := Dictionary new ])		at: aRepository ifAbsentPut: [ self basicReferencesIn: aRepository ]! !!Gofer methodsFor: 'private' stamp: 'lr 12/13/2009 16:28'!basicReferencesIn: aRepository	^ [ aRepository goferReferences asSortedCollection asArray ] 		on: GoferRepositoryError		do: errorBlock! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 2/7/2010 15:11'!blueplane: aString	self url: 'http://squeaksource.blueplane.jp/' , aString! !!Gofer methodsFor: 'operations-ui' stamp: 'lr 12/14/2009 23:51'!browseLocalChanges	"Browse the changes between the base version and the working copy."		^ self execute: GoferBrowseLocalChanges! !!Gofer methodsFor: 'operations-ui' stamp: 'lr 12/14/2009 23:51'!browseRemoteChanges	"Browse the changes between the working copy and the remote changes."		^ self execute: GoferBrowseRemoteChanges! !!Gofer methodsFor: 'operations' stamp: 'lr 10/3/2009 11:31'!cleanup	"Cleans the specified packages."		^ self execute: GoferCleanup! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:08'!commit	"Commit the modified packages."	^ self execute: GoferCommit! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:08'!commit: aString	"Commit the modified packages with the given commit message."	^ self execute: GoferCommit do: [ :operation | operation message: aString ]! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:27'!croquet: aString	self url: 'http://hedgehog.software.umn.edu:8888/' , aString! !!Gofer methodsFor: 'repositories' stamp: 'lr 3/14/2010 21:13'!directory: aDirectoryOrString	"Add a file-system repository at aDirectoryOrString."	| repository |	repository := (aDirectoryOrString isString and: [ aDirectoryOrString endsWith: '*' ])		ifTrue: [ 			((Smalltalk globals				at: #MCSubDirectoryRepository				ifAbsent: [ self error: aDirectoryOrString printString , ' is an unsupported repository type' ]) new)				directory: (FileDirectory on: aDirectoryOrString allButLast);				yourself ]		ifFalse: [ 			(MCDirectoryRepository new)				directory:						(aDirectoryOrString isString								ifTrue: [ FileDirectory on: aDirectoryOrString ]								ifFalse: [ aDirectoryOrString ]);				yourself ].	self repository: repository! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:33'!disablePackageCache	"Disable the use of the package-cache repository."	packageCacheRepository := nil! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:32'!disableRepositoryErrors	"Silently swallow all repository errors."	errorBlock := [ :error | error resume: #() ]! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:33'!enablePackageCache	"Enable the use of the package-cache repository."	packageCacheRepository := MCCacheRepository default! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:32'!enableRepositoryErrors	"Throw an exception when repositories are not available."	errorBlock := [ :error | error pass ]! !!Gofer methodsFor: 'private' stamp: 'lr 10/2/2009 10:11'!execute: anOperationClass	^ self execute: anOperationClass do: nil! !!Gofer methodsFor: 'private' stamp: 'lr 12/13/2009 16:43'!execute: anOperationClass do: aBlock	| operation result |	operation := anOperationClass on: self copy.	aBlock isNil		ifFalse: [ aBlock value: operation ].	^ operation execute! !!Gofer methodsFor: 'operations' stamp: 'lr 12/3/2009 21:06'!fetch	"Download versions from remote repositories into the local cache."	^ self execute: GoferFetch! !!Gofer methodsFor: 'repositories-places' stamp: 'dkh 10/16/2009 10:04'!gemsource: aString	self url: 'http://seaside.gemstone.com/ss/' , aString! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:27'!impara: aString	self url: 'http://source.impara.de/' , aString! !!Gofer methodsFor: 'initialization' stamp: 'lr 12/13/2009 16:33'!initialize	self enablePackageCache; enableRepositoryErrors.	references := OrderedCollection new.	repositories := OrderedCollection new! !!Gofer methodsFor: 'operations' stamp: 'lr 11/30/2009 14:17'!load	"Load the specified packages into the image."		^ self execute: GoferLoad! !!Gofer methodsFor: 'operations' stamp: 'lr 12/14/2009 23:51'!localChanges	"Answer the changes between the base version and the working copy."		^ self execute: GoferLocalChanges! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:06'!merge	"Merge the specified packages into their working copies."		^ self execute: GoferMerge! !!Gofer methodsFor: 'references' stamp: 'lr 4/3/2010 09:56'!package: aString	"Add the package aString to the receiver. aString is a package name as it appears in the Monticello Browser, something like 'Magritte-Seaside'. Gofer will try to resolve this name to an actual version in one of the configured repositories before doing something with the package. Gofer sorts all the versions in all the repositories according to branch name (versions without a branch are preferred), version number, author name and repository priority. The top hit of this sorted list is eventually going to be loaded and used."	references addLast: (GoferPackageReference name: aString)! !!Gofer methodsFor: 'references' stamp: 'lr 4/3/2010 09:56'!package: aString constraint: aOneArgumentBlock	"Add the package aString to the receiver, but constraint the resulting versions further with aOneArgumentBlock. For details on the package, see #package:. The following example defines various constraints: 			aGofer package: 'Magritte-Seaside' constraint: [ :version |			version author = 'lr'				and: [ version branch = 'trial'				and: [ version versionNumber > 120 ] ] ]"	references addLast: (GoferConstraintReference name: aString constraint: aOneArgumentBlock)! !!Gofer methodsFor: 'copying' stamp: 'lr 12/13/2009 16:52'!postCopy	references := references copy.	repositories := repositories copy.	resolvedReferencesCache := nil! !!Gofer methodsFor: 'operations' stamp: 'lr 12/3/2009 21:06'!push	"Upload local versions from local cache into remote repositories."	^ self execute: GoferPush! !!Gofer methodsFor: 'operations' stamp: 'lr 8/20/2009 11:44'!recompile	"Recompile the specified packages."	^ self execute: GoferRecompile! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:18'!references	"Answer the configured references."	^ Array withAll: references! !!Gofer methodsFor: 'operations' stamp: 'lr 12/30/2009 11:27'!reinitialize	"Calls the class side initializers on all package code."		^ self execute: GoferReinitialize! !!Gofer methodsFor: 'operations' stamp: 'lr 12/12/2009 12:49'!remoteChanges	"Display the changes between the working copy and the remote changes."		^ self execute: GoferRemoteChanges! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:25'!renggli: aString	self url: 'http://source.lukas-renggli.ch/' , aString! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:18'!repositories	"Answer the configured monticello repositories."	|  result |	result := OrderedCollection withAll: repositories.	packageCacheRepository isNil		ifFalse: [ result addFirst: packageCacheRepository ].	^ result asArray! !!Gofer methodsFor: 'repositories' stamp: 'lr 1/11/2010 10:34'!repository: aRepository	"Add aRepository to the repository configuration. If there is already a repository defined in the global configuration with that URL take this one instead."		| repository |	repository := MCRepositoryGroup default repositories		detect: [ :each | each = aRepository ]		ifNone: [ aRepository ].	repositories addLast: repository! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:14'!resolved	"Answer the resolved references of the receiver."	^ self references collect: [ :each | each resolveWith: self ]! !!Gofer methodsFor: 'operations' stamp: 'lr 8/20/2009 10:15'!revert	"Revert the specified packages to the currently loaded version."		^ self execute: GoferRevert! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:29'!saltypickle: aString	self url: 'http://squeak.saltypickle.com/' , aString! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:28'!squeakfoundation: aString	self url: 'http://source.squeakfoundation.org/' , aString! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:28'!squeaksource: aString	self url: 'http://www.squeaksource.com/' , aString! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:07'!unload	"Unload the specified packages."		^ self execute: GoferUnload! !!Gofer methodsFor: 'operations' stamp: 'lr 9/18/2009 18:12'!update	"Update the specified packages."		^ self execute: GoferUpdate! !!Gofer methodsFor: 'repositories' stamp: 'lr 12/9/2009 22:17'!url: anUrlString	"Add anUrlString as a repository for the following package operations."	self url: anUrlString username: String new password: String new! !!Gofer methodsFor: 'repositories' stamp: 'lr 3/14/2010 21:13'!url: anUrlString username: aUsernameString password: aPasswordString	"Add anUrlString as a repository for the following package operations."	| repository |	repository := (anUrlString beginsWith: 'ftp://')		ifTrue: [ 			(Smalltalk globals				at: #MCFtpRepository				ifAbsent: [ self error: anUrlString printString , ' is an unsupported repository type' ])				host: ((anUrlString allButFirst: 6) copyUpTo: $/)				directory: ((anUrlString allButFirst: 6) copyAfter: $/)				user: aUsernameString				password: aPasswordString ]		ifFalse: [ MCHttpRepository location: anUrlString user: aUsernameString password: aPasswordString ].	self repository: repository! !!Gofer methodsFor: 'references' stamp: 'lr 4/3/2010 09:52'!version: aString	"Add the version aString to the receiver. aString is a version name as it appears in the Monticello Repository Browser, something like 'Magritte-Seaside-lr.334'. Gofer will try to resolve this name to one of the configured repositories before loading the code."	references addLast: (GoferVersionReference name: aString)! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:26'!wiresong: aString	self url: 'http://source.wiresong.ca/' , aString! !!MetacelloGofer methodsFor: 'private' stamp: 'tobe 5/23/2020 06:14'!basicReferencesIn: aRepository	((aRepository respondsTo: #cacheReferences) not or: [aRepository cacheReferences not])		ifTrue: [^ super basicReferencesIn: aRepository ].	"Use cache for network-based repositories - the contents of repository is cached based on first access 	 and is _not_ updated afterword, so any mcz files added after the initial cache is created won't be seen"	^ MetacelloPlatform current		stackCacheFor: #goferRepository		cacheClass: IdentityDictionary		at: aRepository		doing: [ :cache | 			^ cache at: aRepository put: (super basicReferencesIn: aRepository) ]! !!MetacelloGofer methodsFor: 'operations' stamp: '9/28/2017 08:53:29'!interactiveCommit	^ self execute: MetacelloGoferCommit! !!GoferLoad methodsFor: 'private' stamp: 'lr 12/18/2009 12:56'!addResolved: aResolvedReference	| version reference |	version := aResolvedReference version.	(self versions includes: version)		ifTrue: [ ^ self ].	self versions addLast: version.	version dependencies do: [ :dependency |		self addResolved: (GoferResolvedReference			name: dependency versionInfo name			repository: aResolvedReference repository) ]! !!GoferLoad methodsFor: 'private' stamp: 'lr 9/3/2009 11:00'!defaultModel	^ MCVersionLoader new! !!GoferLoad methodsFor: 'running' stamp: 'dkh 10/12/2009 12:56'!execute	self model goferHasVersions		ifTrue: [ self model load ].	self updateRepositories.	self updateCategories! !!GoferLoad methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 14:49'!initializeOn: aGofer	super initializeOn: aGofer.	aGofer resolved		do: [ :each | self addResolved: each ]		displayingProgress: 'Loading Versions'! !!GoferLoad methodsFor: 'private' stamp: 'lr 12/18/2009 12:55'!updateCategories	"This method makes sure that the categories are ordered in load-order and as specified in the packages."	| categories |	categories := OrderedCollection new.	self versions do: [ :version |		version snapshot definitions do: [ :definition |			definition isOrganizationDefinition ifTrue: [				definition categories do: [ :category |					(categories includes: category)						ifFalse: [ categories addLast: category ] ] ] ] ].	(MCOrganizationDefinition categories: categories)		postloadOver: nil! !!GoferLoad methodsFor: 'private' stamp: 'lr 12/18/2009 12:55'!updateRepositories	"This code makes sure that all packages have a repository assigned, including the dependencies."	self versions do: [ :version |		gofer repositories do: [ :repository | 			version workingCopy repositoryGroup				addRepository: repository ] ]! !!GoferLoad methodsFor: 'accessing' stamp: 'lr 12/18/2009 12:55'!versions	^ model goferVersions! !!MetacelloGoferLoad methodsFor: 'private' stamp: '9/28/2017 08:53:29'!updateCategories	MetacelloPlatform current bypassGoferLoadUpdateCategories		ifFalse: [ super updateCategories ]! !!MetacelloGoferLoad methodsFor: 'private' stamp: '9/28/2017 08:53:29'!updateRepositories	"Noop for Metacello...done by loader itself"! !!GoferOperation class methodsFor: 'instance creation' stamp: 'TestRunner 12/12/2009 11:09'!new	self error: 'Gofer operations can only work on Gofer instances.'! !!GoferOperation class methodsFor: 'instance creation' stamp: 'lr 8/20/2009 12:01'!on: aGofer	^ self basicNew initializeOn: aGofer! !!GoferOperation methodsFor: 'private' stamp: 'lr 8/19/2009 14:01'!defaultModel	^ nil! !!GoferOperation methodsFor: 'running' stamp: 'lr 8/17/2009 14:40'!execute	"Execute the receiving action."	self subclassResponsibility! !!GoferOperation methodsFor: 'accessing' stamp: 'lr 10/3/2009 11:38'!gofer	"Answer the Gofer instance that triggered this operation."	^ gofer! !!GoferOperation methodsFor: 'initialization' stamp: 'lr 8/19/2009 14:01'!initialize	model := self defaultModel! !!GoferOperation methodsFor: 'initialization' stamp: 'TestRunner 12/12/2009 11:09'!initializeOn: aGofer	gofer := aGofer.	self initialize! !!GoferOperation methodsFor: 'accessing' stamp: 'lr 8/20/2009 10:13'!model	"Answer the Monticello model of this operation."		^ model! !!GoferFetch methodsFor: 'private' stamp: 'lr 11/30/2009 13:46'!defaultModel	^ Set new! !!GoferFetch methodsFor: 'running' stamp: 'lr 12/13/2009 17:22'!execute	self model		do: [ :reference | self cacheRepository storeVersion: reference version ]		displayingProgress: 'Fetching Versions'! !!GoferFetch methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 19:56'!initializeOn: aGofer	super initializeOn: aGofer.	self gofer references do: [ :reference |		self gofer allResolved do: [ :resolved |			((reference matches: resolved) and: [ (cacheReferences includes: resolved) not ])				ifTrue: [ self model add: resolved ] ] ]! !!GoferPush methodsFor: 'private' stamp: 'lr 11/30/2009 13:46'!defaultModel	^ OrderedCollection new! !!GoferPush methodsFor: 'running' stamp: 'lr 12/13/2009 17:23'!execute	self model 		do: [ :assocation | assocation value storeVersion: assocation key version ]		displayingProgress: 'Pushing Versions'! !!GoferPush methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 20:08'!initializeOn: aGofer	super initializeOn: aGofer.	self gofer references do: [ :reference |		cacheReferences do: [ :resolved |			(reference matches: resolved) ifTrue: [				self gofer repositories do: [ :repository |					((self gofer allResolvedIn: repository) includes: resolved)						ifFalse: [ self model add: resolved -> repository ] ] ] ] ]! !!GoferSynchronize methodsFor: 'accessing' stamp: 'lr 12/12/2009 14:29'!cacheRepository	^ MCCacheRepository default! !!GoferSynchronize methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 19:54'!initializeOn: aGofer	super initializeOn: aGofer disablePackageCache.	MCFileBasedRepository flushAllCaches.	cacheReferences := self gofer allResolvedIn: self cacheRepository! !!GoferChanges methodsFor: 'private' stamp: 'lr 12/12/2009 12:56'!addReference: aReference	super addReference: aReference.	self model operations 		addAll: (self patchsetOf: aReference) operations! !!GoferChanges methodsFor: 'private' stamp: 'lr 8/19/2009 14:02'!defaultModel	^ MCPatch operations: OrderedCollection new! !!GoferChanges methodsFor: 'running' stamp: 'lr 12/14/2009 23:50'!execute	^ self model! !!GoferChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:06'!patchsetOf: aReference	"Answer the source snapshot of aReference."		| source target |	source := self sourceSnapshotOf: aReference.	target := self targetSnapshotOf: aReference.	^ target patchRelativeToBase: source! !!GoferChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:00'!sourceSnapshotOf: aReference	"Answer the source snapshot of aReference."		self subclassResponsibility! !!GoferChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 12:59'!targetSnapshotOf: aReference	"Answer the source snapshot of aReference."		self subclassResponsibility! !!GoferBrowseLocalChanges methodsFor: 'running' stamp: 'lr 12/14/2009 23:50'!execute	^ super execute browse! !!GoferLocalChanges methodsFor: 'queries' stamp: 'TestRunner 12/13/2009 18:02'!sourceSnapshotOf: aReference	| ancestors reference |	ancestors := aReference workingCopy ancestry ancestors.	ancestors isEmpty ifTrue: [ ^ MCSnapshot new ].	reference := GoferVersionReference name: ancestors first name.	^ (reference resolveWith: self gofer) version snapshot! !!GoferLocalChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:01'!targetSnapshotOf: aReference	^ aReference workingCopy package snapshot! !!GoferBrowseRemoteChanges methodsFor: 'running' stamp: 'lr 12/14/2009 23:50'!execute	^ super execute browse! !!GoferRemoteChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:00'!sourceSnapshotOf: aReference	^ aReference workingCopy package snapshot! !!GoferRemoteChanges methodsFor: 'private' stamp: 'TestRunner 12/13/2009 19:27'!targetSnapshotOf: aReference	^ (aReference resolveWith: self gofer) version snapshot! !!GoferCleanup methodsFor: 'cleaning' stamp: 'lr 10/3/2009 11:37'!cleanup: aWorkingCopy	self cleanupCategories: aWorkingCopy.	self cleanupProtocols: aWorkingCopy! !!GoferCleanup methodsFor: 'cleaning' stamp: 'dkh 10/12/2009 12:59'!cleanupCategories: aWorkingCopy	aWorkingCopy packageInfo systemCategories do: [ :category |		(SystemOrganization goferClassesInCategory: category) isEmpty			ifTrue: [ SystemOrganization removeSystemCategory: category ] ]! !!GoferCleanup methodsFor: 'cleaning' stamp: 'lr 10/3/2009 11:37'!cleanupProtocols: aWorkingCopy	aWorkingCopy packageInfo extensionClasses do: [ :class |		(aWorkingCopy packageInfo extensionCategoriesForClass: class) do: [ :category |			(class organization listAtCategoryNamed: category) isEmpty				ifTrue: [ class organization removeCategory: category ] ] ].	aWorkingCopy packageInfo classesAndMetaClasses do: [ :class |		(aWorkingCopy packageInfo coreCategoriesForClass: class) do: [ :category |			(class organization listAtCategoryNamed: category) isEmpty				ifTrue: [ class organization removeCategory: category ] ] ]! !!GoferCleanup methodsFor: 'running' stamp: 'lr 10/3/2009 11:30'!execute	self workingCopies		do: [ :each | self cleanup: each ]! !!GoferCommit methodsFor: 'running' stamp: 'lr 12/13/2009 18:44'!execute	self workingCopies 		do: [ :each | self execute: each ]! !!GoferCommit methodsFor: 'running' stamp: 'lr 12/27/2009 17:21'!execute: aWorkingCopy	| repositories version |	repositories := self gofer repositories		reject: [ :repository | (aWorkingCopy changesRelativeToRepository: repository) isEmpty ].	repositories isEmpty		ifTrue: [ ^ self ].	version := [ aWorkingCopy newVersion ]		on: MCVersionNameAndMessageRequest		do: [ :notifcation |			self message isNil				ifTrue: [ message := notifcation outer last ].			notifcation resume: (Array with: notifcation suggestedName with: self message) ].	self gofer repositories		do: [ :repository | repository storeVersion: version ]! !!GoferCommit methodsFor: 'running' stamp: 'lr 12/13/2009 19:20'!initializeOn: aGofer	super initializeOn: aGofer disablePackageCache! !!GoferCommit methodsFor: 'accessing' stamp: 'lr 10/2/2009 10:12'!message	^ message! !!GoferCommit methodsFor: 'accessing' stamp: 'lr 10/2/2009 10:12'!message: aString	message := aString! !!MetacelloGoferCommit methodsFor: 'running' stamp: '9/28/2017 08:53:29'!execute: aWorkingCopy	| version |	version := MetacelloPlatform current newVersionForWorkingCopy: aWorkingCopy.	self gofer repositories		do: [ :repository | repository storeVersion: version ]! !!GoferRecompile methodsFor: 'running' stamp: 'lr 12/13/2009 19:12'!execute	self workingCopies		do: [ :each | self execute: each ]! !!GoferRecompile methodsFor: 'running' stamp: 'lr 12/13/2009 19:12'!execute: aWorkingCopy	aWorkingCopy packageInfo methods		do: [ :each | each actualClass recompile: each methodSymbol ]! !!GoferReinitialize methodsFor: 'running' stamp: 'lr 12/30/2009 11:14'!execute	self workingCopies		do: [ :each | self execute: each ]! !!GoferReinitialize methodsFor: 'running' stamp: 'DaleHenrichs 3/5/2010 09:25'!execute: aWorkingCopy	aWorkingCopy packageInfo methods do: [ :each |		(each classIsMeta and: [ each methodSymbol = #initialize ])			ifTrue: [ each actualClass theNonMetaClass initialize ] ]! !!GoferUnload methodsFor: 'private' stamp: 'lr 3/14/2010 21:13'!defaultModel	^ (Smalltalk globals at: #MCMultiPackageLoader ifAbsent: [ MCPackageLoader ]) new! !!GoferUnload methodsFor: 'running' stamp: 'lr 10/3/2009 11:45'!execute	self workingCopies 		do: [ :copy | self unload: copy ].	self model load.	self gofer cleanup.	self workingCopies 		do: [ :copy | self unregister: copy ]! !!GoferUnload methodsFor: 'unloading' stamp: 'lr 10/3/2009 11:46'!unload: aWorkingCopy	self unloadClasses: aWorkingCopy.	self unloadPackage: aWorkingCopy! !!GoferUnload methodsFor: 'unloading' stamp: 'DaleHenrichs 3/5/2010 09:25'!unloadClasses: aWorkingCopy	aWorkingCopy packageInfo methods do: [ :each |		(each classIsMeta and: [ each methodSymbol = #unload ])			ifTrue: [ each actualClass theNonMetaClass unload ] ]! !!GoferUnload methodsFor: 'unloading' stamp: 'lr 8/19/2009 14:00'!unloadPackage: aWorkingCopy	self model unloadPackage: aWorkingCopy package! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/19/2009 13:49'!unregister: aWorkingCopy	self unregisterWorkingCopy: aWorkingCopy.	self unregisterRepositories: aWorkingCopy.	self unregisterPackageInfo: aWorkingCopy! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/19/2009 13:50'!unregisterPackageInfo: aWorkingCopy	PackageOrganizer default		unregisterPackage: aWorkingCopy packageInfo! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/19/2009 13:50'!unregisterRepositories: aWorkingCopy	aWorkingCopy repositoryGroup repositories allButFirst do: [ :repository |		MCWorkingCopy allManagers do: [ :copy |			(copy repositoryGroup includes: repository)				ifTrue: [ ^ self ] ].		MCRepositoryGroup default			removeRepository: repository ]! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/20/2009 11:54'!unregisterWorkingCopy: aWorkingCopy	aWorkingCopy unregister! !!GoferMerge methodsFor: 'private' stamp: 'lr 8/19/2009 14:01'!defaultModel	^ MCVersionMerger new! !!GoferMerge methodsFor: 'running' stamp: 'lr 10/3/2009 11:39'!execute	[ [ self model merge ]		on: MCMergeResolutionRequest		do: [ :request |			request merger conflicts isEmpty				ifTrue: [ request resume: true ]				ifFalse: [ request pass ] ] ]		valueSupplyingAnswers: #(('No Changes' true)).	self gofer cleanup! !!GoferRevert methodsFor: 'running' stamp: 'lr 9/19/2009 13:15'!execute	self workingCopies		do: [ :each | each modified: false ].	super execute! !!GoferRevert methodsFor: 'private' stamp: 'TestRunner 12/13/2009 18:09'!referenceFor: aReference	| ancestors reference |	ancestors := aReference workingCopy ancestry ancestors.	ancestors isEmpty ifTrue: [ ^ MCSnapshot new ].	^ GoferVersionReference name: ancestors first name! !!GoferUpdate methodsFor: 'private' stamp: 'TestRunner 12/13/2009 18:09'!addReference: aReference	super addReference: aReference.	self model addVersion: ((self referenceFor: aReference)		 resolveWith: self gofer) version! !!GoferUpdate methodsFor: 'private' stamp: 'lr 9/18/2009 18:13'!defaultModel	^ MCVersionLoader new! !!GoferUpdate methodsFor: 'running' stamp: 'dkh 10/12/2009 12:55'!execute	self model goferHasVersions		ifTrue: [ self model load ].	self gofer cleanup! !!GoferUpdate methodsFor: 'private' stamp: 'TestRunner 12/13/2009 18:08'!referenceFor: aReference	^ aReference! !!GoferWorking methodsFor: 'private' stamp: 'lr 12/18/2009 20:56'!addReference: aReference	| workingCopy |	workingCopy := aReference workingCopy.	(self workingCopies includes: workingCopy)		ifTrue: [ ^ self ].	self workingCopies addLast: workingCopy.	workingCopy requiredPackages do: [ :package |		self addReference: (GoferPackageReference			name: package name) ]! !!GoferWorking methodsFor: 'initialization' stamp: 'lr 8/19/2009 13:14'!initialize	super initialize.	workingCopies := OrderedCollection new! !!GoferWorking methodsFor: 'initialization' stamp: 'lr 12/13/2009 19:16'!initializeOn: aGofer	super initializeOn: aGofer.	aGofer references 		do: [ :each | self addReference: each ]! !!GoferWorking methodsFor: 'accessing' stamp: 'lr 9/24/2009 16:55'!workingCopies	"Answer the working copies to be operated on."	^ workingCopies! !!GoferConstraintReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:44'!name: aString constraint: aBlock	^ self basicNew initializeName: aString constraint: aBlock! !!GoferConstraintReference methodsFor: 'initialization' stamp: 'TestRunner 12/12/2009 00:18'!initializeName: aString constraint: aBlock	self initializeName: aString.	constraintBlock := aBlock! !!GoferConstraintReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:17'!matches: aResolvedReference	^ (super matches: aResolvedReference) and: [ constraintBlock value: aResolvedReference ]! !!GoferPackageReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:16'!matches: aResolvedReference	^ self packageName = aResolvedReference packageName! !!GoferPackageReference methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!metacelloPackageNameWithBranch    "answer array with package name and package name with branch name .. no branch name"    ^ {(self packageName).    (self packageName)}! !!GoferPackageReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:12'!packageName	^ name! !!MetacelloGoferPackage class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!name: aString packageFilename: packageFilename	^ self basicNew initializeName: aString packageFilename: packageFilename! !!MetacelloGoferPackage class methodsFor: 'package name matching' stamp: '9/28/2017 08:53:29'!packageFileName: pkgFileName matchesPackageName: wcPkgName  ^ (pkgFileName beginsWith: wcPkgName)    ifTrue: [       pkgFileName size = wcPkgName size        or: [           (pkgFileName at: wcPkgName size + 1) = $-            or: [               (pkgFileName at: wcPkgName size + 1) = $.                or: [ (pkgFileName at: wcPkgName size + 1) isDigit ] ] ] ]    ifFalse: [       pkgFileName size >= wcPkgName size        ifTrue: [ ^ false ].      (wcPkgName beginsWith: pkgFileName)        ifFalse: [ ^ false ].      ^ (wcPkgName at: pkgFileName size + 1) = $. ]! !!MetacelloGoferPackage methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!ancestors	| wc |	(wc := self workingCopy) ~~ nil		ifTrue: [ 			wc ancestry ancestors isEmpty not				ifTrue: [ ^wc ancestry ancestors ]].	^nil! !!MetacelloGoferPackage methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!currentVersionInfo	| wc |	(wc := self workingCopy) ~~ nil		ifTrue: [ 			wc ancestry ancestors isEmpty not				ifTrue: [ ^wc ancestry ancestors first ]].	^nil! !!MetacelloGoferPackage methodsFor: 'private' stamp: '9/28/2017 08:53:29'!findWorkingCopy	"Answer a working copy, or nil if the package is not loaded."	| wcs |	wcs := MCWorkingCopy allManagers select: [ :each | self matchesWorkingCopy: each ].	wcs isEmpty ifTrue: [ ^nil ].	^wcs detectMax: [:ea | ea package name size ]! !!MetacelloGoferPackage methodsFor: 'initialization' stamp: '9/28/2017 08:53:29'!initializeName: aString packageFilename: packagefilename	name := aString.	packageFilename := packagefilename! !!MetacelloGoferPackage methodsFor: 'private' stamp: '9/28/2017 08:53:29'!matches: aLoadableReference  | pFilename |  ((pFilename := self packageFilename) == nil    or: [ self name = self packageFilename ])    ifTrue: [ ^ super matches: aLoadableReference ].  aLoadableReference name = pFilename    ifTrue: [ ^ true ].  (aLoadableReference name beginsWith: pFilename)    ifFalse: [ ^ false ].  ^ aLoadableReference matchesMetacelloGoferPackage: self! !!MetacelloGoferPackage methodsFor: 'private' stamp: '9/28/2017 08:53:29'!matchesMetacelloGoferPackage: aMetacelloGoferPackage  self    error:      'Should not be matching a MetacelloGoferPackage with another MetacelloGoferPackage'! !!MetacelloGoferPackage methodsFor: 'private' stamp: '9/28/2017 08:53:29'!matchesWorkingCopy: aWorkingCopy	"check that the working copy package name matches the package file name and that the first ancestor's package file name	 matches the packageName"		| pFilename |	(pFilename := self packageFilename) == nil ifTrue: [ ^self error: 'cannot match working copy' ].	(self class 		packageFileName: pFilename 		matchesPackageName: aWorkingCopy package name)			ifTrue: [				aWorkingCopy ancestry ancestors isEmpty ifTrue: [ ^true ].				^self class 					packageFileName: aWorkingCopy ancestry ancestors first name 					matchesPackageName: self packageName ].	^false! !!MetacelloGoferPackage methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packageFilename	^packageFilename! !!MetacelloGoferPackage methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!workingCopy		workingCopy == nil ifTrue: [ workingCopy := self findWorkingCopy ].	^workingCopy! !!GoferReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:42'!name: aString	^ self basicNew initializeName: aString! !!GoferReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:42'!new	self error: 'Use #name: to initialize the receiver.'! !!GoferReference methodsFor: 'comparing' stamp: 'lr 12/12/2009 13:33'!= aReference	^ self class = aReference class and: [ self name = aReference name ]! !!GoferReference methodsFor: 'comparing' stamp: 'lr 12/12/2009 13:33'!hash	^ self name hash! !!GoferReference methodsFor: 'initialization' stamp: 'lr 12/9/2009 22:57'!initializeName: aString	name := aString! !!GoferReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:16'!matches: aResolvedReference	"Answer true if the receiver matches aResolvedReference."	self subclassResponsibility! !!GoferReference methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!matchesMetacelloGoferPackage: aMetacelloGoferPackage  | pFilename refFilename char |  ((pFilename := aMetacelloGoferPackage packageFilename) == nil    or: [ aMetacelloGoferPackage name = aMetacelloGoferPackage packageFilename ])    ifTrue: [ ^ super matches: self ].  self name = pFilename    ifTrue: [ ^ true ].  (self name beginsWith: pFilename)    ifFalse: [ ^ false ].  refFilename := self metacelloPackageNameWithBranch at: 2.  refFilename = pFilename    ifTrue: [ ^ true ].  pFilename size < refFilename size    ifTrue: [       (refFilename beginsWith: pFilename)        ifFalse: [ ^ false ].      (char := pFilename at: pFilename size) ~= $-        ifTrue: [ char := refFilename at: pFilename size + 1 ] ]    ifFalse: [       (pFilename beginsWith: refFilename)        ifFalse: [ ^ false ].      (char := refFilename at: refFilename size) ~= $-        ifTrue: [ char := pFilename at: refFilename size + 1 ] ].  ^ char = $. or: [ char = $- ]! !!GoferReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:02'!name	"Answer the name of this reference."		^ name! !!GoferReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:09'!packageName	"Answer the package name."		self subclassResponsibility! !!GoferReference methodsFor: 'printing' stamp: 'lr 12/11/2009 22:02'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!GoferReference methodsFor: 'querying' stamp: 'lr 12/13/2009 17:20'!resolveAllWith: aGofer	"Answer a sorted collection of all resolved references within aGofer."	^ aGofer allResolved select: [ :each | self matches: each ]! !!GoferReference methodsFor: 'querying' stamp: 'lr 12/13/2009 17:20'!resolveWith: aGofer	"Answer a single resolved reference with aGofer configuration, throw an error if the version can't be found.'"	| references |	references := self resolveAllWith: aGofer.	^ references isEmpty		ifTrue: [ self error: 'Unable to resolve ' , self name ]		ifFalse: [ references last ]! !!GoferReference methodsFor: 'querying' stamp: 'lr 12/13/2009 17:10'!workingCopy	"Answer a working copy or throw an error if not present."	^ MCWorkingCopy allManagers		detect: [ :each | self packageName = each packageName ]		ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]! !!GoferResolvedReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:55'!name: aString repository: aRepository	^ self basicNew initializeName: aString repository: aRepository! !!GoferResolvedReference methodsFor: 'comparing' stamp: 'lr 3/5/2010 07:19'!<= aResolvedReference	"Sort versions according to:		1. package name		2. branch name, list versions without branch last		3. version number		4. author name		5. repository priority"		self packageName = aResolvedReference packageName		ifFalse: [ ^ self packageName <= aResolvedReference packageName ].	self branch = aResolvedReference branch ifFalse: [ 		^ (self branch isEmpty or: [ aResolvedReference branch isEmpty ])			ifTrue: [ self branch size > aResolvedReference branch size ]			ifFalse: [ self branch <= aResolvedReference branch ] ].	self versionNumber = aResolvedReference versionNumber		ifFalse: [ ^ self versionNumber <= aResolvedReference versionNumber ].	self author = aResolvedReference author		ifFalse: [ ^ self author <= aResolvedReference author ].	self repository goferPriority = aResolvedReference repository goferPriority		ifFalse: [ ^ self repository goferPriority <= aResolvedReference repository goferPriority ].	^ true! !!GoferResolvedReference methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!asMetacelloCachingResolvedReference	^MetacelloCachingGoferResolvedReference name: self name repository: self repository! !!GoferResolvedReference methodsFor: 'initialization' stamp: 'lr 12/9/2009 22:55'!initializeName: aString repository: aRepository	self initializeName: aString.	repository := aRepository! !!GoferResolvedReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:33'!repository	"Answer the repository of the receiver."		^ repository! !!GoferResolvedReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:22'!version	"Answer a Monticello version of the receiver."	^ self repository goferVersionFrom: self! !!MetacelloCachingGoferResolvedReference methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!version	"Answer a Monticello version of the receiver."	cachedVersion == nil ifTrue: [ cachedVersion := super version ].	^cachedVersion! !!MetacelloCachingGoferResolvedReference methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!workingCopy	"Answer a working copy or throw an error if not present."	| pName |	cachedVersion == nil ifTrue: [ ^super workingCopy ].	pName := cachedVersion package name.	^MCWorkingCopy allManagers		detect: [ :each | pName = each packageName ]		ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:22'!author	"Answer the author of the receiver."		^ author! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:23'!branch	"Answer the branch of the receiver."		^ branch! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!compare: aLoadableReference using: aComparisonOperator	"Compare versions using <aComparisonOperator>. package names #= then compare based upon version number	Branches and Author names are used in the case of a version number tie, because we need to avoid seesaw loading."			self packageName = aLoadableReference packageName		ifFalse: [ ^false ].	self versionNumber = aLoadableReference versionNumber		ifFalse: [ ^ self versionNumber perform: aComparisonOperator with: aLoadableReference versionNumber ].	self branch = aLoadableReference branch 		ifFalse: [ ^ self branch perform: aComparisonOperator with: aLoadableReference branch ].	^ self author perform: aComparisonOperator with: aLoadableReference author! !!GoferVersionReference methodsFor: 'initialization' stamp: 'lr 12/11/2009 22:17'!initializeName: aString	super initializeName: aString.	self parseName: aString! !!GoferVersionReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:17'!matches: aResolvedReference	^ self name = aResolvedReference name! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!matchesMetacelloGoferPackage: aMetacelloGoferPackage  | ref |  (super matchesMetacelloGoferPackage: aMetacelloGoferPackage)    ifFalse: [ ^ false ].  ref := self class name: aMetacelloGoferPackage packageFilename.  ref versionNumber = 0    ifTrue: [ ^ true ].  ^ self versionNumber = ref versionNumber! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!metacelloPackageNameWithBranch	"answer array with package name and package name with branch name"	self branch isEmpty		ifTrue: [ 			^ {(self packageName).			(self packageName)} ].	^ {(self packageName).	(self packageName , '.' , self branch)}! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:12'!packageName	"Answer the package of the receiver."	^ package! !!GoferVersionReference methodsFor: 'initialization' stamp: 'lr 2/6/2011 18:01'!parseName: aString	| basicName |	basicName := aString last isDigit		ifTrue: [ aString ]		ifFalse: [ (aString copyUpToLast: $.) copyUpTo: $( ].	package := basicName copyUpToLast: $-.	(package includes: $.)		ifFalse: [ branch := '' ]		ifTrue: [			branch := package copyAfter: $..			package := package copyUpTo: $. ].	author := (basicName copyAfterLast: $-) copyUpToLast: $..	versionNumber := (basicName copyAfterLast: $-) copyAfterLast: $..	(versionNumber notEmpty and: [ versionNumber allSatisfy: [ :each | each isDigit ] ])		ifTrue: [ versionNumber := versionNumber asInteger ]		ifFalse: [ versionNumber := 0 ]! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:20'!versionNumber	"Answer the version of the receiver."	^ versionNumber! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 21:25'!default    ^ FileDirectory default! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 22:12'!deleteAll: aDirectory    ^ aDirectory recursiveDelete! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 21:48'!directoryExists: aDirectory    ^ aDirectory exists! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 13:46'!directoryFromEntry: directoryEntry    ^ directoryEntry asFileDirectory! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:12'!directoryFromPath: directoryPath    ^ FileDirectory on: directoryPath! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 05:18'!directoryFromPath: directoryPath relativeTo: aDirectory    ^ aDirectory directoryNamed: directoryPath! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 06:43'!directoryName: aDirectory    ^ aDirectory localName! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:50'!directoryPathString: aDirectory    ^ aDirectory pathName! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 05:22'!ensureDirectoryExists: aDirectory    aDirectory assureExistence! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 05:25'!ensureFilePathExists: fileNameOrPath relativeTo: aDirectory    FileDirectory splitName: fileNameOrPath to: [ :fPath :fname | (aDirectory directoryNamed: fPath) assureExistence ]! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 15:50'!filePathExists: filePath relativeTo: aDirectory    ^ aDirectory fileExists: (aDirectory fullNameFor: filePath)! !!MCFileTreeFileDirectoryUtils class methodsFor: 'initialization' stamp: 'dkh 8/9/2012 08:29'!initialize    "self initialize"    self install! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 09:33'!parentDirectoryOf: aDirectory    ^ aDirectory containingDirectory! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 19:21'!pathNameDelimiter    ^ FileDirectory pathNameDelimiter! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 06:31'!readStreamFor: filePath in: aDirectory do: aBlock    ^ aDirectory readOnlyFileNamed: filePath do: aBlock! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 15:38'!resolvePath: path in: aDirectory    ^ aDirectory directoryNamed: path! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 09:44'!writeStreamFor: filePath in: aDirectory do: aBlock    aDirectory forceNewFileNamed: filePath do: aBlock! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 09:15'!buildPathFrom: pathCollection    ^ String        streamContents: [ :stream | pathCollection do: [ :element | stream nextPutAll: element ] separatedBy: [ stream nextPut: self pathNameDelimiter ] ]! !!MCFileTreeFileUtils class methodsFor: 'accessing' stamp: 'dkh 8/8/2012 22:36'!current    ^ Current! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!default    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!deleteAll: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryExists: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryFromPath: directoryPath    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryFromPath: directoryPath relativeTo: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryName: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryPathString: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!ensureDirectoryExists: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!ensureFilePathExists: fileNameOrPath relativeTo: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!filePathExists: filePath relativeTo: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'initialization' stamp: 'dkh 8/8/2012 22:37'!install    Current := self! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!parentDirectoryOf: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!pathNameDelimiter    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!readStreamFor: filePath in: aDirectory do: aBlock    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!resolvePath: path in: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!writeStreamFor: filePath in: aDirectory do: aBlock    self subclassResponsibility! !!MCFileTreeJsonParser class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:39:25'!new	self error: 'Instantiate the parser with a stream.'! !!MCFileTreeJsonParser class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:39:25'!on: aStream	^ self basicNew initializeOn: aStream! !!MCFileTreeJsonParser class methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:39:25'!parse: aString	^ self parseStream: aString readStream! !!MCFileTreeJsonParser class methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:39:25'!parseStream: aStream	^ (self on: aStream) parse! !!MCFileTreeJsonParser methodsFor: 'adding' stamp: 'dkh 2/16/2012 14:39:25'!addProperty: anAssociation to: anObject	"Add the property anAssociation described with key and value to anObject. Subclasses might want to refine this implementation."		^ anObject 		add: anAssociation;		yourself! !!MCFileTreeJsonParser methodsFor: 'adding' stamp: 'dkh 2/16/2012 14:39:25'!addValue: anObject to: aCollection	"Add anObject to aCollection. Subclasses might want to refine this implementation."	^ aCollection copyWith: anObject! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createArray	"Create an empty collection. Subclasses might want to refine this implementation."	^ Array new! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createFalse	"Create the false literal. Subclasses might want to refine this implementation."		^ false! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createNull	"Create the null literal. Subclasses might want to refine this implementation."	^ nil! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createNumber: aString	"Create a number literal. Subclasses might want to refine this implementation."	^ aString asNumber! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createObject	"Create an empty object. Subclasses might want to refine this implementation."		^ Dictionary new! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createProperty: aKey with: aValue	"Create an empty attribute value pair. Subclasses might want to refine this implementation."		^ aKey -> aValue! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createString: aString	"Create a string literal. Subclasses might want to refine this implementation."	^ aString! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createTrue	"Create the true literal. Subclasses might want to refine this implementation."	^ true! !!MCFileTreeJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!expect: aString	"Expects aString and consume input, throw an error otherwise."	^ (self match: aString) ifFalse: [ self error: aString , ' expected' ]! !!MCFileTreeJsonParser methodsFor: 'initialization' stamp: 'dkh 2/16/2012 14:39:25'!initializeOn: aStream	self initialize.	stream := aStream! !!MCFileTreeJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!match: aString	"Tries to match aString, consume input and answer true if successful."		| position |	position := stream position.	aString do: [ :each |		(stream atEnd or: [ stream next ~= each ]) ifTrue: [ 			stream position: position.			^ false ] ].	self whitespace.	^ true! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parse	| result |	result := self whitespace; parseValue.	stream atEnd		ifFalse: [ self error: 'end of input expected' ].	^ result! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parseArray	| result |	self expect: '['.	result := self createArray.	(self match: ']')		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addValue: self parseValue			to: result.		(self match: ']') 			ifTrue: [ ^ result ].		self expect: ',' ].	self error: 'end of array expected'! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseCharacter	| char |	(char := stream next) = $\ 		ifFalse: [ ^ char ].	(char := stream next) = $" 		ifTrue: [ ^ char ].	char = $\		ifTrue: [ ^ char ].	char = $/		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char)! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseCharacterHex	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ value := (value << 4) + self parseCharacterHexDigit ].	^ Character codePoint: value! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseCharacterHexDigit    | digit |    stream atEnd        ifFalse: [             digit := stream next charCode.            (digit between: 48 and: 57)                ifTrue: [ ^ digit - 48 ].	"$0"	"$9"            (digit between: 65 and: 70)                ifTrue: [ ^ digit - 55 ].	"$A"	"$F"            (digit between: 97 and: 102)                ifTrue: [ ^ digit - 87 ]	"$a"	"$f" ].    self error: 'hex-digit expected'! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseNumber	| negated number |	negated := stream peek = $-.	negated ifTrue: [ stream next ].	number := self parseNumberInteger.	(stream peek = $.) ifTrue: [		stream next. 		number := number + self parseNumberFraction ].	(stream peek = $e or: [ stream peek = $E ]) ifTrue: [		stream next.		number := number * self parseNumberExponent ].	negated ifTrue: [ number := number negated ].	^ self whitespace; createNumber: number! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseNumberExponent    | number negated |    number := 0.    negated := stream peek = $-.    (negated or: [ stream peek = $+ ])        ifTrue: [ stream next ].    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next charCode - 48) ].    negated        ifTrue: [ number := number negated ].    ^ 10 raisedTo: number! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseNumberFraction    | number power |    number := 0.    power := 1.0.    [ stream atEnd not and: [ stream peek isDigit ] ]        whileTrue: [             number := 10 * number + (stream next charCode - 48).            power := power * 10.0 ].    ^ number / power! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseNumberInteger    | number |    number := 0.    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next charCode - 48) ].    ^ number! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parseObject	| result |	self expect: '{'.	result := self createObject.	(self match: '}')		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addProperty: self parseProperty			to: result.		(self match: '}')			ifTrue: [ ^ result ].		self expect: ',' ].	self error: 'end of object expected'! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseProperty	| name value |	name := self parseString.	self expect: ':'.	value := self parseValue.	^ self createProperty: name with: value.! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseString	| result |	self expect: '"'.	result := WriteStream on: String new.	[ stream atEnd or: [ stream peek = $" ] ] 		whileFalse: [ result nextPut: self parseCharacter ].	^ self expect: '"'; createString: result contents! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parseValue	| char |	stream atEnd ifFalse: [ 		char := stream peek.		char = ${			ifTrue: [ ^ self parseObject ].		char = $[			ifTrue: [ ^ self parseArray ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char between: $0 and: $9 ])			ifTrue: [ ^ self parseNumber ].		(self match: 'true')			ifTrue: [ ^ self createTrue ].		(self match: 'false')			ifTrue: [ ^ self createFalse ].		(self match: 'null')			ifTrue: [ ^ self createNull ] ].	self error: 'invalid input'! !!MCFileTreeJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!whitespace	"Strip whitespaces from the input stream."	[ stream atEnd not and: [ stream peek isSeparator ] ]		whileTrue: [ stream next ]! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 6/13/2012 16:09'!classic    "set the options such that the load performed will be identical to the classic ConfigurationOf load:	(ConfigurationOfExample project version: '1.0') load		#classic forces Metacello to look at image state to determine which version of a project is loaded instead of using		the registry to tell us explicitly which version of a project is loaded .. image state is not PRECISE"    "useCurrentVersion is a 'private' option for enforcing classic rules, so it's not part of scripting api"    ^ self new        onUpgrade: [ :ex | ex allow ];        onConflict: [ :ex | ex allow ];        addStatement: #'useCurrentVersion:' args: {true};        yourself! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 7/16/2012 10:12'!image    ^ self new        executorSpec: #'MetacelloScriptImageExecutor' -> 'batch';        yourself! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 07/27/2013 08:45'!registrations  ^ MetacelloProjectRegistration registry registrations! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 7/13/2012 09:13'!registry    ^ self new        executorSpec: #'MetacelloScriptRegistryExecutor' -> 'batch';        yourself! !!Metacello class methodsFor: 'private' stamp: 'dkh 7/13/2012 09:08'!scriptExecutorClass    ^ self scriptExecutorClass: {(#'MetacelloScriptApiExecutor' -> 'batch')}! !!Metacello class methodsFor: 'private' stamp: 'dkh 7/13/2012 09:15'!scriptExecutorClass: anExecutorSpec    Smalltalk at: anExecutorSpec key ifAbsent: [ ConfigurationOf ensureMetacello: anExecutorSpec value ].    ^ Smalltalk at: anExecutorSpec key! !!Metacello methodsFor: 'private' stamp: 'dkh 5/31/2012 17:57:13'!addStatement: selector args: args    self statements add: selector -> args! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:45'!baseline: projectName    self addStatement: #'baselineArg:' args: {projectName}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 09/29/2014 12:34'!bitbucketUser: userName project: projectName commitish: commitish path: path  | branchOrCommitOrTag |  branchOrCommitOrTag := commitish.  branchOrCommitOrTag isEmpty    ifTrue: [ branchOrCommitOrTag := 'master' ].  self    repository:      'bitbucket://' , userName , '/' , projectName , ':' , branchOrCommitOrTag , '/'        , path! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:46'!blueplane: projectName    self repository: 'http://squeaksource.blueplane.jp/' , projectName! !!Metacello methodsFor: 'api options' stamp: 'dkh 7/23/2012 16:17'!cacheRepository: aRepositoryDescription    self addStatement: #'cacheRepository:' args: {aRepositoryDescription}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:45'!className: className    self addStatement: #'classNameArg:' args: {className}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!configuration: projectName    self addStatement: #'configurationArg:' args: {projectName}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:48'!croquet: projectName    self repository: 'http://hedgehog.software.umn.edu:8888/' , projectName! !!Metacello methodsFor: 'private' stamp: 'dkh 09/30/2014 13:58'!execute: selector args: args  | script |  script := self statements copy.  script add: selector -> args.  ^ self scriptExecutor execute: script! !!Metacello methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:12'!executorSpec    executorSpec ifNil: [ executorSpec := #'MetacelloScriptApiExecutor' -> 'batch' ].    ^ executorSpec! !!Metacello methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:13'!executorSpec: anAssoc    executorSpec := anAssoc! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 13:59'!fetch  ^ self execute: #'fetch:' args: #(#())! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 13:59'!fetch: required  ^ self execute: #'fetch:' args: {required}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:21'!filetreeDirectory: directoryName  self repository: 'filetree://' , directoryName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 06/28/2013 16:52'!gemsource: projectName  self repository: 'http://seaside.gemtalksystems.com/ss/' , projectName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 13:59'!get  "resolve project name in given repository and return an instance of MetacelloProject resolved from a ConfigurationOf or BaselineOf"  ^ self execute: #'get' args: #()! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'ct 11/7/2020 20:15'!githubUser: userName project: projectName commitish: commitish path: path	"commitish can be a branch name, commit hash, or tag."	self repository: (		'github://' , userName , '/' , projectName , (			(commitish isNil or: [commitish isEmpty])				ifTrue: ['']				ifFalse: [':' , commitish]		) , '/' , path)! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'ct 11/7/2020 20:12'!githubUser: userName project: projectName path: path	^ self		githubUser: userName		project: projectName		commitish: nil		path: path! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/13/2012 16:05'!ignoreImage    "ignore image state"    self addStatement: #'ignoreImage:' args: {true}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:48'!impara: projectName    self repository: 'http://source.impara.de/' , projectName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00'!list  "list projects in registry"  ^ self execute: #'list' args: #()! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00'!load  ^ self execute: #'load:' args: #(#())! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00'!load: required  ^ self execute: #'load:' args: {required}! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00'!lock  "lock projects in registry"  ^ self execute: #'lock' args: #()! !!Metacello methodsFor: 'api actions' stamp: 'dkh 07/25/2013 15:45'!locked  "list of locked projects in registry"  ^ self    project: [ :projectSpec | projectSpec isLocked ];    list! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/7/2012 15:34'!onConflict: aBlock    self addStatement: #'onConflict:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 15:25'!onConflictUseIncoming  self onConflict: [ :ex :loaded :incoming | ex useIncoming ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 16:44'!onConflictUseIncoming: incomingProjects useLoaded: loadedProjects  self    onConflict: [ :ex :loaded :incoming |       (incomingProjects includes: incoming baseName)        ifTrue: [ ex useIncoming ]        ifFalse: [           (loadedProjects includes: incoming baseName)            ifTrue: [ ex useLoaded ] ].      ex pass ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 15:25'!onConflictUseLoaded  self onConflict: [ :ex :loaded :incoming | ex useLoaded ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/8/2012 14:03:46'!onDowngrade: aBlock    self addStatement: #'onDowngrade:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onDowngradeUseIncoming  self onDowngrade: [ :ex :loaded :incoming | ex useIncoming ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onDowngradeUseIncoming: projectNames  self    onDowngrade: [ :ex :loaded :incoming |       (projectNames includes: loaded baseName)        ifTrue: [ ex useIncoming ]        ifFalse: [ ex useLoaded ] ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 07/24/2013 17:09'!onLock: aBlock  self addStatement: #'onLock:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/13/2014 09:31'!onLockBreak  self onLock: [ :ex :loaded :incoming | ex break ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/13/2014 09:32'!onLockBreak: projectNames  self    onLock: [ :ex :loaded :incoming |       (projectNames includes: loaded baseName)        ifTrue: [ ex break ]        ifFalse: [ ex honor ] ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/7/2012 15:33'!onUpgrade: aBlock    self addStatement: #'onUpgrade:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onUpgradeUseLoaded  self onUpgrade: [ :ex :loaded :incoming | ex useLoaded ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onUpgradeUseLoaded: projectNames  self    onUpgrade: [ :ex :loaded :incoming |       (projectNames includes: loaded baseName)        ifTrue: [ ex useLoaded ]        ifFalse: [ ex useIncoming ] ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 07/24/2013 15:22'!onWarning: aBlock  self addStatement: #'onWarning:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:53'!onWarningLog  self    onWarning: [ :ex |       Transcript        cr;        show: ex description.      ex resume ]! !!Metacello methodsFor: 'api projectSpec' stamp: 'ct 11/16/2020 12:34'!password: aString	"Password or access token to authenticate to the repository. Optional. Depending on the repository provider, the username might be optional if an access token is provided as a password. See https://github.com/Metacello/metacello/pull/536. See also implementors of #sitePassword:."	self addStatement: #'passwordArg:' args: {aString}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!project: projectName    self addStatement: #'projectArg:' args: {projectName}! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00'!record  ^ self execute: #'record:' args: #(#())! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00'!record: required  ^ self execute: #'record:' args: {required}! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:01'!register  "change registered project"  ^ self execute: #'register' args: #()! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:48'!renggli: projectName    self repository: 'http://source.lukas-renggli.ch/' , projectName! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!repository: repositoryDescription    self addStatement: #'repositoryArg:' args: {repositoryDescription}! !!Metacello methodsFor: 'api options' stamp: 'dkh 7/23/2012 19:27'!repositoryOverrides: aRepositoryDescriptionCollection    self addStatement: #'repositoryOverrides:' args: {aRepositoryDescriptionCollection}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:49'!saltypickle: projectName    self repository: 'http://squeak.saltypickle.com/' , projectName! !!Metacello methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:16'!scriptExecutor    ^ (self class scriptExecutorClass: self executorSpec) new! !!Metacello methodsFor: 'api options' stamp: 'dkh 5/31/2012 17:57:13'!silently    "no progress bars"    self addStatement: #'silently:' args: {true}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:20'!smalltalkhubUser: userName project: projectName  self    repository:      'http://smalltalkhub.com/mc/' , userName , '/' , projectName , '/main'! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:49'!squeakfoundation: projectName    self repository: 'http://source.squeakfoundation.org/' , projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:17'!squeaksource3: projectName  self repository: 'http://ss3.gemtalksystems.com/ss/' , projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:50'!squeaksource: projectName    self repository: 'http://www.squeaksource.com/' , projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:46'!ss3: projectName    self squeaksource3: projectName! !!Metacello methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!statements    statements ifNil: [ statements := OrderedCollection new ].    ^ statements! !!Metacello methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!statements: anObject	statements := anObject! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'topa 1/19/2015 15:25'!swa: projectName    self swasource: projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'topa 1/19/2015 15:25'!swasource: projectName    self repository: 'http://www.hpi.uni-potsdam.de/hirschfeld/squeaksource/' , projectName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:01'!unlock  "unlock projects in registry"  ^ self execute: #'unlock' args: #()! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:01'!unregister  "unlock projects in registry"  ^ self execute: #'unregister' args: #()! !!Metacello methodsFor: 'api projectSpec' stamp: 'ct 11/16/2020 12:32'!username: aString	"Username to authenticate to the repository. Optional. See https://github.com/Metacello/metacello/pull/536. See also implementors of #siteUsername:."	self addStatement: #'usernameArg:' args: {aString}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!version: versionString    self addStatement: #'versionArg:' args: {versionString}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:50'!wiresong: projectName    self repository: 'http://source.wiresong.ca/' , projectName! !!MetacelloAbstractConstructor methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!configurationClass	^self subclassResponsibility! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractAllVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version: into: aDict.	self extractPragmas: #version:imports: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractCommonDefaultSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #defaultSymbolicVersion: for: ConfigurationOf into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractDefaultSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #defaultSymbolicVersion: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!extractPragmas: pragmaKeyword for: aClass into: versionDict	| versionString  pragmas |	(Pragma 		allNamed: pragmaKeyword		in: aClass) do: [:pragma |			versionString := pragma argumentAt: 1.			pragmas := versionDict 				at: versionString 				ifAbsent: [ | list |					list := OrderedCollection new.					versionDict at: versionString put: list.					list ].			pragmas add: pragma ].! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!extractPragmas: pragmaKeyword into: versionDict	^self extractPragmas: pragmaKeyword for: self configurationClass into: versionDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #symbolicVersion: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractVersionImportPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version:imports: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version: into: aDict.	^aDict! !!MetacelloAbstractVersionConstructor class methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!symbolicMethodSelectorAndPragma: selector symbolicVersionSymbol: symbolicVersionSymbol on: strm	strm		nextPutAll: selector asString , ' spec';		cr;		tab;		nextPutAll: '<symbolicVersion: #' , symbolicVersionSymbol asString printString;		nextPutAll: '>';		cr! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!addAttribute: anAttribute	self attributeOrder add: anAttribute! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!attributeMap	attributeMap == nil ifTrue: [ attributeMap := Dictionary new ].	^attributeMap! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!attributeOrder	attributeOrder == nil ifTrue: [ attributeOrder := OrderedCollection new ].	^attributeOrder! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!author: aBlockOrString    "Define author field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrString> is a String, the version spec author is set to the String.	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the author spec (MetacelloValueHolderSpec). Not Recommended!!			spec author: 'dkh'.				spec author: [			spec value: 'dkh'. ].	 "    self root author: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!authorForVersion: aBlockOrString    aBlockOrString setAuthorInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!baseline: aString    self root baseline: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!baseline: aString with: aBlockOrString    self root baseline: aString with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!baselineForVersion: aString    self setBaseline: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!baselineForVersion: aString with: aBlock    aBlock setBaseline: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!blessing: aBlockOrString    "Define blessing field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrString> is a String, the version spec blessing is set to the String. It is recommended to use a Symbol.	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the blessing spec (MetacelloValueHolderSpec). Not Recommended!!			spec blessing: #release.				spec blessing: [			spec value: #release. ].		The blessing should typically be set to one of three values:		#baseline - indicating that the version spec is specifying a baseline version		#development - indicating that the version spec is not stabilized and will change over time		#release - indicating that the version spec has stabilized and will NOT change over time	 "    self root blessing: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!blessingForVersion: aBlockOrString    aBlockOrString setBlessingInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!className: aString    "Define className field of a project spec (MetacelloMCProjectSpec).			spec project: 'CoolBrowser' with: [			spec className: 'ConfigurationOfCoolBrowser'. ].	The className field is OPTIONAL in the project spec. If omitted, the className will be created by prepending 'ConfigurationOf' to the project name.	 "    self root className: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!classNameForProject: aString    self root className: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configuration	^configuration! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configuration: aConfig	configuration := aConfig! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!configuration: aString with: aBlockOrString    self root configuration: aString with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationClass	^self configuration class! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!configurationForVersion: aString with: aBlock    aBlock setConfiguration: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!description: aBlockOrString    "Define description field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrString> is a String, the version spec blessing is set to the String. It is recommended to use a Symbol.	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the blessing spec (MetacelloValueHolderSpec). Not Recommended!!			spec description: 'Descriptive comment'.				spec description: [			spec value: 'Descriptive comment'.	 "    self root description: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!descriptionForVersion: aBlockOrString    aBlockOrString setDescriptionInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'private' stamp: 'EstebanLorenzano 9/16/2017 14:02'!evaluatePragma: pragma	currentContext := pragma.	[ self configuration 		perform: (MetacelloPlatform current selectorForPragma: pragma) 		with: self ] 	ensure: [ currentContext := nil ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!file: aString    "Define file field of a package spec (MetacelloPackageSpec) or project spec (MetacelloMCProjectSpec).	For a package spec, the file: field is optional in a baseline. In a baseline, the file field may be used to specify a package branch for the package:			spec package: 'MyPackage' with: [			spec file: 'MyPackage.gemstone'. ]'.	The file: field is required in a version. In a version, the file field defines the explicit version of the package to be loaded:			spec package: 'MyPackage' with: [			spec file: 'MyPackage.gemstone-dkh.1'. ]'.	The following may be used as a short cut for specifying the file field in a version:		spec package: 'MyPackage' with: 'MyPackage.gemstone-dkh.1'.	For a project spec, the file field specifies the name of the Monticello package that contains the configuration. If you are using the convention of 	naming the class and package usingthe  'ConfigurationOf' prefix, then there is no need to specify the file field:			spec project: 'MyProject' with: [			spec file: 'ConfigurationMyProject'.	It should only be used when the package name for the configuration is different from the name of the project:		spec project: 'MyProject' with: [			spec file: 'MyProject-Metacello'.	 "    self root file: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!fileForPackage: aString    self root file: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!fileForProject: aString    self root file: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!for: attributeListOrSymbol do: aBlock    "conditional version support"    attributeListOrSymbol setForDo: aBlock withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!for: attributeListOrSymbol version: aString    "conditional symbolicVersion support"    attributeListOrSymbol setForVersion: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!group: aString overrides: aStringOrCollection    self root group: aString overrides: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!group: aString with: aStringOrCollection    self root group: aString with: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!groupForVersion: aString overrides: aStringOrCollection    | spec |    spec := self project groupSpec        name: aString;        includes: aStringOrCollection;        yourself.    self root packages add: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!groupForVersion: aString with: aStringOrCollection    | spec |    spec := self project groupSpec        name: aString;        includes: aStringOrCollection;        yourself.    self root packages merge: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!import: aStringOrCollection  "import names defined in baseline <aString> to be used when loading the version		spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec import: 'Sample' ]		or a list of names for multiple project imports:			spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec baseline: 'Example' with: [ spec repository: 'github://dalehenrich/example:master/repository' ].		spec import: #('Sample' 'Example')]		 "  self root import: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!import: aString provides: aCollection  "import names defined in baseline <aString> to be used when loading the version			spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec import: 'Sample' provides: #('Sample Core');		spec baseline: 'Example' with: [ spec repository: 'github://dalehenrich/example:master/repository' ].		spec import: 'Example' provides: #('Example Core')]		 "  self root import: aString provides: aCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!importForVersion: aString    self root import: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!importForVersion: aString provides: anArray  self root import: aString provides: anArray! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!includes: anObject    self root includes: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!includesForPackage: anObject    self root includes: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!loads: aStringOrCollection  self root loads: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!loadsForProject: anObject    self root loads: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!name: anObject    self root name: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!nameForProject: aString    self root name: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!operator: anObject    self root operator: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!operatorForProject: anObject    self root operator: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!package: aString    self root package: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!package: aString overrides: aBlock    self root package: aString overrides: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!package: packageName with: aBlockOrString    "Define specification for package <packageName>.	 If <aBlockOrString> is a String (or Symbol), the String is expected to be a version (or symbolic version).	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the project:			spec package: 'MyPackage' with: '1.0'.				spec package: 'MyPackage' with: [			spec file:'MyPackage-dkh.1'.			spec repository: '/opt/gemstone/repository'.	 "    self root package: packageName with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!packageForVersion: aString    | spec |    spec := self project packageSpec        name: aString;        yourself.    self root packages add: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!packageForVersion: aString overrides: aBlock    | spec |    spec := self project packageSpec        name: aString;        yourself.    self root packages add: spec.    self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!packageForVersion: packageName with: aBlockOrString    aBlockOrString setPackage: packageName withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!postLoadDoIt: aSymbol    self root postLoadDoIt: aSymbol constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!postLoadDoItForPackage: aSymbol    self postLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!postLoadDoItForProject: aSymbol    self postLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!postLoadDoItForSpec: aSymbol    self validateDoItSelector: aSymbol.    self root postLoadDoIt: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!postLoadDoItForVersion: aSymbol    self postLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!preLoadDoIt: aSymbol    self root preLoadDoIt: aSymbol constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!preLoadDoItForPackage: aSymbol    self preLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!preLoadDoItForProject: aSymbol    self preLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!preLoadDoItForSpec: aSymbol    self validateDoItSelector: aSymbol.    self root preLoadDoIt: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!preLoadDoItForVersion: aSymbol    self preLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project    project == nil        ifTrue: [ project := self projectClass new ].    ^ project! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!project: aString    self root project: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!project: aString copyFrom: oldSpecName with: aBlock    self root        project: aString        copyFrom: oldSpecName        with: aBlock        constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!project: aString overrides: aBlock    self root project: aString overrides: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!project: aString with: aBlockOrString    self root project: aString with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: '*metacello-mc-accessing' stamp: '9/28/2017 08:53:29'!projectClass    ^ MetacelloMCProject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!projectForVersion: aString    self project: aString with: ''! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!projectForVersion: aString copyFrom: oldSpecName with: aBlock    | spec projectSpec |    projectSpec := self project projectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages copy: oldSpecName to: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!projectForVersion: aString overrides: aBlock    | spec projectSpec |    projectSpec := self project projectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages add: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!projectForVersion: aString with: aBlockOrString    aBlockOrString setProject: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!projectPackage: aBlock    "projectPackage spec data folded into project spec"    self root projectPackage: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!projectPackageForProject: aBlock    self with: self root during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!removeGroup: aString    self root removeGroup: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!removeGroupForVersion: aString    | spec |    spec := self project groupSpec        name: aString;        yourself.    self root packages remove: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!removePackage: aString    self root removePackage: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!removePackageForVersion: aString    | spec |    spec := self project packageSpec        name: aString;        yourself.    self root packages remove: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!removeProject: aString    self root removeProject: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!removeProjectForVersion: aString    | spec |    spec := self project projectReferenceSpec        name: aString;        yourself.    self root packages remove: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!repositories: aBlock    self root repositories: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoriesForPackage: aBlock    self repositoriesForSpec: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoriesForProject: aBlock    self repositoriesForSpec: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoriesForSpec: aBlock    self with: self root repositories during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoriesForVersion: aBlock    self repositoriesForSpec: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!repository: anObject    self root repository: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!repository: description username: username password: password    self root        repository: description        username: username        password: password        constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForPackage: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForPackage: aString username: username password: password    self repositoryForSpec: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForProject: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForProject: aString username: username password: password    self repositoryForSpec: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForRepositories: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForRepositories: aString username: username password: password    self repositoryForVersion: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForSpec: anObject    self root repository: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForSpec: aString username: username password: password    self root repository: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForVersion: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!repositoryForVersion: aString username: username password: password    self repositoryForSpec: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!requires: anObject    self root requires: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!requiresForPackage: anObject    self root requires: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!reset    attributeMap := attributeOrder := nil! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!root	^root! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!root: aMetacelloSpec    root := aMetacelloSpec! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setAuthorWithBlock: aBlock	| spec |	(spec := self root getAuthor) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setAuthor: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setAuthorWithString: aString	self root author: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setBaseline: aString    | spec projectSpec |    projectSpec := self project baselineOfProjectSpec        name: aString;        className: 'BaselineOf' , aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages merge: spec.    ^ projectSpec! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setBaseline: aString withBlock: aBlock    | projectSpec |    projectSpec := self setBaseline: aString.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setBlessingWithBlock: aBlock	| spec |	(spec := self root getBlessing) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setBlessing: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setBlessingWithString: aString	self root blessing: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setConfiguration: aString withBlock: aBlock    | spec projectSpec |    projectSpec := self project configurationOfProjectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages merge: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setDescriptionWithBlock: aBlock	| spec |	(spec := self root getDescription) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setDescription: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setDescriptionWithString: aString	self root description: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setFor: attributeList do: aBlock    "conditional version support"    attributeList asMetacelloAttributeList        do: [ :attribute |             | blockList |            blockList := self attributeMap                at: attribute                ifAbsent: [ self attributeMap at: attribute put: (blockList := OrderedCollection new) ].            blockList add: aBlock.            self addAttribute: attribute ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setFor: attributeList version: aString    "conditional symbolicVersion support"    attributeList asMetacelloAttributeList        do: [ :attribute |             self attributeMap at: attribute put: aString.            self addAttribute: attribute ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setPackage: aString withBlock: aBlock	| spec |	spec := 		(self project packageSpec)			name: aString;			yourself.	self root packages merge: spec.	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setPackage: aString withString: aFile	| spec |	spec := 		(self project packageSpec)			name: aString;			file: aFile;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setProject: aProject	project := aProject! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setProject: aString withBlock: aBlock    | spec projectSpec |    projectSpec := self project projectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages merge: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setProject: aString withString: versionString	| spec projectSpec |	projectSpec := 		(self project projectSpec)			name: aString;			versionString: versionString;			yourself.	spec := 		(self project projectReferenceSpec)			name: aString;			projectReference: projectSpec;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setTimestampWithBlock: aBlock	| spec |	(spec := self root getTimestamp) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setTimestamp: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setTimestampWithString: aString	self root timestamp: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!supplyingAnswers: aCollection    self root supplyingAnswers: aCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!supplyingAnswersForPackage: anObject    self root answers: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!symbolicVersion	^symbolicVersion! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!symbolicVersion: aSymbol	symbolicVersion := aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!timestamp: aBlockOrStringOrDateAndTime    "Define timestamp field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrStringOrDateAndTime> is a String, the version spec timetamp is set to the String.	 If <aBlockOrStringOrDateAndTime> is a DateAndTime, the version spec timetamp is set to the printString of the DateAndTime.	If <aBlockOrStringOrDateAndTime> is a Block, the specifications in <aBlockOrStringOrDateAndTime> are applied to the timestamp spec (MetacelloValueHolderSpec). Not Recommended!!			spec timestamp: '10/7/2009 14:40'.				spec timestamp: DateAndTime now'.				spec timestamp: [			spec value: '10/7/2009 14:40'. ].    "    self root timestamp: aBlockOrStringOrDateAndTime constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!timestampForVersion: aBlockOrStringOrDateAndTime    aBlockOrStringOrDateAndTime setTimestampInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validateDoItSelector: anObject	anObject == nil ifTrue: [ ^ self ].	anObject isSymbol ifFalse: [ self error: 'Invalid message selector for doit: ', anObject printString ].! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!value: anObject    self root value: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!valueForValueHolder: anObject    self root value: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!version: anObject    self root version: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!versionForProject: anObject    self versionStringForProject: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!versionForVersion: anObject    self versionStringForVersion: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: '9/28/2017 08:54:38'!versionString: anObject    self root versionString: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!versionStringForProject: anObject    self root versionString: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: '9/28/2017 08:54:38'!versionStringForVersion: anObject    self versionStringForProject: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!with: aMetacelloSpec during: aBlock    | previousRoot |    previousRoot := self root.    self root: aMetacelloSpec.    aBlock        ensure: [ self root: previousRoot ]! !!MetacelloBaselineConstructor class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!on: aConfig    ^ self new        on: aConfig;        yourself! !!MetacelloBaselineConstructor class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!on: aConfig project: aProject    ^ self new        on: aConfig project: aProject;        yourself! !!MetacelloBaselineConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!calculate: aConfig project: aProject    | pragma versionMap versionSpec |    self configuration: aConfig.    pragma := self extractBaselinePragmaFor: aConfig class.    self        setProject:            (aProject                ifNil: [                     [ aConfig class project ]                        on: MessageNotUnderstood                        do: [ :ex | ex return: nil ] ]).    versionSpec := self project versionSpec.    self root: versionSpec.    self evaluatePragma: pragma.    versionMap := Dictionary new.    self project attributes        do: [ :attribute |             | blockList |            (blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil                ifTrue: [ blockList do: [ :block | self with: versionSpec during: block ] ] ].    versionSpec versionString: self project singletonVersionName.    versionMap at: versionSpec versionString put: versionSpec createVersion.    self project map: versionMap.    self project configuration: aConfig! !!MetacelloBaselineConstructor methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractBaselinePragmaFor: aClass    | pragmas |    pragmas := Pragma allNamed: #'baseline' in: aClass.    pragmas isEmpty        ifTrue: [ ^ self error: 'No #baseline pragma found' ].    ^ pragmas first! !!MetacelloBaselineConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!on: aConfig    self calculate: aConfig project: nil! !!MetacelloBaselineConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!on: aConfig project: aProject    self calculate: aConfig project: aProject! !!MetacelloBaselineConstructor methodsFor: '*metacello-mc-accessing' stamp: '9/28/2017 08:53:29'!projectClass    ^ MetacelloMCBaselineProject! !!MetacelloToolBoxBaselineConstructor methodsFor: 'private' stamp: 'dkh 05/21/2016 20:27'!evaluateBaselineMethodSection: methodSection  | versionSpec |  versionSpec := self project versionSpec.  methodSection versionSpec: versionSpec.  currentSection := methodSection.  self with: versionSpec during: methodSection block.  methodSection methodSections    do: [ :ms | self evaluateBaselineMethodSection: ms ]! !!MetacelloToolBoxBaselineConstructor methodsFor: 'pragma extraction' stamp: 'dkh 05/21/2016 20:22'!extractBaselinePragmaFor: aClass    | pragmas |    pragmas := Pragma allNamed: #'baseline' in: aClass.    pragmas isEmpty        ifTrue: [ ^ self error: 'No #baseline pragma found' ].    ^ pragmas first! !!MetacelloToolBoxBaselineConstructor methodsFor: 'extraction' stamp: 'dkh 05/21/2016 20:34'!extractMethodSectionsFor: aBaselineClass  self shouldNotImplement! !!MetacelloToolBoxBaselineConstructor methodsFor: 'extraction' stamp: 'dkh 05/21/2016 20:35'!extractMethodSectionsForClass: aBaselineClass  | pragma |  pragma := self extractBaselinePragmaFor: aBaselineClass.  self evaluatePragma: pragma.  self methodSections    do: [ :methodSection | self evaluateBaselineMethodSection: methodSection ]! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!evaluateMethodSection: methodSection version: sourceVersionString	| versionSpec |	versionSpec := self project versionSpec.	versionSpec versionString: sourceVersionString.	methodSection versionSpec: versionSpec.	currentSection := methodSection.	self with: versionSpec during: methodSection block.	methodSection methodSections do: [ :ms | self evaluateMethodSection: ms version: sourceVersionString ]! !!MetacelloToolBoxConstructor methodsFor: 'extraction' stamp: '9/28/2017 08:54:38'!extractMethodSectionsFor: sourceVersionString	| coll pragma |	coll := self extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^ #() ].	coll size > 1		ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].	pragma := coll at: 1.	self evaluatePragma: pragma.	self methodSections do: [ :methodSection | self evaluateMethodSection: methodSection version: sourceVersionString ].! !!MetacelloToolBoxConstructor methodsFor: 'extraction' stamp: '9/28/2017 08:54:38'!extractSymbolicVersionSpecsFor: sourceVersionSymbol	| coll pragma |	coll := self extractSymbolicVersionPragmas at: sourceVersionSymbol ifAbsent: [ ^ #() ].	coll size > 1		ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionSymbol printString ].	pragma := coll at: 1.	self evaluatePragma: pragma.	^ self methodSections! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!methodSection: methodSection do: aBlock	methodSection methodSections do: aBlock.	methodSection methodSections do: [ :ms | self methodSection: ms do: aBlock ]! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!methodSection: methodSection inEvaluationOrder: attributes do: aBlock    | selected |    selected := IdentitySet new.    attributes        do: [ :attribute |             methodSection methodSections                do: [ :ms |                     (ms attributes includes: attribute)                        ifTrue: [ selected add: ms ] ] ].    selected do: aBlock.    attributes size == 1        ifTrue: [ ^ self ].    selected        do: [ :ms | self methodSection: ms inEvaluationOrder: (attributes copyFrom: 2 to: attributes size) do: aBlock ]! !!MetacelloToolBoxConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodSectionAttributes    | attributes |    attributes := Set new.    self methodSectionsDo: [ :methodSection | attributes addAll: methodSection attributes ].    ^ attributes! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!methodSections	methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].	^methodSections! !!MetacelloToolBoxConstructor methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!methodSectionsDo: aBlock	self methodSection: self do: aBlock! !!MetacelloToolBoxConstructor methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!methodSectionsInEvaluationOrder: attributes do: aBlock    "breadth first traversal ... to collect selected sections, then evaluate individual sections in attribute order"    | selected processed |    selected := IdentitySet new.    self methodSection: self inEvaluationOrder: attributes do: [ :methodSection | selected add: methodSection ].    processed := IdentitySet new.    attributes        do: [ :attribute |             | list |            list := OrderedCollection new.            selected                do: [ :methodSection |                     (processed includes: methodSection)                        ifFalse: [                             (methodSection attributes includes: attribute)                                ifTrue: [                                     list add: methodSection.                                    processed add: methodSection ] ] ].            list do: aBlock ]! !!MetacelloToolBoxConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!reset	super reset.	"not needed, but included for completeness"	methodSections := nil! !!MetacelloToolBoxConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setFor: attributeList do: aBlock    "conditional version support"    | methodSection |    methodSection := MetacelloVersionMethodSection new        attributes: attributeList asMetacelloAttributeList;        block: aBlock;        yourself.    currentSection ~~ nil        ifTrue: [ currentSection addMethodSection: methodSection ]        ifFalse: [ self methodSections add: methodSection ]! !!MetacelloToolBoxConstructor methodsFor: 'api callbacks' stamp: '9/28/2017 08:54:38'!setFor: attributeList version: aString    "conditional symbolicVersion support"    self methodSections        add:            (MetacelloSymbolicVersionSpec new                attributes: attributeList asMetacelloAttributeList;                versionString: aString;                yourself)! !!MetacelloVersionConstructor class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!on: aConfig	^(self new)		on: aConfig;		yourself! !!MetacelloVersionConstructor class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!on: aConfig project: aProject	^(self new)		on: aConfig project: aProject;		yourself! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self new		spawnPackageMethodIn: aConfig 		category: methodCategory 		named: newSelector		sourceVersion: sourceVersionString 		targetVersion: targetVersionString		blessing: blessing! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!spawnPackageMethodIn: aConfig named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self 		spawnPackageMethodIn: aConfig 		category: 'versions'		named: newSelector 		sourceVersion: sourceVersionString 		targetVersion: targetVersionString 		blessing: #development! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!spawnPackageMethodIn: aConfig named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self new		spawnPackageMethodIn: aConfig 		category: 'versions'		named: newSelector 		sourceVersion: sourceVersionString 		targetVersion: targetVersionString		blessing: blessing! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for a similar example'.	^self new		updatePackageMethodIn: aConfig 		sourceVersion: sourceVersionString! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!calculate: aConfig project: aProject    | versionMap symbolicVersionMap executionBlock pragmaDict |    self setProject: aProject.    self configuration: aConfig.    versionMap := Dictionary new.    symbolicVersionMap := Dictionary new.    executionBlock := self specResolverBlock.    self collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock.    pragmaDict := self extractVersionImportPragmas.    self verifyVersionImportPragmas: pragmaDict definedIn: versionMap.    self collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict.    self collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: self symbolicVersionResolverBlock.    self project map: versionMap.    self project errorMap: self errorMap.    self project symbolicVersionMap: symbolicVersionMap.    self project configuration: aConfig.	"now that we have a nearly complete project, we can collect the defaultSymbolicVersions, which expect the project to be fully constructed"    self        collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractDefaultSymbolicVersionPragmas        into: symbolicVersionMap        using: self defaultSymbolicVersionResolverBlock.	"Pick up defaults from MetacelloBaseConfiguration"    self        collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractCommonDefaultSymbolicVersionPragmas        into: symbolicVersionMap        using: self commonDefaultSymbolicVersionResolverBlock.	"now resolive symbolicVersions defined as symbolicVersions"    symbolicVersionMap copy        keysAndValuesDo: [ :symbolic :original |             | versionString visited |            versionString := original.            visited := Set new.            [             visited add: versionString.            versionString isSymbol and: [ versionString ~~ #'notDefined' ] ]                whileTrue: [                     versionString := symbolicVersionMap                        at: versionString                        ifAbsent: [ self error: 'Cannot resolve symbolic version ' , original printString ].                    (visited includes: versionString)                        ifTrue: [ self error: 'Loop detected resolving symbolic version ' , original printString ] ].            symbolicVersionMap at: symbolic put: versionString ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: executionBlock	| defined versionPragmaDict versionString |	versionPragmaDict := self extractSymbolicVersionPragmas.	versionPragmaDict		keysAndValuesDo: [ :versionSymbol :pragmaColl | 			defined := false.			pragmaColl				do: [ :pragma | 					defined := true.					versionString := executionBlock value: versionSymbol value: pragma ].			defined				ifTrue: [ 					versionString == nil						ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ]].			self reset ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict    | defined done completed count |    done := false.    completed := IdentitySet new.    count := 0.    [     count := count + 1.    count > 10000        ifTrue: [ self error: 'Apparent loop in import expansion' ].    done ]        whileFalse: [             done := true.            pragmaDict                keysAndValuesDo: [ :versionString :pragmaColl |                     | versionSpec |                    versionSpec := nil.                    defined := false.                    [                     pragmaColl                        do: [ :pragma |                             (completed includes: pragma)                                ifFalse: [                                     | imports |                                    done := false.                                    imports := pragma argumentAt: 2.                                    imports                                        detect: [ :importedVersion | (versionMap includesKey: importedVersion) not ]                                        ifNone: [                                             imports                                                do: [ :importedVersion |                                                     | version |                                                    (version := versionMap at: importedVersion ifAbsent: [  ]) ~~ nil                                                        ifTrue: [                                                             defined := true.                                                            completed add: pragma.                                                            versionSpec == nil                                                                ifTrue: [ versionSpec := version spec copy ]                                                                ifFalse: [ versionSpec := versionSpec mergeSpec: version spec copy ].                                                            versionSpec versionString: versionString.                                                            executionBlock value: versionSpec value: pragma ] ] ] ] ] ]                        on: Error                        do: [ :ex |                             (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex)                                ifTrue: [ ^ ex pass ]                                ifFalse: [                                     self errorMap at: versionSpec versionString put: ex.                                                                     defined := false ] ].                    defined                        ifTrue: [                             | version importedVersions |                            importedVersions := OrderedCollection new.                            version := versionSpec createVersion.                            pragmaColl do: [ :pragma | importedVersions addAll: (pragma argumentAt: 2) ].                            version importedVersions: importedVersions.                            self validateVersionString: versionString againstSpec: versionSpec.                            versionMap at: versionSpec versionString put: version ].                    self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock    | defined versionPragmaDict |    versionPragmaDict := self extractVersionPragmas.    versionPragmaDict        keysAndValuesDo: [ :versionString :pragmaColl |             | versionSpec |            versionSpec := self project versionSpec.            versionSpec versionString: versionString.            defined := false.            [             pragmaColl                do: [ :pragma |                     executionBlock value: versionSpec value: pragma.                    defined := true ] ]                on: Error                do: [ :ex |                     (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex)                        ifTrue: [ ^ ex pass ]                        ifFalse: [                             self errorMap at: versionSpec versionString put: ex.                            defined := false ] ].            defined                ifTrue: [                     self validateVersionString: versionString againstSpec: versionSpec.                    versionMap at: versionSpec versionString put: versionSpec createVersion ].            self reset ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!collectDefaultSymbolicVersionsFromVersionPragmasFrom: versionPragmaDict into: symbolicVersionMap using: executionBlock	| defined versionString |	versionPragmaDict		keysAndValuesDo: [ :versionSymbol :pragmaColl | 			defined := false.			symbolicVersionMap				at: versionSymbol				ifAbsent: [ 					"process the defaultSymbolicVersion only if the symbolicVersion is not defined yet"					pragmaColl						do: [ :pragma | 							defined := true.							versionString := executionBlock value: versionSymbol value: pragma ].					defined						ifTrue: [ 							versionString == nil								ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ] ].					self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!commonDefaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: (ConfigurationOf new project: self project)! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!defaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: self configuration! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'EstebanLorenzano 9/16/2017 14:01'!defaultSymbolicVersionResolverBlock: receiver	^ [ :symbolicVrsn :pragma | 	| result |	result := nil.	(pragma argumentAt: 1) = symbolicVrsn		ifTrue: [ 			self symbolicVersion: symbolicVrsn.			result := [ receiver perform: (MetacelloPlatform current selectorForPragma: pragma) ] 				on: MetacelloVersionDoesNotExistError 				do: [ :ex | ex return: nil ] ].	result ]! !!MetacelloVersionConstructor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!errorMap    errorMap ifNil: [ errorMap := Dictionary new ].    ^ errorMap! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!on: aConfig	| cacheKey |	cacheKey := aConfig class.	project := MetacelloPlatform current		stackCacheFor: #versionConstructor		at: cacheKey		doing: [ :cache | 			self calculate: aConfig project: nil.			cache at: cacheKey put:  self project ].	self setProject: project.! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!on: aConfig project: aProject    | cacheKey cachedProject |    cacheKey := aConfig class.    cachedProject := MetacelloPlatform current        stackCacheFor: #'versionConstructor'        at: cacheKey        doing: [ :cache |             self calculate: aConfig project: aProject.            cache at: cacheKey put: self project.            ^ self ].    aProject map: cachedProject map.    aProject errorMap: cachedProject errorMap.    aProject symbolicVersionMap: cachedProject symbolicVersionMap.    aProject configuration: aConfig.    self setProject: aProject! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!prepareForMethodUpdate: aConfig sourceVersion: sourceVersionString forceUpdate: forceUpdate generating: generateBlock	| pragmaDict versionSpecs pragmaMap updatedPackageSpecs updatedPackageSpecsMap reversed pragmaColl seenUpdatedPackageSpecs |	self deprecated: 'see MetacelloToolBox for replacement methods'.	self configuration: aConfig.	versionSpecs := Dictionary new.	pragmaMap := Dictionary new.	pragmaDict := self extractAllVersionPragmas.	pragmaColl := pragmaDict at: sourceVersionString ifAbsent: [ ^ self ].	pragmaColl		do: [ :pragma | 			| specs versionSpec |			specs := Dictionary new.			self evaluatePragma: pragma.			self attributeMap				keysAndValuesDo: [ :attribute :blockList | 					versionSpec := self project versionSpec.					versionSpec versionString: sourceVersionString.					specs at: attribute put: versionSpec.					blockList do: [ :block | self with: versionSpec during: block ] ].			versionSpecs				at: pragma selector				put:					{specs.					(self attributeOrder).					nil}.			pragmaMap at: pragma selector put: pragma.			self reset ].	versionSpecs		keysAndValuesDo: [ :selector :ar | 			updatedPackageSpecsMap := Dictionary new.			seenUpdatedPackageSpecs := Dictionary new.			ar at: 3 put: updatedPackageSpecsMap.			reversed := aConfig project attributes reverse.			reversed				do: [ :attribute | 					| vs |					(vs := (ar at: 1) at: attribute ifAbsent: [  ]) ~~ nil						ifTrue: [ 							updatedPackageSpecs := forceUpdate								ifTrue: [ vs forceUpdatedPackageSpecs ]								ifFalse: [ vs updatedPackageSpecs ].							updatedPackageSpecs associations								do: [ :assoc | 									| filename |									(filename := seenUpdatedPackageSpecs at: assoc key ifAbsent: [  ]) == nil										ifTrue: [ 											assoc value == #uptodate												ifTrue: [ 													"#uptodate means that the spec is up-to-date and we mark it as										 seen so that the spec is not update for a 'later' spec"													seenUpdatedPackageSpecs at: assoc key put: #uptodate ]												ifFalse: [ seenUpdatedPackageSpecs at: assoc key put: assoc value file ] ]										ifFalse: [ 											"if the spec was already seen as up-to-date or the file is the same as 								 the one already seen don't propogate the file"											(filename == #uptodate or: [ assoc value == #uptodate or: [ filename = assoc value file ] ])												ifTrue: [ updatedPackageSpecs removeKey: assoc key ] ] ].							updatedPackageSpecsMap at: attribute put: updatedPackageSpecs ] ].	"clear out #uptodate markers"			updatedPackageSpecsMap				valuesDo: [ :d | 					d associations						do: [ :assoc | 							assoc value == #uptodate								ifTrue: [ d removeKey: assoc key ] ] ].	"remove shadowed packages"			1 to: reversed size do: [ :index | 				| attribute d |				attribute := reversed at: index.				((d := updatedPackageSpecsMap at: attribute ifAbsent: [  ]) ~~ nil and: [ d keys size > 0 ])					ifTrue: [ 						index + 1 to: reversed size do: [ :shadowIndex | 							d								keysDo: [ :key | 									| dict |									(dict := updatedPackageSpecsMap at: (reversed at: shadowIndex) ifAbsent: [  ]) ~~ nil										ifTrue: [ dict removeKey: key ifAbsent: [  ] ] ] ] ] ].			updatedPackageSpecsMap keys				do: [ :key | 					| d |					d := updatedPackageSpecsMap at: key.					d isEmpty						ifTrue: [ updatedPackageSpecsMap removeKey: key ] ].	"ready to generate source for method"			generateBlock				value: selector				value: pragmaMap				value: ar				value: updatedPackageSpecsMap ]! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createBaseline:for:from:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: blessing ~~ #baseline		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm |			strm := WriteStream on: String new.			strm 				nextPutAll: newSelector asString, ' spec'; cr;				tab; nextPutAll: 						'<version: ', 						targetVersionString printString, 						' imports: #(', sourceVersionString printString, 						')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | | x |							x := d at: member spec name ifAbsent: [].						 	member spec updateForSpawnMethod: x ]]					ifFalse: [						vs packagesSpec list do: [:member |							member spec updateForSpawnMethod: member spec copy ]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp.						blessing ~~ nil							ifTrue: [ vs blessing: blessing ]].				vs configSpawnMethodOn: strm indent: 2.				strm nextPutAll: '].'].				(aConfig class						compile: strm contents					classified: methodCategory) == nil 						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!specResolverBlock	^ [ :versionSpec :pragma | 	(pragma argumentAt: 1) = versionSpec versionString		ifTrue: [ 			self evaluatePragma: pragma.			self project attributes				do: [ :attribute | 					| blockList |					(blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil						ifTrue: [ blockList do: [ :block | self with: versionSpec during: block ] ] ] ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: '9/28/2017 08:54:38'!symbolicVersionResolverBlock	^ [ :symbolicVrsn :pragma | 	| result |	result := nil.	(pragma argumentAt: 1) = symbolicVrsn		ifTrue: [ 			self symbolicVersion: symbolicVrsn.			self evaluatePragma: pragma.			self project attributes				do: [ :attribute | 					| versionString |					versionString := self attributeMap at: attribute ifAbsent: [  ].					versionString ~~ nil						ifTrue: [ result := versionString ] ] ].	result ]! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24'!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: false		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm pragma |			updatedPackageSpecsMap isEmpty ifTrue: [ ^false ].			strm := WriteStream on: String new.			strm 				nextPutAll: selector asString, ' spec'; cr;				tab; nextPutAll: '<version: ', sourceVersionString printString.			pragma := pragmaMap at: selector.			pragma numArgs = 2				ifTrue: [					strm nextPutAll: ' imports: #('.					(pragma argumentAt: 2) do: [:versionString |						strm nextPutAll: versionString printString; space ]].			strm nextPutAll: ')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | 							member spec file ~~ nil								ifTrue: [ | x |									(((x := d at: member spec name ifAbsent: []) ~~ nil) and: [ x ~~ #uptodate ])						 				ifTrue: [ member spec file: x file ]]]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [ 						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp ].				vs configMethodOn: strm indent: 2.				strm nextPutAll: '].'].			(aConfig class						compile: strm contents					classified: (aConfig class whichCategoryIncludesSelector: pragma selector)) == nil						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validateVersionString: versionString againstSpec: versionSpec	versionString = versionSpec versionString		ifFalse: [ 			MetacelloValidationNotification				signal:					(MetacelloValidationError						configurationClass: self configurationClass						reasonCode: #incorrectVersionString						callSite: #validateVersionString:againstSpec						explanation:							'The version declared in the pragma ', versionString printString , ' does not match the version in the spec '								, versionSpec versionString printString) ].! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'EstebanLorenzano 9/27/2017 17:14'!verifyVersionImportPragmas: pragmaDict definedIn: versionMap    pragmaDict copy        keysAndValuesDo: [ :versionString :pragmaColl |             [             pragmaColl                do: [ :pragma |                     (pragma argumentAt: 2)                        do: [ :importedVersion |                             versionMap                                at: importedVersion                                ifAbsent: [                                     pragmaDict                                        at: importedVersion                                        ifAbsent: [                                             ^ self                                                error:                                                    'The imported version:' , importedVersion printString , ' for version: ' , versionString                                                        , ' referenced from the method: ' , (MetacelloPlatform current selectorForPragma: pragma) printString                                                        , ' in configuration ' , configuration class printString                                                        , ' has not been defined.' ] ] ] ] ]                on: Error                do: [ :ex |                     (MetacelloErrorInProjectConstructionNotification versionString: versionString exception: ex)                        ifTrue: [ ^ ex pass ]                        ifFalse: [                             pragmaDict removeKey: versionString.                            self errorMap at: versionString put: ex ] ] ]! !!MetacelloMCVersionValidator class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!populateReasonCodeDescriptions    "update MetacelloMCVersionValidator class comment to include any changes to descriptions"    | dict |    dict := super populateReasonCodeDescriptions.    dict        at: #'notDevelopmentVersion'            put: 'the symbolic version #development refers to a non-development literal version.';        at: #'loadWarning' put: 'Warning signalled during load [load validation].';        at: #'stableDevelopmentVersion'            put: 'a version whose blessing is #development has been declared as a #stable version.'.	"Warnings"    dict        at: #'loadDeprecation' put: 'deprecation warning signalled while loading configuration [load validation].';        at: #'missingRecommendedProjectSpecField'            put:                'missing recommended fields in project reference (versionString). The versionString should be specified so that #bleedingEdge loads will be predictable and repeatable.';        at: #'noLoadableVersions' put: 'no non #baseline versions defined in configuration.';        at: #'noTests' put: 'no test cases defined in loaded configuration [load validation].';        at: #'noVersionSpecified'            put:                'no version defined for the project reference or package. The version specified in the baseline or the latest version of the project or package in the repository will be used.';        at: #'testDeprecation'            put: 'deprecation warning signalled while running configuration tests [load validation].'.	"Critical Warnings"    dict        at: #'loadError' put: 'error occured while loading configuration [load validation].';        at: #'testFailures' put: 'test failures while running tests [load validation].'.	"Errors"    ^ dict! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!validateConfigurationLoad: configurationClass	^ ((self new)		configurationClass: configurationClass;		yourself) validateProjectLoad! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!validateConfigurationLoad: configurationClass version: versionString	^self validateConfigurationLoad: configurationClass version: versionString loads: #()! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!validateConfigurationLoad: configurationClass version: versionString loads: loadList	^ ((self new)		configurationClass: configurationClass;		yourself) validateProjectVersionLoad: versionString loads: loadList! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:53:29'!criticalWarningReasonCodes	^ super criticalWarningReasonCodes		, #(#noLoadableVersions #noTests #testDeprecation #loadDeprecation #noVersionSpecified #'missingRecommendedProjectSpecField' )! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:53:29'!errorReasonCodes	^ super errorReasonCodes, #(#loadError #testFailures )! !!MetacelloMCVersionValidator methodsFor: 'validation' stamp: '9/28/2017 08:53:29'!validateBaselineVersionSpec: versionSpec    | projectNames packageNames groupNames versionMessage |    self        validateDoIts: versionSpec        versionString: versionSpec versionString        errorMessage: ' version ' , versionSpec versionString printString.    projectNames := Set new.    packageNames := Set new.    groupNames := Set new.    versionMessage := ' in version ' , versionSpec versionString printString.    versionSpec        projectDo: [ :projectSpec |             projectSpec resolveProjectSpec className == nil                ifTrue: [                     self                        recordValidationError:                            'Missing required field (className:) for project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'incompleteProjectSpec' ].            projectSpec resolveProjectSpec versionString == nil                ifTrue: [                     self                        recordValidationCriticalWarning:                            'Missing recommended field (versionString:) for project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'missingRecommendedProjectSpecField' ].            projectSpec hasRepository                ifTrue: [                     (self recurse and: [ projectSpec versionString ~~ nil ])                        ifTrue: [                             | project |                            projectSpec resolveProjectSpec ensureProjectLoaded.                            project := self                                validateProjectCreationFrom: projectSpec resolveProjectSpec projectClass                                onError: [ :ex |                                     self                                        recordValidationError: 'Error creating project reference: ' , ex description                                        versionString: versionSpec versionString                                        callSite: #'validateBaselineVersionSpec:'                                        reasonCode: #'projectCreationError'.                                    nil ].                            project ~~ nil                                ifTrue: [                                     self validationReport                                        addAll:                                            (self class                                                validateProject: project                                                version: projectSpec versionString                                                debug: self debug                                                recurse: self recurse                                                visited: self visited) ] ] ]                ifFalse: [                     self                        recordValidationError:                            'Missing required field (repository:) for project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'incompleteProjectSpec' ].            self                validateDoIts: projectSpec                versionString: versionSpec versionString                errorMessage: projectSpec name printString , versionMessage.            (projectNames includes: projectSpec name)                ifTrue: [                     self                        recordValidationError:                            'Duplicate projects named' , projectSpec name printString , versionMessage                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'duplicateNames' ]                ifFalse: [ projectNames add: projectSpec name ] ]        packageDo: [ :packageSpec |             self                validateDoIts: packageSpec                versionString: versionSpec versionString                errorMessage: packageSpec name printString , versionMessage.            (packageNames includes: packageSpec name)                ifTrue: [                     self                        recordValidationError:                            'Duplicate packages named' , packageSpec name printString , versionMessage                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'duplicateNames' ]                ifFalse: [ projectNames add: packageSpec name ] ]        groupDo: [ :groupSpec |             (groupNames includes: groupSpec name)                ifTrue: [                     self                        recordValidationError: 'Duplicate groups named' , groupSpec name printString , versionMessage                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'duplicateNames' ]                ifFalse: [ projectNames add: groupSpec name ] ].    (packageNames intersection: projectNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between packages and projects' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (groupNames intersection: projectNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between groups and projects' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (projectNames intersection: packageNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between projects and packages' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (groupNames intersection: packageNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between groups and packages' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (projectNames intersection: groupNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between projects and groups' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (packageNames intersection: groupNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between packages and groups' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!validateCleanLoadAndTestsForVersion: version loads: loadList	| cleanLoad cleanTests |	cleanTests := cleanLoad := false.	[ 	self validateVersionLoad: version loads: loadList.	cleanLoad := true ]		on: Error , Warning		do: [ :ex | 			(ex isKindOf: Error)				ifTrue: [ 					self						recordValidationError:							'Error while loading version ' , version versionString printString , ' in ' , self configurationClass name asString								, ' ' , ex description						versionString: version versionString						callSite: #validateCleanLoadAndTestsForVersion:loads:						reasonCode: #loadError ].			(ex isKindOf: Warning)				ifTrue: [ 					(ex isKindOf: Deprecation)						ifTrue: [ 							self								recordValidationCriticalWarning:									'Deprecation while loading version ' , version versionString printString , ' in '										, self configurationClass name asString , ' ' , ex description								versionString: version versionString								callSite: #validateCleanLoadAndTestsForVersion:loads:								reasonCode: #loadDeprecation ]						ifFalse: [ 							self								recordValidationWarning:									'Warning while loading version ' , version versionString printString , ' in ' , self configurationClass name asString										, ' ' , ex description								versionString: version versionString								callSite: #validateCleanLoadAndTestsForVersion:loads:								reasonCode: #loadWarning.							Smalltalk								at: #UndeclaredVariableWarning								ifPresent: [ :undeclaredWrning | 									(ex isKindOf: undeclaredWrning)										ifTrue: [ ex resume: true ] ].							ex resume ] ] ].	cleanLoad		ifTrue: [ 			cleanTests := [ self validateVersionTests: version ]				on: Deprecation				do: [ :ex | 					| message |					message := 'Deprecation warning while running tests for version ' , version versionString printString , ' in '						, self configurationClass name asString , ' ' , ex description.	"Deprecation warning for release tests is the same as a test failure"					self						recordValidationCriticalWarning: message						versionString: version versionString						callSite: #validateCleanLoadAndTestsForVersion:loads:						reasonCode: #testDeprecation.					ex return: false ].			cleanTests				ifTrue: [ MetacelloCleanLoadAndTestsNotification signal: version ]				ifFalse: [ MetacelloCleanLoadNotification signal: version ] ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!validateProjectLoad	| issues project versions currentVersion collectedIssues |	(issues := self validateProject select: [ :issue | issue isError ]) notEmpty		ifTrue: [ ^ issues ].	project := self configurationClass project.	collectedIssues := issues.	versions := project versions		select: [ :version | 			validationReport := nil.			version blessing ~~ #broken				and: [ 					version blessing ~~ #baseline						and: [ (issues := (self validateProject: project version: version versionString) select: [ :issue | issue isCritical ]) isEmpty ] ] ].	validationReport := collectedIssues.	versions isEmpty		ifTrue: [ 			self				recordValidationCriticalWarning: 'No non #baseline versions  available  in ' , self configurationClass name asString				callSite: #validateProjectLoad				reasonCode: #noLoadableVersions.			^ self validationReport ].	(currentVersion := project currentVersion) ~~ nil		ifTrue: [ 			| index |			index := versions indexOf: currentVersion.			versions := versions copyFrom: index to: versions size ].	versions do: [ :version | self validateCleanLoadAndTestsForVersion: version loads: #('ALL') ].	^ self validationReport! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!validateProjectVersionLoad: versionString loads: loadList	| issues project version |	(issues := (self validateProjectVersion: versionString) select: [ :issue | issue isError ]) notEmpty		ifTrue: [ ^ issues ].	project := self configurationClass project.	version := project		version: versionString		ifAbsent: [ 			self				recordValidationError: 'Version ' , versionString printString , ' does not exist.'				callSite: #validateProjectVersionLoad:loads:				reasonCode: #cannotResolveVersion.			^ self validationReport ].	version blessing = #broken		ifTrue: [ self error: 'The specified version is #broken' ].	self validateCleanLoadAndTestsForVersion: version loads: loadList.	^ self validationReport! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!validateVersionLoad: version loads: loadList	| list |	list := loadList asOrderedCollection.	list isEmpty		ifTrue: [ list add: 'default' ].	(version groups includes: 'Tests')		ifTrue: [ list add: 'Tests' ].	version load: list! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:53:29'!validateVersionSpec: versionSpec  versionSpec blessing value == #'broken'    ifTrue: [ ^ self ].  versionSpec    projectDo: [ :projectSpec |       | referencedProjectSpec |      projectSpec versionString == nil        ifTrue: [           self            recordValidationCriticalWarning:              'No version specified for the project reference ' , projectSpec name printString                , ' in version ' , versionSpec versionString printString            versionString: versionSpec versionString            callSite: #'validateVersionSpec:'            reasonCode: #'noVersionSpecified' ].      referencedProjectSpec := projectSpec referencedSpec.      versionSpec blessing value == #'baseline'        ifTrue: [           referencedProjectSpec hasRepository            ifTrue: [               (referencedProjectSpec file beginsWith: referencedProjectSpec className)                ifFalse: [                   self                    recordValidationCriticalWarning:                      'The class name of project ' , referencedProjectSpec className printString                        , ' does not match the file name '                        , referencedProjectSpec file printString                        , ' in version ' , versionSpec versionString printString                    versionString: versionSpec versionString                    callSite: #'validateVersionSpec:'                    reasonCode: #'projectClassNameFileMismatch' ] ]            ifFalse: [               self                recordValidationError:                  'The specification for the project reference ' , projectSpec name printString                    , ' in version ' , versionSpec versionString printString                    , ' is missing the required repository field'                versionString: versionSpec versionString                callSite: #'validateVersionSpec:'                reasonCode: #'incompleteProjectSpec' ] ].      referencedProjectSpec ensureProjectLoaded        ifTrue: [           [ projectSpec version ]            on: MetacelloVersionDoesNotExistError            do: [ :ex |               | explanation |              explanation := projectSpec versionString == nil                ifTrue: [ 'the default version' ]                ifFalse: [ 'version ' , projectSpec versionString printString ].              self                recordValidationError:                  'Cannot resolve ' , explanation , ' for the project reference '                    , projectSpec name printString , ' in version '                    , versionSpec versionString printString                versionString: versionSpec versionString                callSite: #'validateVersionSpec:'                reasonCode: #'cannotResolveVersion' ] ] ]    packageDo: [ :packageSpec |       (packageSpec file beginsWith: packageSpec name)        ifFalse: [           self            recordValidationCriticalWarning:              'The name of package ' , packageSpec name printString                , ' does not match the file name '                , packageSpec file printString , ' in version '                , versionSpec versionString printString            versionString: versionSpec versionString            callSite: #'validateVersionSpec:'            reasonCode: #'packageNameMismatch' ].      packageSpec file = packageSpec name        ifTrue: [           self            recordValidationCriticalWarning:              'No version specified for the package ' , packageSpec name printString                , ' in version ' , versionSpec versionString printString            versionString: versionSpec versionString            callSite: #'validateVersionSpec:'            reasonCode: #'noVersionSpecified' ] ]    groupDo: [ :ignored |  ].  self validateBaselineVersionSpec: versionSpec! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:53:29'!validateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString	| blessing |	versionSpec blessing value == #broken		ifTrue: [ ^ self ].	blessing := versionSpec blessing value.	(symbolicVersionString == #development and: [ blessing ~~ #development ])		ifTrue: [ 			self				recordValidationWarning:					'Symbolic version ' , symbolicVersionString printString , ' refers to a version' , versionSpec versionString printString						, ' whose blessing ' , blessing printString , ' is not #development'				versionString: versionSpec versionString				callSite: #validateVersionSpecForSymbolicVersion:symbolicVersion:				reasonCode: #notDevelopmentVersion ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!validateVersionTests: version	| testCases cleanTests |	testCases := IdentitySet new.	cleanTests := true.	version currentlyLoadedClassesInVersion		do: [ :class | 			((class inheritsFrom: TestCase) and: [ class isAbstract not ])				ifTrue: [ testCases add: class ] ].	testCases		do: [ :testCase | 			| testResults |			testResults := testCase suite run.			testResults defects notEmpty				ifTrue: [ 					self						recordValidationError:							'Test failures in tests ' , testCase name asString , ' for ' , version versionString printString , ' in '								, self configurationClass name asString , ' ' , testResults printString						versionString: version versionString						callSite: #validateVersionTests:						reasonCode: #testFailures.					cleanTests := false ] ].	testCases isEmpty		ifTrue: [ 			self				recordValidationCriticalWarning:					'No test cases for ' , version versionString printString , ' in ' , self configurationClass name asString				versionString: version versionString				callSite: #validateVersionTests:				reasonCode: #noTests.			cleanTests := false ].	^ cleanTests! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:53:29'!warningReasonCodes	^ super warningReasonCodes, #(#loadWarning #notDevelopmentVersion #stableDevelopmentVersion)! !!MetacelloVersionValidator class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!descriptionForReasonCode: reasonCode	^ self reasonCodeDescriptions at: reasonCode ifAbsent: [ self error: 'Unknown reasonCode: ' , reasonCode printString ]! !!MetacelloVersionValidator class methodsFor: 'private' stamp: '9/28/2017 08:54:38'!populateReasonCodeDescriptions    "update MetacelloMCVersionValidator class comment to include any changes to descriptions"    | dict |    dict := Dictionary new.    dict        at: #'onlyBaselineVersion'        put: 'one or more baseline versions have been defined, but no non-baseline versions are defined.'.    dict        at: #'duplicateVersionDefinitions' put: 'there are multiple pragma methods specifying the same version.';        at: #'packageNameMismatch' put: 'the name in the packageSpec does not match the name of the mcz file.';        at: #'projectClassNameFileMismatch'            put: 'the class name of the configuration does not match the mcz file containing the configuration.';        at: #'cannotResolveVersion'            put: 'the version (project reference or symbolic version) was not found in the specified configuration.'.    dict        at: #'duplicateNames'            put: 'multiple independent definitions for an entity with same name (project, package, or group).';        at: #'incompleteProjectSpec' put: 'missing required fields in project reference (repository, className).';        at: #'incorrectVersionString' put: 'the version declared in pragma doesn''t match version in versionSpec.';        at: #'invalidDoItSelector' put: 'doit select must be a Symbol.';        at: #'invalidVersionString' put: 'versionString must be a String.';        at: #'missingVersionImport' put: 'version specified in import pragma not defined in configuration.';        at: #'noVersionsDefined'            put: 'no usable baseline or version defined in configuration ... configuration cannot be loaded.';        at: #'projectCreationError' put: 'error occured while resolving project reference.';        at: #'versionCreationError'            put:                'error occured while resolving version specification, error will be thrown if an attempt is made to use the version.';        at: #'shadowedNames' put: 'name duplication between packages and projects.';        at: #'versionCompositionError' put: 'error while creating versionSpec from pragmas.'.    ^ dict! !!MetacelloVersionValidator class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!reasonCodeDescriptions	reasonCodeDescriptions ifNil: [ reasonCodeDescriptions := self populateReasonCodeDescriptions ].	^reasonCodeDescriptions! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateBaseline: baselineClass  ^ self validateBaseline: baselineClass debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateBaseline: baselineClass debug: debugList recurse: aBool  ^ (self new    configurationClass: baselineClass;    debug: debugList;    recurse: aBool;    yourself) validateBaselineOf! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateBaseline: baselineClass recurse: aBool  ^ self validateBaseline: baselineClass debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateConfiguration: configurationClass	^self validateConfiguration: configurationClass debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateConfiguration: configurationClass debug: debugList recurse: aBool	^ ((self new)		configurationClass: configurationClass;		debug: debugList;		recurse: aBool;		yourself) validate! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateConfiguration: configurationClass recurse: aBool	^self validateConfiguration: configurationClass debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject	^self validateProject: aMetacelloProject debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject debug: debugList recurse: aBool	^ ((self new)		recurse: aBool;		debug: debugList;		configurationClass: aMetacelloProject configuration class;		yourself) validateProject: aMetacelloProject! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject recurse: aBool	^self validateProject: aMetacelloProject debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject version: versionString	^self validateProject: aMetacelloProject version: versionString debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject version: versionString debug: debugList	^self validateProject: aMetacelloProject version: versionString debug: debugList recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool	^ ((self new)		configurationClass: aMetacelloProject configuration class;		debug: debugList;		recurse: aBool;		yourself) validateProject: aMetacelloProject version: versionString! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool visited: visitied	^(self new		configurationClass: aMetacelloProject configuration class;		debug: debugList;		recurse: aBool;		visited: visitied;		yourself) validateProject: aMetacelloProject version: versionString! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationClass	^ configurationClass! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationClass: anObject	configurationClass := anObject! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!criticalWarningReasonCodes    ^ #(#'packageNameMismatch' #'projectClassNameFileMismatch' #'duplicateVersionDefinitions')! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!debug	debug == nil ifTrue: [ debug := #() ].	^ debug! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!debug: aCollection	"Any combination of: #error, #criticalWarning, #warning"	debug := aCollection! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!errorReasonCodes    ^ #(#'duplicateNames' #'shadowedNames' #'invalidDoItSelector' #'invalidVersionString' #'missingVersionImport' #'projectCreationError' #'noVersionsDefined' #'cannotResolveVersion' #'incompleteProjectSpec' #'incorrectVersionString' #'versionCompositionError' #'versionCreationError')! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!exludededValidations	exludededValidations == nil ifTrue: [ exludededValidations := self extractExcludedValidations ].	^exludededValidations! !!MetacelloVersionValidator methodsFor: 'pragma extraction' stamp: '9/28/2017 08:54:38'!extractExcludedValidations	| exclusionDict |	exclusionDict := Dictionary new.	(Pragma 		allNamed: #excludedValidationIssues:		in: self configurationClass) do: [:pragma | | exclusions |			exclusions := pragma argumentAt: 1.			1 to: exclusions size by: 2 do: [:index |			exclusionDict 				at: (exclusions at: index) 				put: (exclusions at: index + 1) ]].	^exclusionDict! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recordValidationCriticalWarning: aString callSite: callSite reasonCode: aSymbol	^self recordValidationCriticalWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recordValidationCriticalWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#packageNameMismatch		#projectClassNameFileMismatch		#duplicateVersionDefinitions		#duplicateAttributeBlocks	"	(self criticalWarningReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown critical warning reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #criticalWarning) ifTrue: [ self halt: 'Debug triggered for critical warning: ', aString ].	self validationReport		add:			(MetacelloValidationCriticalWarning				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recordValidationError: aString callSite: callSite reasonCode: aSymbol	^self recordValidationError: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recordValidationError: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#noVersionForSymbolicVersion		#duplicateNames		#shadowedNames		#invalidDoItSelector		#invalidVersionString		#missingVersionImport		#projectCreationError		#noVersionsDefined		#cannotResolveVersion		#incompleteProjectSpec		#incorrectVersionString	"	(self errorReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown error reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #error) ifTrue: [ self halt: 'Debug triggered for error: ', aString ].	self validationReport		add:			(MetacelloValidationError				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recordValidationWarning: aString callSite: callSite reasonCode: aSymbol					^self recordValidationWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recordValidationWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#onlyBaselineVersion		#noVersionSpecified	"	(self warningReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown warning reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #warning) ifTrue: [ self halt: 'Debug triggered for critical warning: ', aString ].	self validationReport		add:			(MetacelloValidationWarning				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recurse	recurse == nil ifTrue: [ recurse := false ].	^ recurse! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!recurse: anObject	recurse := anObject! !!MetacelloVersionValidator methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validate	"Issue 5: 		[]no shadowing of names across project/package/group boundaries	 Issue 6: 		[]package version supplied for each package		[]no released (stable/bleedingEdge) versions (only development version)		package spec used instead of project spec in baseline (ConfigurationOfPharo-DaleHenrichs.50)	Issue 20:		[]pre and post load doits must be symbols, not blocks	Others:		[]symbolic versions can be resolved.		[]Ensure that versions are Strings and symbolic versions are symbols.	 	[]Ensure that imported versions are defined."	self validatePragmas.	^self validateProject! !!MetacelloVersionValidator methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validateBaselineOf  self validatePragmas.  ^ self validateBaselineProject! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateBaselineProject  | project |  project := self    validateProjectCreationFrom: self configurationClass    onError: [ :ex |       self        recordValidationError:          'Error creating project: ' , ex description            , ' to reproduce evalutate the following: '''            , self configurationClass name asString , ' project'''        callSite: #'validateBaselineProject'        reasonCode: #'projectCreationError'.      ^ self validationReport ].  ^ self validateBaselineProject: project! !!MetacelloVersionValidator methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validateBaselineProject: project  | version spec |  (self visited includes: project configuration class)    ifTrue: [ ^ self validationReport ].  self visited add: project configuration class.  version := project version.  spec := version spec.  [ self validateBaselineVersionSpec: spec ]    on: Error    do: [ :ex |       self        recordValidationError:          'Error composing version ' , version versionString printString , ': '            , ex description        versionString: version versionString        callSite: #'validateBaselineProject:'        reasonCode: #'versionCompositionError' ].  ^ self validationReport! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateBaselineVersionSpec: versionSpec	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateDoIts: aSpec versionString: versionString errorMessage: errorMessage	| ar |	ar := {		#preLoadDoIt.	'preLoadDoIt selector for '.		#postLoadDoIt.	'postLoadDoIt selector for '.	}.	1 to: ar size by: 2 do: [ :i | 		| selector |		selector := (aSpec perform: (ar at: i)) value.		selector ~~ nil			ifTrue: [ 				selector isSymbol					ifFalse: [ 						self							recordValidationError: (ar at: i + 1) , errorMessage , ' is not a symbol'							versionString: versionString							callSite: #validateDoIts:versionString:errorMessage:							reasonCode: #invalidDoItSelector ] ] ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validatePragmas    "Ensure that versions are Strings and symbolic versions are symbols.	 Ensure that imported versions are defined"    | versionPragmas versionImportPragmas symbolicVersionPragmas versionStrings |    versionPragmas := self extractVersionPragmas.    versionImportPragmas := self extractVersionImportPragmas.    symbolicVersionPragmas := self extractSymbolicVersionPragmas.    versionStrings := Set new.    versionPragmas keys , versionImportPragmas keys , symbolicVersionPragmas keys        do: [ :versionString |             (versionStrings includes: versionString)                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ]                ifFalse: [ versionStrings add: versionString ] ].    versionPragmas        keysAndValuesDo: [ :versionString :pragmaList |             versionString isString                ifFalse: [                     self                        recordValidationError: 'version ' , versionString printString , ' is not a String.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'invalidVersionString' ].            pragmaList size > 1                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ] ].    symbolicVersionPragmas        keysAndValuesDo: [ :versionString :pragmaList |             versionString isSymbol                ifFalse: [                     self                        recordValidationError: 'symbolic version ' , versionString printString , ' is not a Symbol.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'invalidVersionString' ].            pragmaList size > 1                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ] ].    versionImportPragmas        keysAndValuesDo: [ :versionString :pragmaList |             versionString isString                ifFalse: [                     self                        recordValidationError: 'version ' , versionString printString , ' is not a String.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'invalidVersionString' ].            pragmaList size > 1                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ].            pragmaList                do: [ :versionImportPragma |                     (versionImportPragma arguments at: 2)                        do: [ :importedVersionString |                             (versionStrings includes: importedVersionString)                                ifFalse: [                                     self                                        recordValidationError:                                            'version ' , importedVersionString printString , ' referenced in import list of version ' , versionString printString                                                , ' has not been defined.'                                        versionString: versionString                                        callSite: #'validatePragmas'                                        reasonCode: #'missingVersionImport' ] ] ] ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateProject	| project |	project := self		validateProjectCreationFrom: self configurationClass		onError: [ :ex | 			self				recordValidationError:					'Error creating project: ' , ex description , ' to reproduce evalutate the following: '''						, self configurationClass name asString , ' project'''				callSite: #validateProject				reasonCode: #projectCreationError.			^ self validationReport ].	^ self validateProject: project! !!MetacelloVersionValidator methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validateProject: project	| hasNoBaseline hasNoVersion |	(self visited includes: project configuration class)		ifTrue: [ ^ self validationReport ].	self visited add: project configuration class.	hasNoBaseline := hasNoVersion := true.	project versions		do: [ :version | 			| spec |			spec := version spec.			[ 			spec blessing value == #baseline				ifTrue: [ 					hasNoBaseline := false.					self validateBaselineVersionSpec: spec ]				ifFalse: [ 					hasNoVersion := false.					self validateVersionSpec: spec ] ]				on: Error				do: [ :ex | 					self						recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description						versionString: version versionString						callSite: #validateProject:						reasonCode: #versionCompositionError ] ].	project symbolicVersionMap keys		do: [ :symbolicVersion | 			| version |			version := [ project version: symbolicVersion ]				on: Error , MetacelloSymbolicVersionNotDefinedError				do: [ :ex | 					"MetacelloSymbolicVersionNotDefinedError are explicitly not defined, so are not validation errors"					(ex isKindOf: MetacelloSymbolicVersionNotDefinedError)						ifFalse: [ 							self								recordValidationError:									'symbolic version ' , symbolicVersion printString , ' does not resolve to a literal version.'								callSite: #validatePragmas								reasonCode: #cannotResolveVersion ].					ex return: nil ].			version ~~ nil				ifTrue: [ self validateVersionSpecForSymbolicVersion: version spec symbolicVersion: symbolicVersion ] ].	hasNoVersion		ifTrue: [ 			hasNoBaseline				ifTrue: [ 					self						recordValidationError: 'No usable baseline or versions defined.'						callSite: #validatePragmas						reasonCode: #noVersionsDefined ]				ifFalse: [ 					self						recordValidationWarning: 'Only baseline defined (no version defined).'						callSite: #validatePragmas						reasonCode: #onlyBaselineVersion ] ].	^ self validationReport! !!MetacelloVersionValidator methodsFor: 'validation' stamp: '9/28/2017 08:54:38'!validateProject: project version: versionString	| version spec |	(self visited includes: project configuration class)		ifTrue: [ ^ self validationReport ].	self visited add: project configuration class.	[ version := project version: versionString ]		on: Error		do: [ :ex | 			self				recordValidationError: 'Could not resolve version ' , versionString printString , ' due to error: ' , ex description				versionString: versionString				callSite: #validateProject:version:				reasonCode: #cannotResolveVersion.			^ self validationReport ].	spec := version spec.	[ 	spec blessing value == #baseline		ifTrue: [ self validateBaselineVersionSpec: spec ]		ifFalse: [ self validateVersionSpec: spec ] ]		on: Error		do: [ :ex | 			self				recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description				versionString: version versionString				callSite: #validateProject:version:				reasonCode: #versionCompositionError ].	^ self validationReport! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateProjectCreationFrom: aConfigurationClass onError: aBlock    [ ^ aConfigurationClass project ]        on: Error , MetacelloValidationNotification , MetacelloErrorInProjectConstructionNotification        do: [ :ex |             (ex isKindOf: MetacelloValidationNotification)                ifTrue: [                     self validationReport add: ex issue.                    ex resume ].            (ex isKindOf: MetacelloErrorInProjectConstructionNotification)                ifTrue: [                     self                        recordValidationError:                            'Error creating version: ' , ex versionString , ' error: ' , ex exception description                                , ' to reproduce evalutate the following: ''[' , self configurationClass name asString                                ,                                    ' project ] on: MetacelloErrorInProjectConstructionNotification do: [:ex | ex resume: true ]'''                        callSite: #'validateProjectCreationFrom:onError:'                        reasonCode: #'versionCreationError'.                    ex resume: false ].            ^ aBlock value: ex ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateProjectVersion: versionString	| project |	project := self		validateProjectCreationFrom: self configurationClass		onError: [ :ex | 			self				recordValidationError:					'Error creating project: ' , ex description , ' to reproduce evalutate the following: '''						, self configurationClass name asString , ' project'''				callSite: #validateProject				reasonCode: #projectCreationError.			^ self validationReport ].	^ self validateProject: project version: versionString! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateVersionSpec: versionSpec	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!validateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!validationReport		validationReport == nil ifTrue: [ validationReport := OrderedCollection new ].	^ validationReport! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!validationReport: anObject	validationReport := anObject! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!visited	visited == nil ifTrue: [ visited := IdentitySet new ].	^visited! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!visited: anIdentitySet	visited := anIdentitySet! !!MetacelloVersionValidator methodsFor: 'private' stamp: '9/28/2017 08:54:38'!warningReasonCodes	^ #(#onlyBaselineVersion )! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #'ConfigurationOf'		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #'ConfigurationOf' ifAbsent: aBlock ].! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!ensureMetacelloBaseConfiguration  Smalltalk    at: #'ConfigurationOf'    ifAbsent: [       | repository version |      repository := MCHttpRepository        location: 'http://smalltalkhub.com/mc/dkh/metacello/main'        user: ''        password: ''.      repository        versionReaderForFileNamed: 'Metacello-Base-dkh.107'        do: [ :reader |           version := reader version.          version load.          version workingCopy repositoryGroup addRepository: repository ] ]! !!MetacelloConfigTemplate class methodsFor: 'metacello tool support' stamp: '9/28/2017 08:53:29'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!MetacelloConfigTemplate class methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!project	^self new project! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!MetacelloConfigTemplate methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!MetacelloConfigTemplate methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := MetacelloMCProject new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!MetacelloConfigTemplateExample class methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: '9/28/2017 08:53:29'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!MetacelloConfigTemplateExample class methodsFor: 'metacello tool support' stamp: '9/28/2017 08:53:29'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!MetacelloConfigTemplateExample class methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!MetacelloConfigTemplateExample class methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!MetacelloConfigTemplateExample class methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!MetacelloConfigTemplateExample class methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!project	^self new project! !!MetacelloConfigTemplateExample class methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!MetacelloConfigTemplateExample methodsFor: 'baselines' stamp: '9/28/2017 08:53:29'!baseline10: spec	"Baselines are used by convention in Metacello and essentially are nothing else than normal versions.	Name the baseline after the first version it was introduced.	In this case 1.0-baseline was introduced the first time with the 1.0 version defined in the #version10 method.	Metacello only uses the following tag to figure out the name of this baseline:"	<version: '1.0-baseline'>	"Using #common makes this dependency declaration available for all Smalltalks.	If you need more fine-grained control you can add several #for:do: sections for other releases."	spec for: #common do: [			spec blessing: #baseline.		"specify the default repository for your project's packages"		spec repository: 'http://smalltalkhub.com/mc/JohnDoe/MyProject/main'.			"use separate methods for external projects"		self 			fuelMetalevel: spec;			fileSystemLegacy: spec.				"specify the dependencies between packages and projects"		spec			"a package without dependencies:"			package: 'MyProject-Core';			package: 'MyProject-Tests' with: [ 				"Specfiy dependencies using the #requires: directive, you can refer to any name here, in this case to an external project"				spec requires: #('MyProject-Core' 'FuelMetalevel' 'FileSystemLegacy')].					"using groups certain packages and projects can be loaded conditionally"		spec 			"load the tests by default"			group: 'default' with: #('core' 'test');			group: 'test'    with: #('MyProject-Tests');			group: 'core'    with: #('MyProject-Core')]! !!MetacelloConfigTemplateExample methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!MetacelloConfigTemplateExample methodsFor: 'tags' stamp: '9/28/2017 08:53:29'!development: spec	"By convention the development branch should point to a fixed version that is regularly updated and might contain unstable code.	The name used by Metacello is only defined by the following pragma:"	<symbolicVersion: #development >		"For the development tag refer to a fixed version which you update if you commit new code.	Note that you can refer here to any other version name from this configuration"	spec for: #'common' version: 'dev'.! !!MetacelloConfigTemplateExample methodsFor: 'external projects' stamp: '9/28/2017 08:53:29'!fileSystemLegacy: spec	"This is an example of an external project which does not have a configuration yet.	Note that the package name is only used in the Metacello configuration and does not have be exactly the same as the Monticello project/version name."	spec package: 'FileSystemLegacy' with: [		spec 			repository: 'http://smalltalkhub.com/mc/PharoExtras/FileSystemLegacy/main';			"if you do not specify a version, automatically the newest version is chose."			file:  'FileSystem-Legacy-JohanBrichau.2' ]! !!MetacelloConfigTemplateExample methodsFor: 'external projects' stamp: '9/28/2017 08:53:29'!fuelMetalevel: spec	"Specify a dependency on an external project which has it's own configuration.	The given project name can be chosen freely, for simplicity use the same name as the configuration or the conditional group you load."	spec project: 'FuelMetalevel' with: [		spec 			repository: 'http://ss3.gemstone.com/ss/Fuel';			className: 'ConfigurationOfFuel';			"if you want to load by default a special group usse the #loads: message plus a group name of the external configuration"			loads: #FuelMetalevel ].! !!MetacelloConfigTemplateExample methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!MetacelloConfigTemplateExample methodsFor: 'tags' stamp: '9/28/2017 08:53:29'!stable: spec	"Symbolic versions can be used to introduce an indirection to a version number.	The real name used by Metacello is only defined by the following pragma:"	<symbolicVersion: #stable >		"If another version is stable for a differen Smalltalk use a specific name"	"spec for: #'pharo1.4.x' version: '0.9'"		"Specfiy which exact version you want to load"	spec for: #'common' version: '1.0'.! !!MetacelloConfigTemplateExample methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!version10: spec	"The name for this version is solely defined by the following pragma:"	<version: '1.0' imports: #('1.0-baseline') >	"Baselines are used to define more complex setups for your project.	If you want to use external projects and have fine-graind control of the dependencies between packages use the #imports: part.	See the #baseline10: for more details."		"Using #for:do: with the #common release specifier the following version declaration is valid for all platforms."	spec for: #common do: [		spec 			description: 'Version 1.0 the current stable release';			blessing: #release;			author: 'John Doe';			timestamp: '2013-05-01'.				"Specify the versions for each package and external project defined in the baseline, here the 1.0-baseline defined in the baseline10 method."		spec			"For standard Monticello packages simply refere to the full version name without the extension:"			package: 'MyProject-Core'  with: 'MyProject-Core-JohnDoe.52';			package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.73';						"External projects versions are specified using #project:with:.			Note the project name referes to the name used in the Metacello declaration.			FuelMetalevel is defined in the #fuelMetalevel: method."			project: 'FuelMetalevel' with: #stable ].			"If you want to specify different version on other platforms add another #for:do: block with a different version identifier."! !!MetacelloConfigTemplateExample methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!versionDevelopment: spec	"version specification for the current development branch, see #version10 for a complete explanation of a version declaration.	In this case the 'dev' version uses the same baselin as version '1.0':"	<version: 'dev' imports: #('1.0-baseline') >		"Update this configuration regulrarly with intermediate releases.	If a version is more stable or should stay accessible copy this 'dev' definition and give it a proper version name on its own.	For example, in this case you might want to split a new version '1.1' by copying over this definition."	spec for: #common do: [		spec 			description: 'Development Version';			blessing: #development;			author: 'John Doe';			timestamp: '2013-05-09'.				spec			package: 'MyProject-Core'  with: 'MyProject-Core-JohnDoe.152';			package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.173';			"note that for the 'dev' version we rely on the #development version of the external FuleMetalevel project"			project: 'FuelMetalevel'   with: #development ].! !!MetacelloDirective class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!loadPackage: aPackageSpec externalReference: externalReference loader: aLoader	^MetacelloPackageLoadDirective new		spec: aPackageSpec externalReference: externalReference  loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!loader: aLoader	^self new		loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!postLoadSpec: packageOrVersionSpec loader: aLoader	^MetacelloPostLoadDirective new		spec: packageOrVersionSpec loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!preLoadSpec: packageOrVersionSpec loader: aLoader	^MetacelloPreLoadDirective new		spec: packageOrVersionSpec loader: aLoader! !!MetacelloDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!addTo: aLoaderDirective	aLoaderDirective add: self! !!MetacelloDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!directivesDo: aBlock	aBlock value: self! !!MetacelloDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!label	^self spec label! !!MetacelloDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	self subclassResponsibility! !!MetacelloDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loader	^loader! !!MetacelloDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loader: aLoader	loader := aLoader! !!MetacelloDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!packageDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!packageDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!postLoadDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!preLoadDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadDo: aBlock! !!MetacelloDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!printOn: aStream	self printOn: aStream indent: 0! !!MetacelloDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!printOn: aStream indent: indent	indent timesRepeat: [ aStream tab ].	aStream		nextPutAll: self title;		nextPutAll: ' : ';		nextPutAll: self label.! !!MetacelloDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!printString	"Explicit override of superclass implementation. When you are printing a loadDirective it is annoying to have it truncated."	^String streamContents: [:s | self printOn: s]! !!MetacelloDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!spec	^spec! !!MetacelloDirective methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:29'!spec: packageOrVersionSpec loader: aLoader	spec := packageOrVersionSpec.	loader := aLoader! !!MetacelloDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	self subclassResponsibility! !!MetacelloDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!versionDirectivesDepthFirstDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!versionDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!versionDo: aBlock! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!externalReference	^ externalReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!file	^self externalReference name! !!MetacelloPackageLoadDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!label	^self file! !!MetacelloPackageLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPackageDirective: self gofer: aGofer! !!MetacelloPackageLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!packageDirectivesDo: aBlock	aBlock value: self! !!MetacelloPackageLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!packageDo: aBlock	aBlock value: self! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packageName	^self externalReference packageName! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repository	^self externalReference repository! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!resolvedReference	^ resolvedReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!resolvedReference: anObject	resolvedReference := anObject! !!MetacelloPackageLoadDirective methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:29'!spec: aPackageSpec externalReference: anExternalReference loader: aLoader	super spec: aPackageSpec loader: aLoader.	externalReference := anExternalReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	^'load'! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!addTo: aLoaderDirective	spec postLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]! !!MetacelloPostLoadDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!label	^super label, ' >> ', self spec postLoadDoIt value asString! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPostloadDirective: self.! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!postLoadDo: aBlock	aBlock value: self! !!MetacelloPostLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	^'postload'! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!addTo: aLoaderDirective	spec preLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]! !!MetacelloPreLoadDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!label	^super label, ' >> ', self spec preLoadDoIt value asString! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPreloadDirective: self.! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!preLoadDo: aBlock	aBlock value: self! !!MetacelloPreLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	^'preload'! !!MetacelloPrePostLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!evaluateSupplyingAnswers: loadBlock	| answers |	(answers := self spec answers) notEmpty		ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]		ifFalse: [ loadBlock value]! !!MetacelloPrePostLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadDirectivesDo: aBlock	aBlock value: self! !!MetacelloPrePostLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadDo: aBlock	aBlock value: self! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!directivesDo: aBlock	aBlock value: self.	self preloads do: [:directive | directive directivesDo: aBlock ].	self loadDirectives do: [:directive | directive directivesDo: aBlock ].	self postloads do: [:directive | directive directivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!finalizeLoad: aGofer	"load the accumulated packages (if any), reset the package list"	| pkgLoads |	self preloads do: [:directive | super loadPreloadDirective: directive ].	preloads := nil.	(pkgLoads := self packageloads) notEmpty 		ifTrue: [			self loader loadingSpecLoader 				loadPackageDirectives: pkgLoads 				gofer: aGofer.			self packageloads: nil ].	self postloads do: [:directive | super loadPostloadDirective: directive ].	postloads := nil! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: self gofer: aGofer ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadLinearLoadDirective: aLoaderDirective gofer: aGofer	self finalizeLoad: aGofer.	super loadLinearLoadDirective: aLoaderDirective gofer: aGofer! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	"accumulate packages"		self packageloads add: aPackageLoadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadPostloadDirective: aPostloadDirective	"accumulate postloads"	self postloads add: aPostloadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadPreloadDirective: aPreloadDirective 	"accumulate preloads"	self preloads add: aPreloadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadAtomicLoadDirective: self gofer: aGofer.! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packageloads	packageloads == nil ifTrue: [ packageloads := OrderedCollection new ].	^ packageloads! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packageloads: anObject	packageloads := anObject! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!postloads	postloads == nil ifTrue: [ postloads := OrderedCollection new ].	^ postloads! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!preloads	preloads == nil ifTrue: [ preloads := OrderedCollection new ].	^ preloads! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadDirectivesDo: aBlock	self preloads do: [:directive | directive prepostLoadDirectivesDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDirectivesDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDirectivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadsDo: aBlock	self preloads do: [:directive | directive prepostLoadDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	^'atomic load'! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!explicitLoadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!explicitLoadWithPolicy: aLoadPolicy	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	gofer repository: aLoadPolicy cacheRepository.	self explicitLoadUsing: self gofer: gofer! !!MetacelloExplicitLoadDirective methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isExplicit	^true! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadExplicitLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	^'explicit load'! !!MetacelloLinearLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloLinearLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!title	^'linear load'! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!add: aDirective	self loadDirectives add: aDirective! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!directivesDo: aBlock	aBlock value: self.	self loadDirectives do: [:directive | directive directivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!finalizeLoad: aGofer	"nothing special for linear loads"! !!MetacelloVersionLoadDirective methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isExplicit	^false! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!label	self spec == nil ifTrue: [ ^'' ].	^self spec label! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: aLoaderDirective gofer: aGofer ].	aLoaderDirective finalizeLoad: aGofer.! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadDirectives	loadDirectives == nil ifTrue: [ loadDirectives := OrderedCollection new ].	^ loadDirectives! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadDirectives: anObject	loadDirectives := anObject! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadExplicitLoadDirective: aLoaderDirective gofer: aGofer	"load has already been performed, no need to load again"! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadLinearLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: aLoaderDirective gofer: aGofer ].	aLoaderDirective finalizeLoad: aGofer.! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	aPackageLoadDirective loader loadingSpecLoader 		loadPackageDirective: aPackageLoadDirective 		gofer: aGofer! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadPostloadDirective: aPostloadDirective 	| block |	(block :=  aPostloadDirective spec postLoadDoItBlock) ~~ nil		ifTrue: [			aPostloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: 					(Array 						with: aPostloadDirective loader 						with: aPostloadDirective spec) ].			Transcript cr; show: 'Evaluated -> ', aPostloadDirective spec label, ' >> ', aPostloadDirective spec postLoadDoIt value asString]! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadPreloadDirective: aPreloadDirective 	| block |	(block :=  aPreloadDirective spec preLoadDoItBlock) ~~ nil		ifTrue: [			aPreloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: 					(Array 						with: aPreloadDirective loader 						with: aPreloadDirective spec) ].			Transcript cr; show: 'Evaluated -> ', aPreloadDirective spec label, ' >> ', aPreloadDirective spec preLoadDoIt value asString]! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadWithPolicy: aLoadPolicy	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	gofer repository: aLoadPolicy cacheRepository.	self loadUsing: self gofer: gofer! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!packageDirectivesDo: aBlock	self loadDirectives do: [:directive | directive packageDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!packagesDo: aBlock	self loadDirectives do: [:directive | directive packageDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadDirectivesDo: aBlock	self loadDirectives do: [:directive | directive prepostLoadDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!prepostLoadsDo: aBlock	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!printLoadDirectivesOn: aStream indent: indent	self loadDirectives do: [:each |		aStream cr. 		each printOn: aStream indent: indent + 1 ].! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!printOn: aStream indent: indent	super printOn: aStream indent: indent.	self printLoadDirectivesOn: aStream indent: indent! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!spec	"Expected to be a MetacelloVersionSpec"		(spec == nil  and: [  self loader ~~ nil ]) 		ifTrue: [ 			^[ self loader spec versionSpec ] 				on: MessageNotUnderstood				do: [:ex | ex return: self loader spec ]].	^spec! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!versionDirectivesDepthFirstDo: aBlock	self loadDirectives do: [:directive | directive versionDirectivesDepthFirstDo: aBlock ].	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!versionDirectivesDo: aBlock	aBlock value: self.	self loadDirectives do: [:directive | directive versionDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!versionDo: aBlock	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!versionsDo: aBlock	self loadDirectives do: [:directive | directive versionDo: aBlock ].! !!MetacelloLoadData methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!addVersion: version versionInfo: versionInfo resolvedReference: resolvedReference packageSpec: packageSpec	| vis |	"check for duplicates and use the one that is being added"	(vis := self packageNameMap at: packageSpec name ifAbsent: [  ]) ~~ nil		ifTrue: [ 			"remove old references"			vis				do: [ :vi | 					self dataMap removeKey: vi name.					self versionInfoMap removeKey: vi name ] ].	self dataMap		at: version info name		put:			{version.			resolvedReference.			packageSpec}.	self versionInfoMap at: versionInfo name put: {versionInfo}.	self packageNameMap at: packageSpec name put: {versionInfo}! !!MetacelloLoadData methodsFor: 'versionInfo' stamp: '9/28/2017 08:53:29'!ancestorsFor: packageSpec ifAbsent: aBlock	^self versionInfoMap 		at: packageSpec file 		ifAbsent: [ 			self  packageNameMap 				at: packageSpec name				ifAbsent: aBlock ]! !!MetacelloLoadData methodsFor: 'versionInfo' stamp: 'EstebanLorenzano 9/25/2017 10:44'!currentVersionInfoFor: packageSpec ifAbsent: aBlock	^self versionInfoMap 		at: packageSpec file 		ifPresent: [ :v | v first ]		ifAbsent: [ 			self  packageNameMap 				at: packageSpec name				ifPresent: [ :v | v first ]				ifAbsent: aBlock ]! !!MetacelloLoadData methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!dataMap	dataMap == nil ifTrue: [ dataMap := Dictionary new ].	^dataMap! !!MetacelloLoadData methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!do: aBlock	self dataMap valuesDo: [:ar |		aBlock value: (ar at: 1) value: (ar at: 2) value: (ar at: 3) ]! !!MetacelloLoadData methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isEmpty	^self dataMap isEmpty! !!MetacelloLoadData methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packageNameMap	packageNameMap == nil ifTrue: [ packageNameMap := Dictionary new ].	^packageNameMap! !!MetacelloLoadData methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!versionInfoMap	versionInfoMap == nil ifTrue: [ versionInfoMap := Dictionary new ].	^versionInfoMap! !!MetacelloLoaderPolicy class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!overrideRepositories: aCollection	^self new overrideRepositories: aCollection! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!cacheGofer	cacheGofer == nil 		ifTrue: [ 			"don't use a caching Gofer here, since we expect the contents to change during a fetch operation"			cacheGofer := Gofer new. 			cacheGofer disablePackageCache.			cacheGofer repository: self cacheRepository. ].	^ cacheGofer! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!cacheRepository	cacheRepository == nil ifTrue: [ cacheRepository := MCDictionaryRepository new ].	^ cacheRepository! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!cacheRepository: anMCRepository	cacheRepository := anMCRepository.	"getting a new repository, so wipe out the cacheGofer and ensureMap"	ensuredMap := cacheGofer := nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ensuredMap	ensuredMap == nil ifTrue: [ ensuredMap := Dictionary new ].	^ensuredMap! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ensuredMap: anObject	ensuredMap := anObject! !!MetacelloLoaderPolicy methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasRepositoryOverrides	^self overrideRepositories ~~ nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ignoreImage	^ ignoreImage! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ignoreImage: anObject	ignoreImage := anObject! !!MetacelloLoaderPolicy methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:29'!initialize	self 		repositoryMap; 		cacheRepository;		ensuredMap.	ignoreImage := false! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!load	overrideRepositories := Array with: self cacheRepository. "ensure that hasRepositoryOverrides is true"	self loadDirective loadWithPolicy: self! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadData 	loadData == nil ifTrue: [ loadData := MetacelloLoadData new ].	^loadData! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadDirective	loadDirective == nil ifTrue: [ loadDirective := MetacelloLinearLoadDirective new ].	^ loadDirective! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!overrideRepositories	^ overrideRepositories! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!overrideRepositories: anObject	overrideRepositories := anObject! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!pushAtomicLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloAtomicLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!pushExplicitLoadDirectivesDuring: aBlock for: aLoader	| directive |	directive := MetacelloExplicitLoadDirective loader: aLoader.	self pushLoadDirective: directive during: aBlock.	^directive! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!pushLinearLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloLinearLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'private' stamp: '9/28/2017 08:53:29'!pushLoadDirective: aLoaderDirective during: aBlock	|  oldRoot |	self loadDirective add: aLoaderDirective.	oldRoot := loadDirective.	loadDirective := aLoaderDirective.	aBlock ensure: [ loadDirective := oldRoot ].! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositoryMap	repositoryMap == nil ifTrue: [ repositoryMap := Dictionary new ].	^repositoryMap! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositoryMap: anObject	repositoryMap := anObject! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!resetCacheGofer	cacheGofer := nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!silently	silently == nil ifTrue: [ silently := false ].	^ silently! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!silently: anObject	silently := anObject! !!MetacelloMCPartiallyLoadedStatus class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!new	^ self basicNew initialize! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedPackageIsCurrent	^ aLoadedPackageIsCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedPackageIsCurrent: aBoolean	aLoadedPackageIsCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedPackageIsExact	^ aLoadedPackageIsExact! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedPackageIsExact: aBoolean	aLoadedPackageIsExact := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedPackageIsNotCurrent	^ aLoadedPackageIsNotCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedPackageIsNotCurrent: aBoolean	aLoadedPackageIsNotCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedProjectIsCurrent: aBoolean	aLoadedProjectIsCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedProjectIsExact	^ aLoadedProjectIsExact! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedProjectIsExact: aBoolean	aLoadedProjectIsExact := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedProjectIsNotCurrent	^ aLoadedProjectIsNotCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aLoadedProjectIsNotCurrent: aBoolean	aLoadedProjectIsNotCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aPackageIsLoaded	^aPackageIsLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aPackageIsLoaded: aBoolean	aPackageIsLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aPackageNotLoaded	^aPackageNotLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aPackageNotLoaded: aBoolean	aPackageNotLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aProjectIsLoaded	^aProjectIsLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aProjectIsLoaded: aBoolean	aProjectIsLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aProjectNotLoaded	^aProjectNotLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!aProjectNotLoaded: aBoolean	aProjectNotLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!abort	^ abort! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!abort: aBoolean	abort := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'evaulation' stamp: '9/28/2017 08:53:29'!evaluateStatus: validStatusList	^self abort		ifTrue: [ false ]		ifFalse: [ 			(self hasNoProject or: [ self vrsnStatus isEmpty ])				ifTrue: [ true ]				ifFalse: [ 					| valid |					valid := true.					vrsnStatus						do: [ :status | 							(validStatusList includes: status)								ifFalse: [ valid := false ] ].					valid ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!hasNoPackage	^ hasNoPackage! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!hasNoPackage: aBoolean	hasNoPackage := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!hasNoProject	^ hasNoProject! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!hasNoProject: aBoolean	hasNoProject := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'initialization' stamp: '9/28/2017 08:53:29'!initialize	super initialize.	hasNoPackage := hasNoProject := true.	aProjectIsLoaded := aPackageIsLoaded := false.	aLoadedProjectIsExact := aLoadedPackageIsExact := false.	aLoadedProjectIsCurrent := aLoadedPackageIsCurrent := false.	aLoadedProjectIsNotCurrent := aLoadedPackageIsNotCurrent := false.	aProjectNotLoaded := aPackageNotLoaded := false.	vrsnStatus := Set new.	abort := false! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isAllLoadedToSpec: matchBlock        "all projects and packages are loaded and match specification"	(self evaluateStatus: #(#allLoadedToSpec))		ifTrue: [ 			((hasNoPackage				or: [ 					aPackageIsLoaded & aPackageNotLoaded not & aLoadedPackageIsExact & aLoadedPackageIsNotCurrent not						& aLoadedPackageIsCurrent not ])				and: [ 					hasNoProject						or: [ 							aProjectIsLoaded & aProjectNotLoaded not & aLoadedProjectIsExact & aLoadedProjectIsNotCurrent not								& aLoadedProjectIsCurrent not ] ])				ifTrue: [ matchBlock value: #allLoadedToSpec ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isLoadedMatchConstraints: matchBlock	"all loaded projects and packages match constraints (at least one package loaded)"	| matchStatus |	matchStatus := #loadedMatchConstraints.	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints))		ifTrue: [ 			aPackageIsLoaded & aProjectIsLoaded				ifTrue: [ 					(aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not						and: [ aLoadedProjectIsExact | aLoadedProjectIsCurrent & aLoadedProjectIsNotCurrent not ])						ifTrue: [ matchBlock value: matchStatus ] ]				ifFalse: [ 					aPackageIsLoaded						ifTrue: [ 							aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ]						ifFalse: [ 							hasNoPackage & (aLoadedProjectIsExact | aLoadedProjectIsCurrent) & aLoadedProjectIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ] ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isLoadedToSpec: matchBlock	"all loaded projects and packages match specifications (at least one package loaded)"	| matchStatus |	matchStatus := #loadedToSpec.	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec))		ifTrue: [ 			aPackageIsLoaded & aProjectIsLoaded				ifTrue: [ 					(aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not						and: [ aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ])						ifTrue: [ matchBlock value: matchStatus ] ]				ifFalse: [ 					aPackageIsLoaded						ifTrue: [ 							aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ]						ifFalse: [ 							hasNoPackage & aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ] ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isSomethingLoaded: somethingLoadedBlock	"at least one package loaded"	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints #somethingLoaded))		ifTrue: [ 			aPackageIsLoaded				ifTrue: [ somethingLoadedBlock value: #somethingLoaded ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!vrsnStatus	^vrsnStatus! !!MetacelloMCVersionSpecLoader class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!on: aVersionSpec	^(self new) 		versionSpec: aVersionSpec;		yourself! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!label	^self versionSpec label! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!load  | mcLoader |  packages := Dictionary new.  self resolveToLoadableSpecs.  mcLoader := self loader.  packages values    do: [ :pkg |       pkg ensureLoadedForDevelopmentUsing: mcLoader.      (MetacelloIgnorePackageLoaded signal: pkg)        ifFalse: [           mcLoader ignoreImage            ifFalse: [               (pkg                compareCurrentVersion: self operator                targetVersionStatus: #(#'allLoadedToSpec')                using: mcLoader)                ifTrue: [ packages removeKey: pkg name ] ] ] ].  packages notEmpty    ifTrue: [       mcLoader preLoad: self versionSpec.      mcLoader load.      mcLoader postLoad: self versionSpec ].  ^ mcLoader! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loader	loader == nil 		ifTrue: [			loader := self versionSpec loader copy.			loader spec: self.			loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy] ].	^loader! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loaderPolicy	^ loaderPolicy! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!name	^self versionSpec name! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!operator	^self loader operator! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: '9/28/2017 08:53:29'!packageSpecsInLoadOrder    ^ self versionSpec packageSpecsInLoadOrderForMap: packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packages	^packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!project	^self versionSpec project! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!repositories	^self repositorySpecs! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: '9/28/2017 08:53:29'!repositorySpecs	| repositoryMap |	repositoryMap := self versionSpec repositories ~~ nil		ifTrue: [ self versionSpec repositories map ]		ifFalse: [ Dictionary new ].	^repositoryMap values.! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!required	required == nil ifTrue: [ ^#() ].	^ required! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!required: anObject	required := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!resolvePackageNames	packages := Dictionary new.	self resolveToLoadableSpecs.	^packages values collect: [:pkg | pkg name ]! !!MetacelloMCVersionSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolveToLoadableSpecs    self versionSpec resolveToLoadableSpecs: required forLoad: true map: packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!versionSpec	^ versionSpec! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!versionSpec: anObject	versionSpec := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: '9/28/2017 08:53:29'!versionString	^self versionSpec versionString! !!MetacelloMethodSection methodsFor: 'accessing' stamp: 'dkh 9/7/2012 10:45'!attribute    self deprecated: 'Use attributes instead'.    self attributes size > 1        ifTrue: [ self error: 'invalid use of attribute' ].    self attributes isEmpty        ifTrue: [ ^ nil ].    ^ self attributes first! !!MetacelloMethodSection methodsFor: 'accessing' stamp: 'dkh 9/7/2012 10:49'!attribute: anObject    self deprecated: 'Use attributes: instead'.    self attributes size > 1        ifTrue: [ self error: 'invalid use of attribute:' ].    attributes := OrderedCollection with: anObject! !!MetacelloMethodSection methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!attributePrintString    | stream |    stream := WriteStream on: String new.    self attributes size = 1        ifTrue: [ stream nextPutAll: '#' , attributes first asString printString ]        ifFalse: [             stream nextPutAll: '#('.            self attributes                do: [ :attribute |                     stream                        nextPutAll: '#' , attribute asString printString;                        space ].            stream nextPut: $) ].    ^ stream contents! !!MetacelloMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!attributes    attributes ifNil: [ attributes := OrderedCollection new ].    ^ attributes! !!MetacelloMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!attributes: aCollectionOrSymbol    attributes := aCollectionOrSymbol asMetacelloAttributeList! !!MetacelloMethodSection methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!includesAttributeFrom: attributeCollection    ^ (attributeCollection asSet intersection: self attributes asSet) notEmpty! !!MetacelloSymbolicVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	^ versionString! !!MetacelloSymbolicVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject	versionString := anObject! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!addMethodSection: methodSection	methodSection parent: self.	self methodSections add: methodSection! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!attributeOrPath    ^ self parent == nil        ifTrue: [             self attributes size == 1                ifTrue: [ self attributes first ]                ifFalse: [ self attributes ] ]        ifFalse: [ self attributePath ]! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!attributePath    | path |    path := MetacelloMethodSectionPath with: self attributes.    ^ self parent == nil        ifTrue: [ path ]        ifFalse: [ self parent attributePath , path ]! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!block	^ block! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!block: anObject	block := anObject! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodSections	methodSections ifNil: [ methodSections := OrderedCollection new ].	^methodSections! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!parent	^ parent! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!parent: anObject	parent := anObject! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!printOn: aStream  aStream    nextPutAll: self class name asString;    nextPut: $(.  self versionSpec printOn: aStream.  aStream nextPut: $)! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!topParent	self parent == nil		ifTrue: [ ^ self ].	^ self parent topParent! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionSpec	^ versionSpec! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionSpec: anObject	versionSpec := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!category	^ category! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!category: anObject	category := anObject! !!MetacelloMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!compileMethod	(project configuration class		compile: self methodSource		classified: self category) == nil		ifTrue: [ self error: 'Error compiling the method' ]! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodSections	methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].	^ methodSections! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodSections: anObject	methodSections := anObject! !!MetacelloMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!methodSource	self subclassResponsibility! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project	^ project! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project: anObject	project := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!selector	^ selector! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!selector: anObject	selector := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString	^ versionString! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: aStringOrSymbol	versionString := aStringOrSymbol! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'adding' stamp: '9/28/2017 08:54:38'!addMethodSection: attribute versionString: aString    self methodSections        add:            (MetacelloSymbolicVersionSpec new                attributes: attribute asMetacelloAttributeList;                versionString: aString;                yourself)! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!methodSource    | strm |    strm := WriteStream on: String new.    self symbolicMethodSelectorAndPragma: self selector symbolicVersionSymbol: self versionString on: strm.    (self methodSections asArray sort: [ :a :b | a attributes first <= b attributes first ])        do: [ :methodSection |             | vs |            strm                cr;                tab;                nextPutAll: 'spec for: ' , methodSection attributePrintString , ' version: '.            vs := methodSection versionString.            vs isSymbol                ifTrue: [ strm nextPut: $# ].            strm                nextPutAll: vs asString printString , '.';                cr ].    ^ strm contents! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!symbolicMethodSelectorAndPragma: aSelector symbolicVersionSymbol: symbolicVersionSymbol on: strm	strm		nextPutAll: aSelector asString , ' spec';		cr;		tab;		nextPutAll: '<symbolicVersion: #' , symbolicVersionSymbol asString printString;		nextPutAll: '>';		cr! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: aStringOrSymbol	aStringOrSymbol isSymbol ifFalse: [ self error: 'Version symbol ', aStringOrSymbol printString, ' for symbolic version method must be a Symbol' ].	super versionString: aStringOrSymbol! !!MetacelloBaselineOfMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!methodSelectorAndPragma: aSelector imports: importList on: strm  strm    nextPutAll: aSelector asString , ' spec';    cr;    tab;    nextPutAll: '<baseline>'! !!MetacelloBaselineOfMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!methodSource  | strm |  strm := WriteStream on: String new.  self methodSelectorAndPragma: self selector imports: self imports on: strm.  self    methodSection: self    pre: [ :methodSection :indent |       strm        cr;        tab: indent;        nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';        cr.      methodSection versionSpec        configMethodOn: strm        last: methodSection methodSections isEmpty        indent: indent + 1 ]    last: false    post: [ :methodSection :indent :last |       strm nextPutAll: ' ].'.      (last        or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ])        ifTrue: [ strm cr ] ]    indent: 0.  ^ strm contents! !!MetacelloBaselineOfMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString  ^ MetacelloMCBaselineProject singletonVersionName! !!MetacelloVersionMethodSpec methodsFor: 'adding' stamp: '9/28/2017 08:54:38'!addMethodSection: attributePath versionSpec: versionSpec    | attributeList methodSection index sections found |    attributeList := attributePath last.    methodSection := MetacelloVersionMethodSection new        attributes: attributeList;        versionSpec: versionSpec;        yourself.    attributePath size > 1        ifTrue: [             index := 1.            sections := self methodSections.            found := true.            [ found ]                whileTrue: [                     found := false.                    sections                        do: [ :ms |                             ms attributes = (attributePath at: index)                                ifTrue: [                                     index == (attributePath size -1)                                        ifTrue: [                                             ms methodSections add: methodSection.                                            ^ self ].                                    sections := ms methodSections.                                    index := index + 1.                                    found := true ] ] ].            self error: 'Method section for attribute: ' , (attributePath at: index) printString , ' not found.' ]        ifFalse: [ self methodSections add: methodSection ]! !!MetacelloVersionMethodSpec methodsFor: 'adding' stamp: '9/28/2017 08:54:38'!findMethodSection: attributeOrPath sectionIndex: sectionIndex    | attributePath index sections found |    attributePath := attributeOrPath asMetacelloAttributePath.    index := 1.    sections := self methodSections.    found := true.    [ found ]        whileTrue: [             found := false.            sections                do: [ :ms |                     ms attributes = (attributePath at: index)                        ifTrue: [                             index == attributePath size                                ifTrue: [ ^ ms ].                            sections := ms methodSections.                            index := index + 1.                            found := true ] ] ].    self error: 'Method section for attribute: ' , attributePath printString , ' not found.'! !!MetacelloVersionMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!imports	imports == nil ifTrue: [ imports := #() ].	^ imports! !!MetacelloVersionMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!imports: anObject	imports := anObject! !!MetacelloVersionMethodSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!methodSection: methodSection pre: preBlock last: last post: postBlock indent: indent	| list |	methodSection ~~ self		ifTrue: [ preBlock value: methodSection value: indent ].	list := methodSection methodSections.	1 to: list size		do: [ :index | | ms | 			ms := list at: index.			self				methodSection: ms				pre: preBlock				last: index ~= list size				post: postBlock				indent: indent + 1 ].	methodSection ~~ self		ifTrue: [ postBlock value: methodSection value: indent value: last ]! !!MetacelloVersionMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!methodSelectorAndPragma: aSelector imports: importList versionString: aString on: strm	strm		nextPutAll: aSelector asString , ' spec';		cr;		tab;		nextPutAll: '<version: ' , aString printString.	importList notEmpty		ifTrue: [ 			strm nextPutAll: ' imports: #('.			importList				do: [ :importVersionString | 					strm						nextPutAll: importVersionString printString;						space ].			strm nextPut: $) ].	strm		nextPutAll: '>';		cr! !!MetacelloVersionMethodSpec methodsFor: 'method generation' stamp: '9/28/2017 08:54:38'!methodSource    | strm |    strm := WriteStream on: String new.    self        methodSelectorAndPragma: self selector        imports: self imports        versionString: self versionString        on: strm.    self        methodSection: self        pre: [ :methodSection :indent |             strm                cr;                tab: indent;                nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';                cr.            methodSection versionSpec configMethodOn: strm last: methodSection methodSections isEmpty indent: indent + 1 ]        last: false        post: [ :methodSection :indent :last |             strm nextPutAll: ' ].'.            (last or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ])                ifTrue: [ strm cr ] ]        indent: 0.    ^ strm contents! !!MetacelloVersionMethodSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: aStringOrSymbol	aStringOrSymbol isSymbol ifTrue: [ self error: 'Version string ', aStringOrSymbol printString, ' for version method must be a String' ].	super versionString: aStringOrSymbol! !!MetacelloPlatform class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!current	Current		ifNil: [Current := MetacelloPlatform new].	^ Current! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: '9/28/2017 08:54:38'!initialize  "noop ... use #select"! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: '9/28/2017 08:54:38'!select  Current := self new! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: '9/28/2017 08:54:38'!unselect  MetacelloPlatform current class = self    ifTrue: [ Current := nil ]! !!MetacelloPlatform methodsFor: 'utilities' stamp: '9/28/2017 08:54:38'!authorName	Smalltalk at: #Author ifPresent: [:cl | ^cl perform: #initials ].	^'no developer initials'! !!MetacelloPlatform methodsFor: 'utilities' stamp: '9/28/2017 08:54:38'!authorName: aString	"Primarily used for testing"	self subclassResponsibility! !!MetacelloPlatform methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!bypassGoferLoadUpdateCategories	bypassGoferLoadUpdateCategories == nil ifTrue: [ bypassGoferLoadUpdateCategories := false ].	^ bypassGoferLoadUpdateCategories! !!MetacelloPlatform methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!bypassGoferLoadUpdateCategories: anObject	bypassGoferLoadUpdateCategories := anObject! !!MetacelloPlatform methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!bypassProgressBars	bypassProgressBars == nil ifTrue: [ bypassProgressBars := false ].	^ bypassProgressBars! !!MetacelloPlatform methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!bypassProgressBars: anObject	bypassProgressBars := anObject! !!MetacelloPlatform methodsFor: 'caching' stamp: '9/28/2017 08:54:38'!clearCurrentVersionCache	MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo)! !!MetacelloPlatform methodsFor: 'package cache' stamp: '9/28/2017 08:54:38'!clearPackageCache  "make sure that the package cache is empty, by hook or by crook"  | cache dir |  cache := self defaultPackageCache.  cache flushCache.	"GemStone and Pharo1.4"  dir := cache directory.  dir ~~ nil    ifTrue: [       "delete directory - Squeak and Pharo"      [ self recursiveDelete: dir ]        on: Error        do: [ :ignore |  ] ]! !!MetacelloPlatform methodsFor: 'notification' stamp: '9/28/2017 08:54:38'!collection: aCollection do: aBlock displaying: aString	aCollection do: aBlock! !!MetacelloPlatform methodsFor: 'user interaction' stamp: '9/28/2017 08:54:38'!confirm: aString		^(Smalltalk hasClassNamed: #UIManager)		ifTrue: [ (Smalltalk classNamed: #UIManager) default perform: #confirm: with: aString ]		ifFalse: [			"throw warning and answer true, if no way to announce"			Warning signal: aString.			true ]! !!MetacelloPlatform methodsFor: 'reflection' stamp: '9/28/2017 08:54:38'!copyClass: oldClass as: newName inCategory: newCategoryName	self subclassResponsibility! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'EstebanLorenzano 9/16/2017 13:02'!createRepository: aRepositorySpec  | type |  type := aRepositorySpec type.  type = 'http'    ifTrue: [       ^ MCHttpRepository        location: aRepositorySpec description        user: aRepositorySpec username        password: aRepositorySpec password ].  type = 'directory'    ifTrue: [       ^ MCDirectoryRepository new        directory: (self fileHandleOn: aRepositorySpec description) ].  Smalltalk    at: #'MCFileTreeRepository'    ifPresent: [ :cl |       type = 'filetree'        ifTrue: [           | description headerSize |          description := aRepositorySpec description.          headerSize := 'filetree://' size.          ^ cl new            directory:              (self                fileHandleOn:                  (aRepositorySpec description copyFrom: headerSize + 1 to: description size)) ] ].  Smalltalk    at: #'TonelRepository'    ifPresent: [ :cl |       type = 'tonel'        ifTrue: [           | description headerSize |          description := aRepositorySpec description.          headerSize := 'tonel://' size.          ^ cl new            directory:              (self                fileHandleOn:                  (aRepositorySpec description copyFrom: headerSize + 1 to: description size)) ] ].  Smalltalk    at: #'MCGitHubRepository'    ifPresent: [ :cl |       type = 'github'        ifTrue: [ ^ cl location: aRepositorySpec description ] ].  Smalltalk    at: #'MCBitbucketRepository'    ifPresent: [ :cl |       type = 'bitbucket'        ifTrue: [ ^ cl location: aRepositorySpec description ] ].  Smalltalk    at: #'MCGitoriousRepository'    ifPresent: [ :cl |       type = 'gitorious'        ifTrue: [ ^ cl location: aRepositorySpec description ] ].  type = 'dictionary'    ifTrue: [       | description headerSize globalName |      description := aRepositorySpec description.      headerSize := 'dictionary://' size.      globalName := (description copyFrom: headerSize + 1 to: description size)        asSymbol.      ^ Smalltalk        at: globalName        ifAbsent: [           Smalltalk            at: globalName            put:              (MCDictionaryRepository new                description: description;                yourself) ] ].  ^ nil! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!defaultDirectory	"Get the image default directory"		^self fileDirectoryClass default! !!MetacelloPlatform methodsFor: 'package cache' stamp: '9/28/2017 08:54:38'!defaultPackageCache  "Apparently the MCCacheRepository api is changing in Pharo"  ^ MCCacheRepository default! !!MetacelloPlatform methodsFor: 'attributes' stamp: '9/28/2017 08:54:38'!defaultPlatformAttributes  | versionString |  Smalltalk    at: #'SystemVersion'    ifPresent: [ :cl |       versionString := cl current version.      (versionString beginsWith: 'Pharo')        ifTrue: [ ^ #(#'squeakCommon' #'pharo') ].      (versionString beginsWith: 'Squeak')        ifTrue: [ ^ #(#'squeakCommon' #'squeak') ].	"see http://code.google.com/p/metacello/issues/detail?id=146"      (self string: versionString includesSubstring: 'Pharo')        ifTrue: [ ^ #(#'squeakCommon' #'pharo') ].      (self string: versionString includesSubstring: 'Squeak')        ifTrue: [ ^ #(#'squeakCommon' #'squeak') ].      self error: 'Unrecognized version of Squeak/Pharo: ' , versionString ].  ^ #(#'gemstone')! !!MetacelloPlatform methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!defaultRepositoryDescription    ^ 'http://www.squeaksource.com/MetacelloRepository'! !!MetacelloPlatform methodsFor: 'tests' stamp: '9/28/2017 08:54:38'!defaultTimeout	"squeak compatability"	^60! !!MetacelloPlatform methodsFor: 'file system' stamp: 'TravisCI 7/28/2016 16:01'!deleteFileNamed: filePath	(self fileDirectoryClass on: filePath) containingDirectory deleteFileNamed: (self fileDirectoryClass localNameFor: filePath)! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!directoryFromPath: adirectoryPath relativeTo: anotherDirectoryPath	"Get a handle on the following path: anotherDirectoryPath/adirectoryPath"	^ anotherDirectoryPath directoryNamed: adirectoryPath! !!MetacelloPlatform methodsFor: 'tests' stamp: 'dkh 07/06/2016 14:55'!disableUndefinedSybolUpdates  "noop for most platforms - needed for GemStone"  ^ nil! !!MetacelloPlatform methodsFor: 'notification' stamp: '9/28/2017 08:54:38'!do: aBlock displaying: aString	aBlock value! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: '9/28/2017 08:54:38'!downloadErrorFileNameFor: zipFileName  | pid |  pid := self processPID.  ^ '/tmp/curl-' , pid , '-' , (zipFileName select: [ :c | c isAlphaNumeric ])    , '.err'! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: '9/28/2017 08:54:38'!downloadJSON: url eTagsCache: eTagsCache eTagsKey: eTagsKey username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  "To minimize GitHub rate limiting problems, we are caching the ETags for the tag request: https://developer.github.com/v3/#conditional-requests"  ^ self downloadJSON: url username: username pass: pass! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: '9/28/2017 08:54:38'!downloadJSON: url username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  self subclassResponsibility! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'ct 10/12/2020 19:37'!downloadZipArchive: url to: outputFileName	^ self downloadZipArchive: url to: outputFileName username: nil pass: nil! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'ct 10/12/2020 23:49'!downloadZipArchive: url to: outputFileName username: username pass: pass	^ self subclassResponsibility! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!ensureDirectoryExists: aDirectoryHandle	"Ensure the directory exists."	^ aDirectoryHandle assureExistence ; yourself! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: '9/28/2017 08:54:38'!extractRepositoryFrom: zipFile to: directory    "unzip <zipFile> into <directory>"    self subclassResponsibility! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'EstebanLorenzano 9/16/2017 11:55'!extractTypeFromDescription: description  description == nil    ifTrue: [ ^ nil ].  ((description beginsWith: '/') or: [ description second = $: ])    ifTrue: [ ^ 'directory' ].  (description beginsWith: 'dictionary://')    ifTrue: [ ^ 'dictionary' ].  (description beginsWith: 'filetree://')    ifTrue: [ ^ 'filetree' ].  (description beginsWith: 'tonel://')    ifTrue: [ ^ 'tonel' ].  (description beginsWith: 'github://')    ifTrue: [ ^ 'github' ].  (description beginsWith: 'gitorious://')    ifTrue: [ ^ 'gitorious' ].  (description beginsWith: 'bitbucket://')    ifTrue: [ ^ 'bitbucket' ].  ^ 'http'! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'EstebanLorenzano 9/27/2017 17:10'!fileDirectoryClass	^ Smalltalk at: #FileDirectory! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!fileHandleOn: aPath	"Get an handle on a file."	^ self fileDirectoryClass on: aPath! !!MetacelloPlatform methodsFor: 'git support' stamp: '9/28/2017 08:54:38'!gitBranchNameFor: aDirectory  "return current branch for git repository located at <aDirectory>, if <aDirectory> is not a git repository, return nil"  ^ nil! !!MetacelloPlatform methodsFor: 'git support' stamp: '9/28/2017 08:54:38'!gitCommitShaFor: aDirectory  "return SHA for git repository located at <aDirectory>, if <aDirectory> is not a git repository, return nil"  ^ nil! !!MetacelloPlatform methodsFor: 'reflection' stamp: '9/28/2017 08:54:38'!globalNamed: globalName	^Smalltalk at: globalName! !!MetacelloPlatform methodsFor: 'reflection' stamp: '9/28/2017 08:54:38'!globalNamed: globalName ifAbsent: absentBlock	^Smalltalk at: globalName ifAbsent: absentBlock! !!MetacelloPlatform methodsFor: 'monticello' stamp: '9/28/2017 08:54:38'!newVersionForWorkingCopy: aWorkingCopy  ^ aWorkingCopy newVersion! !!MetacelloPlatform methodsFor: 'repository creation' stamp: '9/28/2017 08:54:38'!packageInfoFor: aMCWorkingCopy  ^ aMCWorkingCopy packageInfo! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!parentDirectoryOf: aFileHandler	"Get the parent directory of this file."		^ aFileHandler containingDirectory! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24'!primeStackCacheFor: cacheName doing: noArgBlock defaultDictionary: aDictionary	self deprecated: 'use #primeStackCacheWith:doing:'.	self 		useStackCacheDuring: [:dict | | cache |			cache := dict at: cacheName ifAbsent: [].			cache == nil				ifTrue: [ 					cache := Dictionary new.					dict at: cacheName put: cache ].			^noArgBlock value ] 		defaultDictionary: aDictionary! !!MetacelloPlatform methodsFor: 'caching' stamp: '9/28/2017 08:54:38'!primeStackCacheWith: aDictionary doing: noArgBlock	self 		useStackCacheDuring: [:dict | ^noArgBlock value ] 		defaultDictionary: aDictionary! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: '9/28/2017 08:54:38'!processPID  "return pid of process as string if available"  ^ ''! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!readStreamOn: aFileHandle do: aBlock	"Get a read stream on the file handle and execute some actions on it."	| stream |	stream := aFileHandle readStream.	^ [ aBlock value: stream ] 		ensure: [ stream close ]! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!recursiveDelete: aDirectory	"delete this directory and all children of it"	^  aDirectory recursiveDelete! !!MetacelloPlatform methodsFor: 'tests' stamp: 'dkh 07/06/2016 14:55'!reenableUndefinedSybolUpdates: undefinedSymbols  "noop for most platforms - needed for GemStone"! !!MetacelloPlatform methodsFor: 'repository creation' stamp: '9/28/2017 08:54:38'!registerPackageNamed: packageName  ^ (Smalltalk at: #'PackageInfo') registerPackageName: packageName! !!MetacelloPlatform methodsFor: 'system' stamp: 'EstebanLorenzano 9/16/2017 13:59'!selectorForPragma: aPragma	^ aPragma selector! !!MetacelloPlatform methodsFor: 'caching' stamp: '9/28/2017 08:54:38'!stackCacheFor: cacheName at: key doing: aBlock	^self stackCacheFor: cacheName cacheClass: Dictionary at: key doing: aBlock! !!MetacelloPlatform methodsFor: 'caching' stamp: '9/28/2017 08:54:38'!stackCacheFor: cacheName cacheClass: cacheClass at: key doing: aBlock	self 		useStackCacheDuring: [:dict | | cache |			cache := dict at: cacheName ifAbsent: [].			cache ~~ nil				ifTrue: [ | value hasEntry |					hasEntry := true.					value := cache at: key ifAbsent: [ hasEntry := false ].					hasEntry ifTrue: [ ^value ]]				ifFalse: [ 					cache := cacheClass new.					dict at: cacheName put: cache ].			^aBlock value: cache ] 		defaultDictionary: nil! !!MetacelloPlatform methodsFor: 'utilities' stamp: '9/28/2017 08:54:38'!string: aString includesSubstring: aSubstring	"abstract String>>includesSubstring: to have the same message on all supported platforms."	^aString includesSubString: aSubstring! !!MetacelloPlatform methodsFor: 'system' stamp: 'EstebanLorenzano 9/27/2017 17:11'!suspendSystemUpdateEventsDuring: aBlock	"Wraps call to the system evetn manager to tell it that we want to suspend events during execution of aBlock"	(Smalltalk at: #SystemChangeNotifier) uniqueInstance doSilently: aBlock! !!MetacelloPlatform methodsFor: 'file system' stamp: '9/28/2017 08:54:38'!tempFileFor: aName suffix: aSuffixString	^ '/tmp/' , aName , aSuffixString! !!MetacelloPlatform methodsFor: 'utilities' stamp: '9/28/2017 08:54:38'!timestamp	^DateAndTime now printString! !!MetacelloPlatform methodsFor: 'transactions' stamp: '9/28/2017 08:54:38'!transact: aBlock	"On GemStone, we want to optionally abort before command execution and commit after 	 common execution. Other plaforms don't need to do anything special.	 Returning out of block, skips commit."		aBlock value! !!MetacelloPlatform methodsFor: 'caching' stamp: '9/28/2017 08:54:38'!useStackCacheDuring: aBlock defaultDictionary: defaultDictionary	| dict |	dict := MetacelloStackCacheNotification signal.	dict == nil		ifTrue: [ 			dict := defaultDictionary == nil				ifTrue: [ Dictionary new ]				ifFalse: [ defaultDictionary ] ].	[ ^ aBlock value: dict ]		on: MetacelloStackCacheNotification , MetacelloClearStackCacheNotification		do: [ :ex | 			(ex isKindOf: MetacelloStackCacheNotification)				ifTrue: [ ex resume: dict ].			(ex isKindOf: MetacelloClearStackCacheNotification)				ifTrue: [ 					| keys |					keys := ex cacheNames.					keys ifNil: [ keys := dict keys ].					keys						do: [ :k | 							(dict includesKey: k)								ifTrue: [ 									| c |									c := dict at: k.									c keys do: [ :ck | c removeKey: ck ].									dict removeKey: k ] ].					ex resume ] ]! !!MetacelloSqueakPlatform class methodsFor: 'initialize-release' stamp: 'tobe 5/7/2020 09:29'!cleanUp: aggressive	Smalltalk globals at: #MCGitHubRepository ifPresent: [:c |		c flushETagsCache].	Smalltalk globals at: #MCFetchGithubRepository ifPresent: [:c |		c flushETagsCache].! !!MetacelloSqueakPlatform class methodsFor: 'initialize-release' stamp: 'dkh 6/12/2012 10:18:46.076'!initialize  self select! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 6/12/2012 10:18:46.076'!authorName	^Utilities authorInitials! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 6/12/2012 10:18:46.076'!authorName: aString	^Utilities authorInitials: aString! !!MetacelloSqueakPlatform methodsFor: 'private' stamp: 'topa 9/20/2017 13:44'!cacheJSONFor: aWebResponse in: aDictionary  self cacheMetadataFor: aWebResponse in: aDictionary.  "Retain Json"  ^ aDictionary  at: 'jsonObject' put: (MCFileTreeJsonParser parse: aWebResponse content).! !!MetacelloSqueakPlatform methodsFor: 'private' stamp: 'topa 9/20/2017 13:43'!cacheMetadataFor: aWebResponse in: aDictionary  "Copy interesting"  #( 'ETag' 'Last-Modified' 'X-RateLimit-Remaining' ) do: [:key |    (aWebResponse headerAt: key) ifNotEmpty: [:value| aDictionary at: key put: value]].! !!MetacelloSqueakPlatform methodsFor: 'notification' stamp: 'dkh 6/12/2012 10:18:46.076'!collection: aCollection do: aBlock displaying: aString	self bypassProgressBars ifTrue: [ ^super collection: aCollection do: aBlock displaying: aString ].	aCollection 		do: aBlock		displayingProgress: aString! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 6/12/2012 10:18:46.076'!copyClass: oldClass as: newName inCategory: newCategoryName	| copysName class newDefinition |	copysName := newName asSymbol.	copysName = oldClass name		ifTrue: [ ^ oldClass ].	(Smalltalk includesKey: copysName)		ifTrue: [ ^ self error: copysName , ' already exists' ].	newDefinition := oldClass definition copyReplaceAll: '#' , oldClass name asString with: '#' , copysName asString printString.	newDefinition := newDefinition		copyReplaceAll: 'category: ' , (SystemOrganization categoryOfElement: oldClass name) asString printString		with: 'category: ' , newCategoryName printString.	class := Compiler evaluate: newDefinition logged: true.	class class instanceVariableNames: oldClass class instanceVariablesString.	class copyAllCategoriesFrom: oldClass.	class class copyAllCategoriesFrom: oldClass class.	class category: newCategoryName.	^ class! !!MetacelloSqueakPlatform methodsFor: 'repository creation' stamp: 'ct 11/7/2020 14:06'!createRepository: aRepositorySpec 	| type |	type := aRepositorySpec type.	type = 'ftp'		ifTrue: [| description headerSize index host directory |			description := aRepositorySpec description.			headerSize := 'ftp://' size.			index := description indexOf: $/ startingAt: headerSize + 1.			host := description copyFrom: headerSize + 1 to: index - 1.			directory := description copyFrom: index + 1 to: description size.			^ MCFtpRepository				host: host				directory: directory				user: aRepositorySpec username				password: aRepositorySpec password].		type = 'github' ifTrue: [		^ MCFetchGithubRepository			location: aRepositorySpec description			username: aRepositorySpec username			password: aRepositorySpec password].	type = 'bitbucket' ifTrue: [		^ MCFetchBitbucketRepository			location: aRepositorySpec description			username: aRepositorySpec username			password: aRepositorySpec password].		^ super createRepository: aRepositorySpec! !!MetacelloSqueakPlatform methodsFor: 'attributes' stamp: 'mt 9/15/2020 15:55'!defaultPlatformAttributes	| attributes systemVersion major minor both |	attributes := OrderedCollection with: #squeakCommon with: #squeak.	systemVersion := (Smalltalk at: #SystemVersion ifPresent: [:cl | cl current])		ifNil: [^ attributes "get out early if we don't know about this verison"].	both := systemVersion majorMinorVersion readStream.	[both peek isDigit] whileFalse: [both next].	major := both upTo: $..	minor := both upToEnd.	(systemVersion version endsWith: 'alpha')		ifTrue: ["For alphas it is sensible to pretend to be the previous version, 				so that things can be tested and then moved forward."				minor ~= '0'					ifTrue: 						["easy" attributes add: ('squeak', major, '.', (minor asInteger - 1) asString, '.x') asSymbol]					ifFalse:						[" well we would have to guess the previous release for 'big jumps' here,						  so for now use a list of known jumps or roll down to 10 "						| priorVersion priorMajor |						priorMajor := major asInteger - 1.						priorVersion := #(('1' '1.31') ('2' '2.8') ('3' '3.10') ('4' '4.5' "on purpose NOT 4.6") ('5' '5.3'))							at: priorMajor ifAbsent: [{priorMajor asString . priorMajor asString, '.10'}].						attributes							add: ('squeak', priorVersion first, '.x') asSymbol;							add: ('squeak', priorVersion second, '.x') asSymbol]].	attributes		add: ('squeak', major, '.x') asSymbol;		add: ('squeak', major, '.', minor, '.x') asSymbol.	^ attributes! !!MetacelloSqueakPlatform methodsFor: 'file system' stamp: 'tfel 7/29/2014 14:39'!directoryFromPath: adirectoryPath relativeTo: anotherDirectoryPath	"Get a handle on the following path: anotherDirectoryPath/adirectoryPath"	| path |      "remove trailing slash - required for Windows compat"      path := adirectoryPath last = $/		ifTrue: [adirectoryPath allButLast] ifFalse: [adirectoryPath].	^ anotherDirectoryPath directoryNamed: path! !!MetacelloSqueakPlatform methodsFor: 'notification' stamp: 'dkh 6/12/2012 10:18:46.076'!do: aBlock displaying: aString	self bypassProgressBars ifTrue: [ ^super do: aBlock displaying: aString ].	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: 2		during: [:bar |			bar value: 1.			aBlock value.			bar value: 2 ]! !!MetacelloSqueakPlatform methodsFor: 'github/bitbucket support' stamp: 'tobe 5/7/2020 10:10'!downloadJSON: url eTagsCache: eTagsCache eTagsKey: eTagsKey username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  "To minimize GitHub rate limiting problems, we are caching the ETags for the tag request: https://developer.github.com/v3/#conditional-requests"  | info response |  eTagsCache ifNil: [^ self downloadJSON: url username: username pass: pass].  Transcript cr.  info := eTagsCache at: eTagsKey ifAbsentPut: [Dictionary new].  response := self httpGet: url username: username pass: pass do: [:req |    info      at: 'ETag'      ifPresent: [:tag | req headerAt: 'If-None-Match' put: tag]      ifAbsent: [req headerAt: 'If-Modified-Since' put:  'Mon, 23 Apr 2012 14:17:47 GMT']].  response isSuccess | response isRedirect    ifFalse: [ Transcript cr; show: 'downloadJSON:eTagsCache:eTagsKey:username:pass: ', response printString ].   response code = 304 ifTrue: [" Not modified"    ^ info      at: 'jsonObject'      ifPresent: [:obj | self cacheMetadataFor: response in: info. obj]      ifAbsent: [self downloadJSON: url username: username pass: pass]].    ^ response isSuccess    ifFalse: [MCFileTreeJsonParser parse: response content]    ifTrue: [self cacheJSONFor: response in: info]  ! !!MetacelloSqueakPlatform methodsFor: 'github/bitbucket support' stamp: 'topa 9/21/2017 14:04'!downloadJSON: url username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  | response |  response := self httpGet: url username: username pass: pass do: [:req | ].  response isSuccess    ifFalse: [ Transcript cr; show: 'downloadJSON:username:pass: ', response printString ].  ^ MCFileTreeJsonParser parse: response content! !!MetacelloSqueakPlatform methodsFor: 'private' stamp: 'topa 1/17/2018 13:20'!downloadProgressFor: url    ^ self bypassProgressBars ifFalse: [            [:total :amount|             HTTPProgress new                total: total;                amount: amount;                 signal: 'Downloading ', url] ].! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'ct 10/12/2020 19:35'!downloadZipArchive: url to: outputFileName username: username pass: pass  "download zip archive from <url> into <outputFileName>. username:pass can be used to access resources with limited visibility but may be nil."    self streamFrom: url to: outputFileName username: username pass: pass ifFailed: 	[:response | | message |        message := response content.        response close.        ^ self error: 'Error downloading ', url, ' to ', outputFileName, '. Server said: ', message].    ^ ZipArchive new readFrom: outputFileName! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'tfel 7/29/2014 14:42'!extractRepositoryFrom: zipFile to: directory    "unzip <zipFile> into <directory>"    ZipArchive new        readFrom: zipFile;        extractAllTo: (FileDirectory on: directory) informing: nil overwrite: true.! !!MetacelloSqueakPlatform methodsFor: 'repository creation' stamp: 'dkh 6/12/2012 10:18:46.076'!extractTypeFromDescription: description 	(description beginsWith: 'ftp://')		ifTrue: [^ 'ftp'].	^ super extractTypeFromDescription: description! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 6/12/2012 10:18:46.076'!globalNamed: globalName	^Smalltalk at: globalName! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 6/12/2012 10:18:46.076'!globalNamed: globalName ifAbsent: absentBlock	^Smalltalk at: globalName ifAbsent: absentBlock! !!MetacelloSqueakPlatform methodsFor: 'private' stamp: 'ct 10/26/2020 13:48'!httpGet: url username: username pass: pass do: aBlock  | client response |  client := WebClient new.  username ifNotNil: [client username: username; password: [pass]].  response := client httpGet: url do: [:req |    ((username notNil or: [pass notNil]) and: [client server = 'api.github.com']) ifTrue: [      "Workaround for GitHub API which requires manual authorization. See https://docs.github.com/en/free-pro-team@latest/rest/overview/resources-in-the-rest-api#authentication and http://forum.world.st/The-Inbox-WebClient-Core-ct-126-mcz-tp5123366p5123381.html for more information."      "NB: Password authentication to the API is not supported. You must use an OAuth access token. See https://docs.github.com/en/free-pro-team@latest/rest/overview/other-authentication-methods#via-username-and-password for more information."      req headerAt: 'Authorization' put: 'token ' , pass].    aBlock cull: req].  ^ response    content;    close! !!MetacelloSqueakPlatform methodsFor: 'private' stamp: 'ct 10/12/2020 19:39'!streamFrom: aUrlString to: aFileName username: username pass: pass ifFailed: aBlock    |response |    response := self httpGet: aUrlString username: username pass: pass do: [:req | ].    response isSuccess ifFalse: [^ aBlock value: response].    " some sites do not indicate error codes but rather just 200 with html..., we expect zip"    (response contentType beginsWith: 'text/') ifTrue: [^ aBlock value: response].        ^ FileDirectory activeDirectoryClass        splitName: aFileName        to: [:path :file |            (FileDirectory on: path)                assureExistence;                forceNewFileNamed: file do:                    [:stream | response                        streamTo: stream binary                        size: response contentLength                        progress: (self downloadProgressFor: aUrlString)]]! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'topa 9/21/2017 11:04'!string: aString includesSubstring: aSubstring	^ (aString findString: aSubstring startingAt: 1) > 0! !!MetacelloSqueakPlatform methodsFor: 'file system' stamp: 'jr 10/19/2016 14:52'!tempFileFor: aName suffix: aSuffixString	^ (Smalltalk os platformName = 'Win32'		ifTrue: [self windowsTempDirectory]		ifFalse: ['/tmp']) , FileDirectory slash , aName , aSuffixString! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 6/12/2012 10:18:46.076'!timestamp	^Date today mmddyyyy, ' ',			((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!MetacelloSqueakPlatform methodsFor: 'file system' stamp: 'jr 3/11/2017 00:32'!windowsTempDirectory	Smalltalk at: #OSProcess ifPresent: [:osProcess |		^ osProcess thisOSProcess environment at: 'TMP'].	(FileDirectory on: 'C:\Windows') exists		ifTrue: ["C:\Windows\Temp is writable, but not listable and #exists answers false for it"			"create a subdirectory in it (for which #exists will answer true) and use that"			| metacelloDir | metacelloDir := FileDirectory on: 'C:\Windows\Temp\Metacello'.			metacelloDir exists ifFalse:				[metacelloDir containingDirectory createDirectory: metacelloDir localName].			^ metacelloDir pathName]		ifFalse: [self error: 'Cannot determine temporary directory. Please install OSProcess.']! !!MetacelloCypressBaselineProject class methodsFor: 'accessing' stamp: '08/31/2013 23:33'!singletonVersionName    ^ 'baseline'! !!MetacelloCypressBaselineProject class methodsFor: 'accessing' stamp: 'dkh 07/07/2016 07:10'!useCypressPackagesForAllBaselines  UseCypressPackagesForAllBaselines ifNil: [ ^ false ].  ^ UseCypressPackagesForAllBaselines! !!MetacelloCypressBaselineProject class methodsFor: 'accessing' stamp: 'TravisCI 7/10/2016 08:15'!useCypressPackagesForAllBaselines: aBool	"self useCypressPackagesForAllBaselines: true"	UseCypressPackagesForAllBaselines := aBool! !!MetacelloCypressBaselineProject class methodsFor: 'accessing' stamp: '08/31/2013 23:37'!versionConstructorClass    ^ MetacelloBaselineConstructor! !!MetacelloCypressBaselineProject methodsFor: 'spec classes' stamp: 'dkh 6/29/2016 15:25'!baselineOfProjectSpecClass    ^ MetacelloCypressBaselineProjectSpec! !!MetacelloCypressBaselineProject methodsFor: 'spec classes' stamp: '08/31/2013 23:28'!packageSpecClass  ^ MetacelloCypressPackageSpec! !!MetacelloMCBaselineProject class methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!singletonVersionName    ^ 'baseline'! !!MetacelloMCBaselineProject class methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!versionConstructorClass    ^ MetacelloBaselineConstructor! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asBaselineProject    ^ self! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asConfigurationProject    ^ MetacelloMCProject new! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!bleedingEdge    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!currentVersion    ^ self version isSomethingLoaded        ifTrue: [ self version ]        ifFalse: [ nil ]! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!currentVersionAgainst: resolvedPackageAndProjectNames    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!development    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!hasVersion: versionString    ^ versionString = 'baseline'! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!lastVersion    ^ self version! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!latestVersion    ^ self version! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!latestVersion: blessing    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!latestVersionMatching: versionPatternString    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!latestVersionMatching: versionPatternString excludedBlessings: excluded    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!latestVersionMatching: versionPatternString includedBlessings: included    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings    ^ nil! !!MetacelloMCBaselineProject methodsFor: '*metacello-cypress' stamp: 'dkh 07/07/2016 07:17'!packageSpecClass  "One could argue that Baselines should have done this from the very beginning ... the cost is that every package is fetched (from disk) and the snapshots for every package are created ... the advantage is that you will properly downgrade packages when switching git versions ... for now a class variable is sufficient"  MetacelloCypressBaselineProject useCypressPackagesForAllBaselines    ifTrue: [ ^ MetacelloCypressPackageSpec ].  ^ super packageSpecClass! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool  "see https://github.com/dalehenrich/metacello-work/issues/244 ... uncoditionally load   baseline"  ^ aMetacelloScriptEngine getBaselineProjectUnconditionalLoad: true! !!MetacelloMCBaselineProject methodsFor: 'as yet unclassified' stamp: '9/28/2017 08:53:29'!setBaselineRepositoryDescription: aListOrRepositoryDescriptions    "set #version repositories to < aListOrRepositoryDescriptions>. Should be the directory where the BaselineOf is located."    aListOrRepositoryDescriptions do: [:desc | self version spec repository: desc]! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!singletonVersionName    ^ self class singletonVersionName! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!stableVersion    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!symbolicVersionSymbols    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!version    ^ self version: self singletonVersionName! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: '9/28/2017 08:53:29'!versions  ^ [ {(self version)} ]    on: MetacelloVersionDoesNotExistError    do: [ :ex | ^ #() ]! !!MetacelloMCProject methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asBaselineProject    ^ MetacelloMCBaselineProject new! !!MetacelloMCProject methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asConfigurationProject    ^ self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!baselineOfProjectSpecClass    ^ MetacelloMCBaselineOfProjectSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!configurationOfProjectSpecClass    ^ MetacelloMCConfigurationOfProjectSpec! !!MetacelloMCProject methodsFor: 'repository creation' stamp: '9/28/2017 08:53:29'!createRepository: aRepositorySpec	^ MetacelloPlatform current createRepository: aRepositorySpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!defaultLoaderClass	^MetacelloLoadingMCSpecLoader! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!fetchProject	"fetch the latest version of the configuration package"		^self fetchProject: MetacelloLoaderPolicy new! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!fetchProject: aLoaderPolicy	"fetch the latest version of the configuration package"		| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader doingLoads: [ 		MCWorkingCopy			managersForClass: self configuration class			do: [:mgr | | pkg |				pkg := self packageSpec.				mgr repositoryGroup repositories do: [:repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].				pkg name: mgr packageName.				pkg fetchUsing: mcLoader.				^true ]].	^true! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!goferBranch: branchName project: commitMessage    | pkgSpec |    pkgSpec := self projectPackage.    pkgSpec file: pkgSpec name , '.' , branchName.    ^ pkgSpec goferBranchPackage: branchName message: commitMessage! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!goferCommitProject: commitMessage	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	^pkgSpec goferCommitPackage: commitMessage! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!packageSpec	^self packageSpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!packageSpecClass	^MetacelloPackageSpec! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!packagesNeedSaving: aVersionString	"Answer a collection of associations (package -> repository) representing the packages 	 reachable from this project that need to be saved"	| packages |	packages := Set new.	(self version: aVersionString) spec 		packagesNeedSavingVisited: (Set with: self configuration class name asString)		into: packages.	^packages! !!MetacelloMCProject methodsFor: 'private' stamp: '9/28/2017 08:53:29'!pragmaKeywords	^super pragmaKeywords, #(projectPackage:attribute: packages:attribute: repositories:attribute: )! !!MetacelloMCProject methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool    ^ aMetacelloScriptEngine getConfigurationProjectUnconditionalLoad: aBool! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!projectPackage  MCWorkingCopy    managersForClass: self configuration class    do: [ :mgr |       | pkgSpec repo |      pkgSpec := self packageSpec        name: mgr packageName;        yourself.      mgr ancestors notEmpty        ifTrue: [ pkgSpec file: mgr ancestors first name ].      repo := mgr repositoryGroup repositories        detect: [ :each | each ~~ MetacelloPlatform current defaultPackageCache ]        ifNone: [           Transcript            cr;            show:                'Using cache repository for ' , self label , ' project package'.          MetacelloPlatform current defaultPackageCache ].      pkgSpec repository: (repo asRepositorySpecFor: self).      ^ pkgSpec ].  ^ nil! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!projectSpecClass	^ MetacelloMCNamelessProjectSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!repositoriesSpec	^self repositoriesSpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!repositoriesSpecClass	^MetacelloRepositoriesSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!repositorySpec	^self repositorySpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!repositorySpecClass	^MetacelloRepositorySpec! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!saveProject	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	^pkgSpec savePackage! !!MetacelloMCProject methodsFor: 'as yet unclassified' stamp: '9/28/2017 08:53:29'!setBaselineRepositoryDescription: aListOrRepositoryDescriptions    "noop "! !!MetacelloMCProject methodsFor: 'repository updating' stamp: '9/28/2017 08:53:29'!updatePackageRepositoriesFor: versionString	| versionSpec |	(versionSpec := (self version: versionString) versionSpec) packageSpecsInLoadOrder do: [:pkgSpec |		pkgSpec updatePackageRepositoriesFor: versionSpec ].	^true! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updateProject	"load the latest version of the configuration package"	"WARNING: don't forget to refresh your project instance after doing an #updateProject, 	 otherwise your instance won't reflect the info in the freshly loaded configuration"		^self updateProject: MetacelloLoaderPolicy new! !!MetacelloMCProject methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updateProject: aLoaderPolicy	"load the latest version of the configuration package"	"WARNING: don't forget to refresh your project instance after doing an #updateProject, 	 otherwise your instance won't reflect the info in the freshly loaded configuration"	| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader		doingLoads: [ 			MCWorkingCopy				managersForClass: self configuration class				do: [ :mgr | 					| pkg ar |					pkg := self packageSpec.					mgr repositoryGroup repositories do: [ :repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].					ar := mgr metacelloPackageNameWithBranch.					pkg name: (ar at: 1).					(ar at: 2) notEmpty						ifTrue: [ pkg file: (ar at: 2) ].					pkg load.					^ true ] ].	^ true! !!MetacelloMCProject methodsFor: 'spec classes' stamp: '9/28/2017 08:53:29'!versionSpecClass	^MetacelloMCVersionSpec! !!MetacelloProject class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!new	| inst |	inst := self basicNew.	^inst configuration: inst; yourself! !!MetacelloProject class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!on: aConfig	^self basicNew configuration: aConfig; yourself! !!MetacelloProject class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionConstructorClass    ^ MetacelloVersionConstructor! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!attributes	^(OrderedCollection with: #common)		addAll: self platformAttributes;		yourself! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!baselineOfProjectSpec    ^ self baselineOfProjectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!baselineOfProjectSpecClass    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!baselineOfVersionSpecClass    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!bleedingEdge	^self version: #bleedingEdge! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configuration	^ configuration! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configuration: anObject	configuration := anObject! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!configurationOfProjectSpec    ^ self configurationOfProjectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!configurationOfProjectSpecClass    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!currentVersion	| cacheKey cv |	cacheKey := self configuration class.	^ MetacelloPlatform current		stackCacheFor: #currentVersion		at: cacheKey		doing: [ :cache | 			cv := self currentVersionAgainst: nil.			^ cache at: cacheKey put: cv ]! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!currentVersionAgainst: resolvedPackageAndProjectNames	| cacheKey |	cacheKey := resolvedPackageAndProjectNames isNil		ifTrue: [ Array with: self configuration class with: nil ]		ifFalse: [ Array with: self configuration class with: (resolvedPackageAndProjectNames sort: [ :a :b | a <= b ]) ].	^ MetacelloPlatform current		stackCacheFor: #currentVersionAgainst:		at: cacheKey		doing: [ :cache | 			| cv versions latestSomethingLoaded |			cv := nil.			versions := self sortedAndFilteredVersions.			versions				do: [ :version | 					| status matchBlock |					status := resolvedPackageAndProjectNames isNil						ifTrue: [ version spec isPartiallyCurrent ]						ifFalse: [ version spec isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].					matchBlock := [ :matchStatus | 					cv := version copy.					cv versionStatus: matchStatus.					^ cache at: cacheKey put: cv ].					status isAllLoadedToSpec: matchBlock.					status isLoadedToSpec: matchBlock.					status isLoadedMatchConstraints: matchBlock.					status						isSomethingLoaded: [ :matchStatus | 							latestSomethingLoaded isNil								ifTrue: [ 									cv := version copy.									cv versionStatus: matchStatus.									latestSomethingLoaded := cv ] ] ].			latestSomethingLoaded ifNotNil: [ ^ cache at: cacheKey put: latestSomethingLoaded ].			^ cache at: cacheKey put: nil ]! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!defaultBlessing	^#release! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!defaultLoaderClass	^MetacelloSpecLoader! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!defaultPlatformAttributes	^ MetacelloPlatform current defaultPlatformAttributes! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!development	^self version: #development! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!errorMap	^ errorMap! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!errorMap: anObject    errorMap ifNil: [ errorMap := Dictionary new ].    errorMap := anObject! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!excludeFromLatestVersion	^#(structural development broken baseline)! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!groupSpec	^self groupSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!groupSpecClass	^MetacelloGroupSpec! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!hasVersion: versionString	self version: versionString ifAbsent: [ ^false ].	^true! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!label	^self configuration class name! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!lastVersion	| coll |	coll := (self map values asArray sort: [:a :b | a <= b ]) asOrderedCollection.	coll isEmpty ifTrue: [ ^nil ].	^coll last! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!latestVersion	| excluded |"	self deprecated: 'Please use #stableVersion instead.'."	self flag: 'deprecate after version 1.0'.	excluded := self excludeFromLatestVersion.	^(self map values select: [:version |  		(excluded includes: version blessing) not ]) detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!latestVersion: blessing	^(self map values select: [:version | blessing = version blessing ]) detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!latestVersionMatching: versionPatternString	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence."	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!latestVersionMatching: versionPatternString excludedBlessings: excluded	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: excluded! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!latestVersionMatching: versionPatternString includedBlessings: included	^self 		latestVersionMatching: versionPatternString 		includedBlessings: included		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings	| excluded |	excluded := excludedBlessings asSet copy.	excluded removeAllFoundIn: included.	^(self map values select: [:version |		(included isEmpty or: [ included includes: version blessing ]) 			and: [ (excluded includes: version blessing) not 				and: [ version versionNumber match: versionPatternString ]]])		detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!load: aVersionString	^(self version: aVersionString) load! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loadType	"#atomic or #linear"	loadType == nil ifTrue: [ ^#atomic ].	^loadType! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loadType: aSymbol	"#atomic or #linear"	loadType := aSymbol! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!loader	^loader! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!loader: aLoader	loader := aLoader! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!loaderClass	loaderClass == nil ifTrue: [ loaderClass := self defaultLoaderClass ].	^loaderClass! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!loaderClass: aMetacelloSpecLoader	loaderClass := aMetacelloSpecLoader! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!lookupVersion: aVersionString ifAbsent: aBlock    "please use version:...this is a private method"    ^ self map        at: aVersionString        ifAbsent: [             (MetacelloVersionDefinitionError project: self project versionString: aVersionString)                exception: (self errorMap at: aVersionString ifAbsent: [ ^ aBlock value ]);                signal ]! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!map	versionMap ifNil: [ ^ Dictionary new ].	^ versionMap! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!map: aDictionary	versionMap := aDictionary! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!packagesSpec	^self packagesSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!packagesSpecClass	^MetacelloPackagesSpec! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!platformAttributes	 ^self projectPlatformAttributes! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!pragmaKeywords	^#(version:attribute: blessing:attribute: description:attribute: required:attribute: groups:attribute: doits:attribute:)! !!MetacelloProject methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream	| label |	self configuration class printOn: aStream.	aStream nextPut: $(.	self versions		do: [ :vrsn | 			aStream nextPutAll: vrsn versionString.			vrsn spec ~~ nil				ifTrue: [ 					(label := vrsn spec projectLabel) isEmpty						ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ].			aStream				nextPut: $,;				space ].	aStream nextPut: $)! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project	^self! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!projectAttributes	projectAttributes ~~ nil ifTrue: [ ^projectAttributes ].	^#()! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!projectAttributes: aList	projectAttributes := aList! !!MetacelloProject methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!projectForScriptEngine: aMetacelloScriptEngine    ^ self projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: false! !!MetacelloProject methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!projectPlatformAttributes	| list aBlock |	list := OrderedCollection new.	(aBlock := self projectAttributes) ~~ nil 		ifTrue: [ list addAll: aBlock value ].	^self defaultPlatformAttributes, list! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!projectReferenceSpec	^self projectReferenceSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!projectReferenceSpecClass	^MetacelloProjectReferenceSpec! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!projectSpec	^self projectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!projectSpecClass    ^ MetacelloProjectSpec! !!MetacelloProject methodsFor: 'private' stamp: '9/28/2017 08:54:38'!sortedAndFilteredVersions		^(self map values asArray sort: [:a :b | a >= b ]) select: [:vrsn | (#(structural broken baseline) includes: vrsn blessing) not ].! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!stableVersion	^self version: #stable! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!symbolicVersionMap	^symbolicVersionMap! !!MetacelloProject methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!symbolicVersionMap: aDictionary	symbolicVersionMap := aDictionary! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!symbolicVersionSymbols	^self symbolicVersionMap keys asArray sort: [:a :b | a <= b ]! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!valueHolderSpec	^self valueHolderSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!valueHolderSpecClass	^MetacelloValueHolderSpec! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!version: aVersionString        aVersionString isSymbol        ifTrue: [             | symbolicVersionString |            symbolicVersionString := self symbolicVersionMap                at: aVersionString                ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: aVersionString) signal ].            symbolicVersionString == #'notDefined'                ifTrue: [ (MetacelloSymbolicVersionNotDefinedError project: self project versionString: aVersionString) signal ].            ^ self                lookupVersion: symbolicVersionString                ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: symbolicVersionString) signal ] ].    ^ self        lookupVersion: aVersionString        ifAbsent: [ (MetacelloVersionDoesNotExistError project: self project versionString: aVersionString) signal ]! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!version: aVersionString ifAbsent: aBlock	^[ self version: aVersionString ] on: MetacelloVersionDoesNotExistError do: [:ex | aBlock value ].! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!versionNumberClass    versionNumberClass ifNil: [ versionNumberClass := MetacelloVersionNumber ].    ^ versionNumberClass! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!versionNumberClass: aClass    versionNumberClass := aClass! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!versionSpec	^self versionSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: '9/28/2017 08:54:38'!versionSpecClass	^MetacelloVersionSpec! !!MetacelloProject methodsFor: 'versions' stamp: '9/28/2017 08:54:38'!versions	^self map values asArray sort: [:a :b | a <= b ]! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineClasses    "Return a set of the Metacello baseline classes that have been loaded into the image."    "self baselineClasses"    ^ BaselineOf allSubclasses! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineProjectSpecs    "MetacelloProjectRegistration baselineProjectSpecs"    ^ self registry baselineProjectSpecs! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!classRemoved: aClassRemovalAnnouncement  "aRemovalAnnouncement is platform-specific ... responds to #itemClass to    answer the class that was removed."  | aClass registration |  aClass := aClassRemovalAnnouncement itemClass.  registration := self registry    registrationForExactClassNamed: aClass name asString    ifAbsent: [ ^ self ].  registration unregisterProject! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationClasses    "Return a set of the Metacello configuration classes that have been loaded into the image."    "self configurationClasses"    | answer |    answer := IdentitySet new.    ConfigurationOf allSubclasses        do: [ :cl |             (cl == BaselineOf or: [ cl inheritsFrom: BaselineOf ])                ifFalse: [ answer add: cl ] ].    Object allSubclasses        do: [ :cl |             (answer includes: cl)                ifFalse: [                     (([ cl isMetacelloConfig ]                        on: Error                        do: [ :ex | ex return: false ]) and: [ cl name asString beginsWith: 'ConfigurationOf' ])                        ifTrue: [ answer add: cl ] ] ].    ^ answer! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationProjectSpecs    "MetacelloProjectRegistration configurationProjectSpecs"    ^ self registry configurationProjectSpecs! !!MetacelloProjectRegistration class methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!copyRegistryRestoreOnErrorWhile: aBlock  "install copy of registry for duration of <aBlock> execution."  "registrations will be copied on write during <aBlock> execution."  "if <aBlock> does not return control to this context, revert to the original	version of the registry. Otherwise leave the new copy installed."  | oldRegistry newRegistry |  oldRegistry := self registry.  newRegistry := self registry copy.  self registry: newRegistry.  aBlock    ensure: [       "install old version of registry"      newRegistry := self registry.	"see https://github.com/dalehenrich/metacello-work/issues/210"      self registry: oldRegistry ].  self registry: newRegistry	"if control returned, install newRegistry"! !!MetacelloProjectRegistration class methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!copyRegistryWhile: aBlock    "install copy of registry for duration of <aBlock> execution."    "registrations will be copied on write during <aBlock> execution."    "Unconditionally revert to the original	version of the registry. Otherwise leave the new copy installed."    | oldRegistry newRegistry |    oldRegistry := self registry.    newRegistry := self registry copy.    self registry: newRegistry.    aBlock        ensure: [             "install old version of registry"            self registry: oldRegistry ]! !!MetacelloProjectRegistration class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!fromMCBaselineProjectSpec: aProjectSpec    ^ self new        projectName: aProjectSpec name;        baselineProjectSpec: aProjectSpec;        yourself! !!MetacelloProjectRegistration class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!fromMCConfigurationProjectSpec: aProjectSpec    ^ self new        projectName: aProjectSpec name;        configurationProjectSpec: aProjectSpec;        yourself! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!primeRegistryFromImage    "MetacelloProjectRegistration primeRegistryFromImage"    self registry primeRegistryFromImage! !!MetacelloProjectRegistration class methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!projectSpecForClassNamed: aClassName ifAbsent: absentBlock    ^ self registry projectSpecForClassNamed: aClassName ifAbsent: absentBlock! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecs    "MetacelloProjectRegistration projectSpecs"    ^ self configurationProjectSpecs , self baselineProjectSpecs! !!MetacelloProjectRegistration class methodsFor: 'registration' stamp: '9/28/2017 08:54:38'!registerProjectSpec: aProjectSpec ifPresent: presentBlock    | newRegistration |    newRegistration := aProjectSpec asProjectRegistration.    ^ self registry        registrationFor: newRegistration        ifPresent: [ :existing | presentBlock value: existing value: newRegistration ]        ifAbsent: [ newRegistration registerProject ]! !!MetacelloProjectRegistration class methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!registrationForClassNamed: aClassName ifAbsent: absentBlock    ^ self registry registrationForClassNamed: aClassName ifAbsent: absentBlock! !!MetacelloProjectRegistration class methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!registrationForProjectSpec: aProjectSpec ifAbsent: absentBlock ifPresent: presentBlock    | newRegistration |    newRegistration := aProjectSpec asProjectRegistration.    self registry        registrationFor: newRegistration        ifPresent: [ :existing | ^ presentBlock value: existing value: newRegistration ]        ifAbsent: [ ^ absentBlock value: newRegistration ]! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!registry    Registry ifNil: [ Registry := MetacelloProjectRegistry new ].    ^ Registry! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!registry: aMetacelloProjectRegistry    Registry := aMetacelloProjectRegistry! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!resetRegistry    Registry := nil! !!MetacelloProjectRegistration methodsFor: 'comparing' stamp: '8/31/2017 07:16:49'!= aRegistration    aRegistration class == self class        ifFalse: [ ^ false ].    ^ (configurationProjectSpec registrationsCompareEqual: aRegistration configurationProjectSpec)        and: [ baselineProjectSpec registrationsCompareEqual: aRegistration baselineProjectSpec ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baseName	^ self projectSpec baseName! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineProjectSpec  "only one of baselineProjectSpec or configurationProjectSpec should ever be set"  ^ baselineProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineProjectSpec: anObject  "force the registration to be consistent -- difficult for Metacello to    repair registrations during load -- I've tried. "  "https://github.com/dalehenrich/metacello-work/issues/212"  self shouldBeMutable.  configurationProjectSpec := nil.  self assert: anObject isBaselineOfProjectSpec.  baselineProjectSpec := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineProjectSpecIfAbsent: absentBlock  ^ baselineProjectSpec ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineProjectSpecIfPresent: presentBlock ifAbsent: absentBlock     ^ baselineProjectSpec ifNotNil: [ presentBlock cull: baselineProjectSpec ]  ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!canDowngradeTo: aProjectRegistration    "true if there are no load conflicts        OR       if the load conflicts involved two cofigurations ONLY and a downgrade is allowed"    (self hasLoadConflicts: aProjectRegistration)        ifFalse: [ ^ true ].    configurationProjectSpec        ifNotNil: [             aProjectRegistration configurationProjectSpec                ifNotNil: [                     configurationProjectSpec ensureProjectLoaded.                    ^ configurationProjectSpec canDowngradeTo: aProjectRegistration configurationProjectSpec ] ].    ^ false! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!canUpgradeTo: aProjectRegistration  "true if there are no load conflicts        OR       if the load conflicts involved two cofigurations ONLY and an upgrade is allowed"  (self hasLoadConflicts: aProjectRegistration)    ifFalse: [ ^ true ].  configurationProjectSpec    ifNotNil: [       aProjectRegistration configurationProjectSpec        ifNotNil: [           configurationProjectSpec copy ensureProjectLoaded.          ^ configurationProjectSpec            canUpgradeTo: aProjectRegistration configurationProjectSpec ] ].  baselineProjectSpec    ifNotNil: [       aProjectRegistration baselineProjectSpec        ifNotNil: [           baselineProjectSpec copy ensureProjectLoaded.          ^ baselineProjectSpec            canUpgradeTo: aProjectRegistration baselineProjectSpec ] ].  ^ false! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationProjectSpec  "only one of baselineProjectSpec or configurationProjectSpec should ever be set"  ^ configurationProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationProjectSpec: anObject  "force the registration to be consistent -- difficult for Metacello to    repair registrations during load -- I've tried. "  "https://github.com/dalehenrich/metacello-work/issues/212"  self shouldBeMutable.  baselineProjectSpec := nil.  self assert: anObject isConfigurationOfProjectSpec.  configurationProjectSpec := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationProjectSpecIfAbsent: absentBlock    ^ configurationProjectSpec ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationProjectSpecIfPresent: presentBlock ifAbsent: absentBlock    ^ configurationProjectSpec ifNotNil: [ presentBlock cull: configurationProjectSpec ]  ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!copyOnWrite: aBlock    "assume that only registered projects are immutable ... otherwise you'll get an error"    | copy |    self class registry        registrationFor: self        ifPresent: [ :existing |  ]        ifAbsent: [             aBlock value: self.            ^ self ].    self unregisterProject.    copy := self copy.    aBlock value: copy.    copy registerProject.    ^ copy! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!currentBranchName  ^ self configurationProjectSpec    ifNotNil: [       configurationProjectSpec versionOrNil        ifNil: [ '' ]        ifNotNil: [ :vrsn | vrsn blessing asString ] ]    ifNil: [ baselineProjectSpec repositoryBranchName ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'EstebanLorenzano 9/27/2017 17:11'!currentVersionString  ^ self configurationProjectSpec    ifNotNil: [ :aSpec | aSpec versionString ]    ifNil: [ baselineProjectSpec repositoryVersionString ]! !!MetacelloProjectRegistration methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!currentlyLoadedClassesInProject	^ self projectSpec currentlyLoadedClassesInVersion asSet! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasLoadConflicts: aProjectRegistration	"5 combinations of loads with no load conflicts:        No configs and baselines =        configs = and no baselines        configs = and baselines =        configs = and no baseline loaded (self) with a baseline to load (aProjectRegistration)        config loaded (self), no config to load (aProjectRegistration) and no baseline loaded(self) with a baseline to load (aProjectRegistration) "	aProjectRegistration validate.	self isValid		ifFalse: [ ^ false ].	^ self projectSpec hasConflictWithProjectSpec: aProjectRegistration projectSpec! !!MetacelloProjectRegistration methodsFor: 'comparing' stamp: '8/31/2017 07:16:49'!hash    ^ ((String stringHash: projectName initialHash: 0) bitXor: configurationProjectSpec metacelloRegistrationHash)        bitXor: baselineProjectSpec metacelloRegistrationHash! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!immutable    mutable := false! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!isMutable    mutable ifNil: [ ^ true ].    ^ mutable! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isValid  " has a name and one or the other of the projectSpecs is non-nil, but not both ... this is CRITICAL"  projectName ifNil: [ ^ false ].  configurationProjectSpec isNil    ifTrue: [ ^ baselineProjectSpec notNil ].  ^ baselineProjectSpec isNil! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loadedInImage    loadedInImage ifNil: [ loadedInImage := false ].    ^ loadedInImage! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loadedInImage: anObject    self shouldBeMutable.    loadedInImage := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!locked    locked ifNil: [ locked := false ].    ^ locked! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!locked: anObject    self shouldBeMutable.    locked := anObject! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: '9/28/2017 08:54:38'!lookupBaselineSpec  baselineProjectSpec ifNotNil: [ :spec | ^ spec ].  ^ configurationProjectSpec! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: '9/28/2017 08:54:38'!lookupConfigurationSpec  configurationProjectSpec ifNotNil: [ :spec | ^ spec ].  ^ baselineProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'EstebanLorenzano 9/19/2017 11:39'!merge: aProjectRegistration  " ... merge is done when a spec has been loaded into the image"  self shouldBeMutable.  aProjectRegistration validate.  aProjectRegistration configurationProjectSpec    ifNotNil: [ :aSpec |      configurationProjectSpec := aSpec copy.      configurationProjectSpec versionOrNil        ifNotNil: [ :version |           "resolve symbolic versions for loaded projects"          configurationProjectSpec versionString: version versionString ].      baselineProjectSpec := nil.      self versionInfo versionString: configurationProjectSpec versionString ]    ifNil: [       baselineProjectSpec := aProjectRegistration baselineProjectSpec.      configurationProjectSpec := nil.      self versionInfo        versionString: baselineProjectSpec repositoryVersionString ]! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!mutable    mutable := true! !!MetacelloProjectRegistration methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy    super postCopy.    mutable := nil! !!MetacelloProjectRegistration methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream  | label versionString descriptions |  self    configurationProjectSpecIfPresent: [ :spec |       label := spec className.      versionString := spec versionString ]    ifAbsent: [       "baseline"      label := self baselineProjectSpec className.      versionString := '[baseline]' ].  aStream nextPutAll: label.  versionString    ifNil: [ aStream nextPutAll: ' --no version specified--' ]    ifNotNil: [       aStream        space;        nextPutAll: versionString ].  (descriptions := self repositoryDescriptions) isEmpty    ifTrue: [ ^ self ].  aStream nextPutAll: ' from '.  descriptions size = 1    ifTrue: [ aStream nextPutAll: descriptions first ]    ifFalse: [       aStream nextPut: ${.      descriptions do: [ :description | aStream nextPutAll: description ].      aStream nextPut: $} ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectName	^ projectName! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectName: anObject    self shouldBeMutable.    projectName := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec	^ baselineProjectSpec		ifNil: [ 			self assert: configurationProjectSpec notNil.			configurationProjectSpec ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectVersion  | pv |  pv := self versionInfo projectVersion.  pv    ifNil: [       pv := self projectSpec versionOrNil.      self versionInfo projectVersion: pv ].  ^ pv! !!MetacelloProjectRegistration methodsFor: 'registration' stamp: '9/28/2017 08:54:38'!registerProject    "unconditionally register <newRegistration> ... use with care"    self class registry registerProjectRegistration: self! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositoryDescriptions    ^ (self configurationProjectSpecIfAbsent: [ self baselineProjectSpec ]) repositoryDescriptions! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!shouldBeMutable    self isMutable        ifTrue: [ ^ self ].    self error: 'Not allowed to modify an immutable object'! !!MetacelloProjectRegistration methodsFor: 'registration' stamp: '9/28/2017 08:54:38'!unregisterProject    self class registry unregisterProjectRegistration: self! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!validate	self isValid		ifFalse: [ self error: 'Invalid project registration' ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!version    ^ (self configurationProjectSpecIfAbsent: [ ^ MetacelloMCBaselineProject singletonVersionName ]) versionString! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionInfo  versionInfo    ifNil: [       versionInfo := MetacelloProjectRegistrationVersionInfo new.      self        configurationProjectSpecIfPresent: [ versionInfo versionString: self version ]        ifAbsent: [           "do not set versionString for freshly minted baseline ...            see https://github.com/dalehenrich/metacello-work/issues/328"           ] ].  ^ versionInfo! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionInfo: aMetacelloProjectRegistrationVersionInfo  versionInfo := aMetacelloProjectRegistrationVersionInfo! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectVersion  ^ projectVersion! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectVersion: anObject  projectVersion := anObject! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setVersionString: anObject  "set versionString, only if it does not already have avalue"  versionString ifNil: [ self versionString: anObject ]! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString   ^versionString! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject  versionString := anObject.  projectVersion := nil! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineProjectSpecs    "MetacelloProjectRegistration baselineProjectSpecs"    | projectSpecs |    projectSpecs := OrderedCollection new.    self baselineRegistry        keysAndValuesDo: [ :className :registration | projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].    ^ projectSpecs asArray! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!baselineRegistry    baselineRegistry ifNil: [ baselineRegistry := Dictionary new ].    ^ baselineRegistry! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationProjectSpecs    "MetacelloProjectRegistration configurationProjectSpecs"    | projectSpecs |    projectSpecs := OrderedCollection new.    self configurationRegistry        keysAndValuesDo: [ :className :registration | projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].    ^ projectSpecs asArray! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationRegistry    configurationRegistry ifNil: [ configurationRegistry := Dictionary new ].    ^ configurationRegistry! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!isEmpty  ^ self configurationProjectSpecs isEmpty    and: [ self baselineProjectSpecs isEmpty ]! !!MetacelloProjectRegistry methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy    super postCopy.    baselineRegistry := self baselineRegistry copy.    configurationRegistry := self configurationRegistry copy! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegisterLoadedProjectSpec: projectSpec  MetacelloProjectRegistration    registrationForProjectSpec: projectSpec    ifAbsent: [ :new |       new        loadedInImage: true;        registerProject ]    ifPresent: [ :existing :new |       existing        copyOnWrite: [ :existingCopy |           existingCopy loadedInImage: true.          existing locked            ifFalse: [               "lock takes precedence when priming from image"              existingCopy merge: new ] ] ]! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegistryCurrentVersionFor: cl  ^ [ cl project currentVersion ]    on: Error    do: [ :ex |       Warning        signal:          'Error finding current version of ' , cl name asString            , '. Probably an invalid specification.'.      nil ]! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegistryFromImage  "MetacelloProjectRegistration primeRegistryFromImage"  self primeRegistryFromImage: false! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegistryFromImage: prioritizeConfiguration  "MetacelloProjectRegistration primeRegistryFromImage"  self    primeRegistryFromImage: MetacelloProjectRegistration configurationClasses    baselineClasses: MetacelloProjectRegistration baselineClasses    prioritizeConfiguration: prioritizeConfiguration! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses  "MetacelloProjectRegistration primeRegistryFromImage"  self    primeRegistryFromImage: configurationClasses    baselineClasses: baselineClasses    prioritizeConfiguration: false! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses prioritizeConfiguration: prioritizeConfiguration  "MetacelloProjectRegistration primeRegistryFromImage"  baselineClasses    do: [ :cl |       (self baselineRegistry includesKey: cl name asString)        ifFalse: [           "not registered"          (self primeRegistryCurrentVersionFor: cl)            ifNotNil: [ :version |               | projectSpec |              projectSpec := (version project projectSpec                name: (MetacelloScriptEngine baseNameOf: cl name asString);                repositories: version project projectPackage repositories copy;                yourself) asBaselineProjectSpec.              self primeRegisterLoadedProjectSpec: projectSpec ] ] ].  configurationClasses    do: [ :cl |       (self configurationRegistry includesKey: cl name asString)        ifFalse: [           "not registered"          (self primeRegistryCurrentVersionFor: cl)            ifNotNil: [ :version |               | projectSpec repos projectPackage project |              project := version project.              projectPackage := project projectPackage.              repos := nil.              projectPackage ~~ nil                ifTrue: [ repos := projectPackage repositories copy ].              projectSpec := (version project projectSpec                name: (MetacelloScriptEngine baseNameOf: cl name asString);                className: cl name asString;                versionString: version versionString;                repositories: repos;                yourself) asConfigurationProjectSpec.              (prioritizeConfiguration                or: [ (self primeRegistryProjectSpecRegistered: projectSpec) not ])                ifTrue: [                   "Configuration override existing registrations or nothing registered yet"                  self primeRegisterLoadedProjectSpec: projectSpec ] ] ] ]! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!primeRegistryProjectSpecRegistered: projectSpec  MetacelloProjectRegistration    registrationForProjectSpec: projectSpec    ifAbsent: [ :new | ^ false ]    ifPresent: [ :existing :new | ^ true ]! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!projectSpecForClassNamed: aClassName ifAbsent: absentBlock    ^ (self configurationRegistry        at: aClassName        ifAbsent: [ ^ (self baselineRegistry at: aClassName ifAbsent: [^absentBlock value]) baselineProjectSpec ])        configurationProjectSpec! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecs    "MetacelloProjectRegistration projectSpecs"    ^ self configurationProjectSpecs , self baselineProjectSpecs! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: '9/28/2017 08:54:38'!registerProjectRegistration: aMetacelloProjectRegistration  "unconditionally register <newRegistration> ... use with care"  aMetacelloProjectRegistration configurationProjectSpec copy    ifNotNil: [ :spec |       self configurationRegistry        at: spec className        ifPresent: [ :existing |           (existing configurationProjectSpec registrationsCompareEqual: spec)            ifFalse: [               Transcript                cr;                show:                    'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString                        , ' REPLACED BY '                        , aMetacelloProjectRegistration printString ] ].      spec versionOrNil        ifNotNil: [ :version |           "resolve symbolic versions for loaded projects"          spec versionString: version versionString ].      aMetacelloProjectRegistration configurationProjectSpec: spec.      (aMetacelloProjectRegistration respondsTo: #'versionInfo')        ifTrue: [ aMetacelloProjectRegistration versionInfo setVersionString: spec versionString ].      spec immutable.      self configurationRegistry        at: spec className        put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration baselineProjectSpec    ifNotNil: [ :spec |       self baselineRegistry        at: spec className        ifPresent: [ :existing |           (existing baselineProjectSpec registrationsCompareEqual: spec)            ifFalse: [               Transcript                cr;                show:                    'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString                        , ' REPLACED BY '                        , aMetacelloProjectRegistration printString ] ].      (aMetacelloProjectRegistration respondsTo: #'versionInfo')        ifTrue: [           aMetacelloProjectRegistration versionInfo            setVersionString: spec repositoryVersionString ].      spec immutable.      self baselineRegistry        at: spec className        put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration immutable! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: '9/28/2017 08:54:38'!registrationFor: aMetacelloProjectRegistration ifPresent: presentBlock ifAbsent: absentBlock    | baseName |    baseName := aMetacelloProjectRegistration baseName.    aMetacelloProjectRegistration configurationProjectSpec        ifNotNil: [ :spec | self configurationRegistry at: spec className ifPresent: [ :existing | ^ presentBlock value: existing ] ].    aMetacelloProjectRegistration baselineProjectSpec        ifNotNil: [ :spec | self baselineRegistry at: spec className ifPresent: [ :existing | ^ presentBlock value: existing ] ].    self configurationRegistry        at: 'ConfigurationOf' , baseName        ifPresent: [ :existing | ^ presentBlock value: existing ].    self baselineRegistry at: 'BaselineOf' , baseName ifPresent: [ :existing | ^ presentBlock value: existing ].    ^ absentBlock value! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!registrationForClassNamed: aClassName ifAbsent: absentBlock  ^ self    registrationForExactClassNamed: aClassName    ifAbsent: [       | baseName |      baseName := MetacelloScriptEngine baseNameOf: aClassName.      self configurationRegistry        at: 'ConfigurationOf' , baseName        ifPresent: [ :registration | ^ registration ].      self baselineRegistry        at: 'BaselineOf' , baseName        ifPresent: [ :registration | ^ registration ].      absentBlock value ]! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!registrationForExactClassNamed: aClassName ifAbsent: absentBlock  self configurationRegistry    at: aClassName    ifPresent: [ :registration | ^ registration ].  self baselineRegistry    at: aClassName    ifPresent: [ :registration | ^ registration ].  ^ absentBlock value! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!registrations  ^ self baselineRegistry values , self configurationRegistry values! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: '9/28/2017 08:54:38'!unregisterProjectRegistration: aMetacelloProjectRegistration    aMetacelloProjectRegistration configurationProjectSpec        ifNotNil: [ :spec |             self configurationRegistry                removeKey: spec className                ifAbsent: [ self error: 'unexpectedly missing project registration' ] ].    aMetacelloProjectRegistration baselineProjectSpec        ifNotNil: [ :spec | self baselineRegistry removeKey: spec className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ]! !!MetacelloProjectSpecForLoad methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasOverride    ^ self overrideProjectSpec ~~ nil! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!overrideProjectSpec	^ overrideProjectSpec! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!overrideProjectSpec: anObject	overrideProjectSpec := anObject! !!MetacelloProjectSpecForLoad methodsFor: 'operations' stamp: 'dkh 04/04/2016 13:06'!performCurrentVersionTestAgainst: vrsn operator: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader  "answer true if the current state of image is to be left as is"  | currentVersion existing new |  vrsn ifNil: [ ^ false ].  self useDetermineVersionForLoad    ifTrue: [       | prjct cv |      self hasOverride        ifTrue: [           self            error:              'unexpected logic combination: useDeterminVersionForLoad & hasOverride' ].      prjct := self projectSpec projectClassProject.      prjct loader: anMCLoader.      (cv := prjct currentVersion) == nil        ifTrue: [ ^ false ].      (targetVersionStatus includes: cv versionStatus)        ifTrue: [ ^ cv perform: anOperator with: vrsn ].      ^ false ].  true    ifTrue: [       "unconditional fail test at this point for Issue #388"      "https://github.com/dalehenrich/metacello-work/issues/388"      ^ false ].  (self hasOverride not or: [ targetVersionStatus ~= #(#'allLoadedToSpec') ])    ifTrue: [ ^ false ].  (self overrideProjectSpec allPackagesLoaded: anMCLoader)    ifFalse: [       "roughly equivalent to versionStatus test above (#'allLoadedToSpec')"      ^ false ].  (self overrideProjectSpec    isPartiallyLoaded: self overrideProjectSpec copy loader)    ifFalse: [       "if the project is not loaded at all"      ^ false ].  (currentVersion := self overrideProjectSpec versionOrNil) ifNil: [ ^ false ].  currentVersion = vrsn    ifTrue: [ ^ true ].  existing := self overrideProjectSpec asProjectRegistration.  new := self projectSpec asProjectRegistration.  ^ currentVersion > vrsn    ifTrue: [       "answer false if downgrade allowed"      (MetacelloAllowProjectDowngrade new        existingProjectRegistration: existing;        newProjectRegistration: new;        signal) == existing ]    ifFalse: [       "answer false if upgrade allowed"      (MetacelloAllowProjectUpgrade new        existingProjectRegistration: existing;        newProjectRegistration: new;        signal) == existing ]! !!MetacelloProjectSpecForLoad methodsFor: 'operations' stamp: '9/28/2017 08:54:38'!performLoad  | displayString spec |  spec := self projectSpec.  displayString := 'Project: ' , spec name.  spec versionString ~~ nil    ifTrue: [ displayString := displayString , ' ' , spec versionString ].  Transcript    cr;    show: displayString.  self hasOverride    ifTrue: [       | override |      override := self overrideProjectSpec copy.      override mergeScriptLoads: spec.      override loadVersion: nil ]    ifFalse: [       | vrsn |      vrsn := self useDetermineVersionForLoad        ifTrue: [ spec determineCurrentVersionForLoad ]        ifFalse: [ spec versionOrNil ].      (spec asProjectSpecForVersion: vrsn) loadVersion: vrsn ]! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec	^ projectSpec! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec: anObject	projectSpec := anObject! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!useDetermineVersionForLoad    useDetermineVersionForLoad ifNil: [ useDetermineVersionForLoad := true ].    ^ useDetermineVersionForLoad! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!useDetermineVersionForLoad: anObject	useDetermineVersionForLoad := anObject! !!MetacelloBaselineSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecCreationBlock    ^ [ :projectName | {(MetacelloMCBaselineProject new baselineOfProjectSpec name: projectName)} ]! !!MetacelloBaselineSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecListBlock    ^ [ MetacelloProjectRegistration baselineProjectSpecs ]! !!MetacelloBaselineSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecLookupBlock    ^ [ :projectName |     {(MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: projectName)        ifAbsent: [  ])} ]! !!MetacelloConfigurationSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecCreationBlock    ^ [ :projectName | {(MetacelloMCProject new configurationOfProjectSpec name: projectName)} ]! !!MetacelloConfigurationSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecListBlock    ^ [ MetacelloProjectRegistration configurationProjectSpecs ]! !!MetacelloConfigurationSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecLookupBlock    ^ [ :projectName |     {(MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: projectName)        ifAbsent: [  ])} ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecCreationBlock    ^ [ :projectName | {(MetacelloMCProject new projectSpec name: projectName)} ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecListBlock    ^ [ MetacelloProjectRegistration projectSpecs ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpecLookupBlock    ^ [ :projectName |     {(MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: projectName)        ifAbsent: [  ]).    (MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: projectName)        ifAbsent: [  ])} ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!target	^ target! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!target: anObject	target := anObject! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: '9/28/2017 08:54:38'!baseNameOf: className  ^ (className beginsWith: 'BaselineOf')    ifTrue: [ className copyFrom: 'BaselineOf' size + 1 to: className size ]    ifFalse: [       (className beginsWith: 'ConfigurationOf')        ifTrue: [ className copyFrom: 'ConfigurationOf' size + 1 to: className size ]        ifFalse: [ className ] ]! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: '9/28/2017 08:54:38'!baselineNameFrom: baseName    "Return the fully-qualified configuration class name."    ^ (baseName indexOfSubCollection: 'BaselineOf') > 0        ifTrue: [ baseName ]        ifFalse: [ 'BaselineOf' , baseName ]! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: '9/28/2017 08:54:38'!configurationNameFrom: baseName    "Return the fully-qualified configuration class name."    ^ (baseName indexOfSubCollection: 'ConfigurationOf') > 0        ifTrue: [ baseName ]        ifFalse: [ 'ConfigurationOf' , baseName ]! !!MetacelloScriptEngine class methodsFor: 'defaults' stamp: '9/28/2017 08:54:38'!defaultRepositoryDescription    DefaultRepositoryDescription        ifNil: [ DefaultRepositoryDescription := MetacelloPlatform current defaultRepositoryDescription ].    ^ DefaultRepositoryDescription! !!MetacelloScriptEngine class methodsFor: 'defaults' stamp: '9/28/2017 08:54:38'!defaultRepositoryDescription: descriptionOrNil  DefaultRepositoryDescription := descriptionOrNil! !!MetacelloScriptEngine class methodsFor: 'defaults' stamp: '9/28/2017 08:54:38'!defaultVersionString    DefaultVersionString ifNil: [ DefaultVersionString := #'stable' ].    ^ DefaultVersionString! !!MetacelloScriptEngine methodsFor: 'options' stamp: '9/28/2017 08:54:38'!cacheRepository    ^ (MetacelloMCProject new repositorySpec description: (self options at: #'cacheRepository' ifAbsent: [ ^ nil ]))        createRepository! !!MetacelloScriptEngine methodsFor: 'defaults' stamp: '9/28/2017 08:54:38'!defaultRepositoryDescription    ^ self class defaultRepositoryDescription! !!MetacelloScriptEngine methodsFor: 'defaults' stamp: '9/28/2017 08:54:38'!defaultVersionString    ^ self class defaultVersionString! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!fetch: required    self        fetchRecord: [ :version |             required isEmpty                ifTrue: [ version fetch ]                ifFalse: [ version fetch: required ] ]        required: required! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!fetchRecord: fetchRecordBlock required: required  MetacelloProjectRegistration    copyRegistryWhile: [       self        handleNotificationsForAction: [           | version loadedSpec |          self setDefaultsAndValidateProjectSpec.          [ loadedSpec := self lookupProjectSpecFor: self projectSpec ]            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade            do: [ :notification |               notification                handleOnDownGrade: [ :ex :existing :new | ex allowEvenIfLocked ]                onUpgrade: [ :ex :existing :new | ex allowEvenIfLocked ] ].          version := loadedSpec versionForScriptEngine: self.          self root: (fetchRecordBlock value: version) loadDirective ] ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!get  " load a fresh copy from repo"  | spec projectPackage |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidateProjectSpec.      spec := self projectSpec.      projectPackage := spec projectPackage.      projectPackage repositorySpecs        do: [ :repoSpec | repoSpec createRepository flushForScriptGet ].      self cacheRepository        ifNotNil: [ :cacheRepository | projectPackage loader loaderPolicy cacheRepository: cacheRepository ].      projectPackage load.      self root: (Smalltalk at: spec className asSymbol) project.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :new | new registerProject ]        ifPresent: [ :existing :new |           existing            copyOnWrite: [ :existingCopy |               spec                copyForRegistration: existingCopy                onWrite: [ :specCopy |                   specCopy                    ifNil: [ existingCopy merge: new ]                    ifNotNil: [ specCopy mergeScriptRepository: spec ] ] ] ] ]! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!getBaselineProjectUnconditionalLoad: unconditionalLoad    | project |    project := (self getBaselineUnconditionalLoad: unconditionalLoad) project.    project version spec repositories: self repositories copy.    ^ project! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!getBaselineUnconditionalLoad: unconditionalLoad  | spec |  spec := self projectSpec.  Smalltalk    at: spec className asSymbol    ifPresent: [ :cl |       unconditionalLoad        ifFalse: [ ^ cl ] ].  spec := self lookupProjectSpecFor: spec.  [ spec projectPackage load ]    on: MetacelloIgnorePackageLoaded    do: [ :ex |       "see https://github.com/dalehenrich/metacello-work/issues/244 ... uncoditionally load        baseline"      ex resume: true ].  ^ Smalltalk at: spec className asSymbol! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!getConfigurationProjectUnconditionalLoad: unconditionalLoad    ^ (self getConfigurationUnconditionalLoad: unconditionalLoad) project! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!getConfigurationUnconditionalLoad: unconditionalLoad    | spec |    spec := self projectSpec.    Smalltalk        at: spec className asSymbol        ifPresent: [ :cl |             unconditionalLoad                ifFalse: [ ^ cl ] ].    (spec := self lookupProjectSpecFor: spec) projectPackage load.    ^ Smalltalk at: spec className asSymbol! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleConflict: exception    ^ (self options at: #'onConflict' ifAbsent: [ ^ exception pass ])        cull: exception        cull: exception existingProjectRegistration        cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleDowngrade: exception    ^ (self options at: #'onDowngrade' ifAbsent: [ ^ exception pass ])        cull: exception        cull: exception existingProjectRegistration        cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleEnsureProjectLoadedForDevelopment: exception    "if useCurrentVersion resume with true, else resume with false"    ^ exception resume: self useCurrentVersion! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleLock: exception  ^ (self options at: #'onLock' ifAbsent: [ ^ exception pass ])    cull: exception    cull: exception existingProjectRegistration    cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleLookupBaselineSpecForEnsureLoad: exception  "if requested and registered don't compare equal, then ensure the new baseline is loaded"  | requested registered |  requested := exception projectSpec.  registered := self lookupProjectSpecFor: exception projectSpec.  ^ exception resume: (registered compareEqual: requested) not! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleLookupProjectSpec: exception    ^ exception        resume:            ((self lookupProjectSpecFor: exception projectSpec) ifNil: [ ^ exception resume: exception projectSpec ])! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleLookupProjectSpecForLoad: exception  "if overrideProjectSpec is nil, use currentVersion in image, ignoreImage is false"  | requested override |  requested := exception projectSpec.  override := self useCurrentVersion    ifTrue: [       "don't do lookup in registry if we expect to use the #currentVersion calculation"      nil ]    ifFalse: [       | registered |      registered := self lookupProjectSpecFor: exception projectSpec.      (registered compareEqual: requested)        ifFalse: [           "counts as override, only if they differ in some aspect"          override := registered ] ].  ^ exception    resume:      (MetacelloProjectSpecForLoad new        projectSpec: requested;        useDetermineVersionForLoad: self useCurrentVersion;        overrideProjectSpec: override;        yourself)! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleNotificationsForAction: actionBlock  [   [   [   actionBlock    on:      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad        , MetacelloProjectSpecLoadedNotification        , MetacelloScriptEnsureProjectLoadedForDevelopment        , MetacelloLookupBaselineSpecForEnsureLoad    do: [ :ex |       "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"      ex handleResolutionFor: self ] ]    on:      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade        , MetacelloAllowConflictingProjectUpgrade    do: [ :ex |       "option handlers need to be outermost set of handlers ... last line of defense before users are involved"      ex handleResolutionFor: self ] ]    on: MetacelloAllowLockedProjectChange    do: [ :ex |       "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"      ex handleResolutionFor: self ] ]    on: Warning    do: [ :ex |       "Warning is absolute outermost handler"      self handleWarning: ex ]! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleProjectSpecLoaded: exception    MetacelloProjectRegistration        registrationForProjectSpec: exception projectSpec        ifAbsent: [ :new |             new                loadedInImage: true;                registerProject ]        ifPresent: [ :existing :new |             "unconditionally merge new with existing (updates registration)"            existing                copyOnWrite: [ :existingCopy |                     existingCopy                        loadedInImage: true;                        merge: new ] ].    exception resume! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleUpgrade: exception    ^ (self options at: #'onUpgrade' ifAbsent: [ ^ exception pass ])        cull: exception        cull: exception existingProjectRegistration        cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: '9/28/2017 08:54:38'!handleWarning: exception  ^ (self options at: #'onWarning' ifAbsent: [ ^ exception pass ])    cull: exception! !!MetacelloScriptEngine methodsFor: 'options' stamp: '9/28/2017 08:54:38'!ignoreImage    ^ self options at: #'ignoreImage' ifAbsent: [ false ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!list  self setDefaultsAndValidateProjectSpec.  self root: self projectSpec! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!load: required    self        load: required        onProjectDownGrade: [ :ex :existing :new | ex allowEvenIfLocked ]        onProjectUpgrade: [ :ex :existing :new | ex allowEvenIfLocked ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!load: required onProjectDownGrade: onDownGradeBlock onProjectUpgrade: onUpgradeBlock  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self        handleNotificationsForAction: [           | version loadedSpec |          self setDefaultsAndValidateProjectSpec.          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].          version := loadedSpec versionForScriptEngine: self.          self            root:              (required isEmpty                ifTrue: [ version load ]                ifFalse: [ version load: required ]) loadDirective.          loadedSpec loads: required.          MetacelloProjectRegistration            registrationForProjectSpec: loadedSpec            ifAbsent: [ :new |               new                loadedInImage: true;                registerProject ]            ifPresent: [ :existing :new |               existing                copyOnWrite: [ :existingCopy |                   existingCopy                    loadedInImage: true;                    merge: new ] ] ] ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!lock  | spec |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"      spec := self projectSpec.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :new |           new            locked: true;            registerProject ]        ifPresent: [ :existing :new |           existing            copyOnWrite: [ :existingCopy |               existingCopy locked: true.              spec                copyForRegistration: existingCopy                onWrite: [ :specCopy |                   specCopy                    ifNil: [ existingCopy merge: new ]                    ifNotNil: [                       specCopy mergeScriptRepository: spec.                      spec := specCopy ] ] ] ].      self root: spec ]! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!lookupProjectSpecFor: aProjectSpec  "if there is no conflict, choose new spec"  | registration |  registration := MetacelloProjectRegistration    registrationForProjectSpec: aProjectSpec    ifAbsent: [ :new | new ]    ifPresent: [ :existing :new |       (existing hasLoadConflicts: new)        ifTrue: [           ((existing canUpgradeTo: new)            ifTrue: [ MetacelloAllowProjectUpgrade new ]            ifFalse: [               (existing canDowngradeTo: new)                ifTrue: [ MetacelloAllowProjectDowngrade new ]                ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])            existingProjectRegistration: existing;            newProjectRegistration: new;            signal ]        ifFalse: [ new ] ].  ^ registration projectSpec! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!options    options ifNil: [ options := Dictionary new ].    ^ options! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!options: aDictionary    options := aDictionary! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectName    ^ self projectSpec name! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec    ^ projectSpec! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectSpec: aProjectSpec    projectSpec := aProjectSpec! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!record: required    self        fetchRecord: [ :version |             required isEmpty                ifTrue: [ version record ]                ifFalse: [ version record: required ] ]        required: required! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!register  | spec |  self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"  spec := self projectSpec.  MetacelloProjectRegistration    registrationForProjectSpec: spec    ifAbsent: [ :new | new registerProject ]    ifPresent: [ :existing :new | existing copyOnWrite: [ :existingCopy | existingCopy merge: new ] ].  self root: spec! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositories    ^ self projectSpec repositories! !!MetacelloScriptEngine methodsFor: 'options' stamp: '9/28/2017 08:54:38'!repositoryOverrides    ^ (self options at: #'repositoryOverrides' ifAbsent: [ ^ nil ])        collect: [ :description | (MetacelloMCProject new repositorySpec description: description) createRepository ]! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!root	^ root! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!root: anObject	root := anObject! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!setDefaultsAndValidate: aProjectSpec  "NOTE: aProjectSpec has defaults assigned if versionString or repository missing"  | issues |  issues := aProjectSpec    validateForScriptLoad: self    withDefaultVersionString: self defaultVersionString    withDefaultRepositoryDecription: self defaultRepositoryDescription.  issues isEmpty    ifTrue: [ ^ self ].  (MetacelloValidationFailure    issues: issues    message: 'Project spec validation failure') signal! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: '9/28/2017 08:54:38'!setDefaultsAndValidateProjectSpec  "NOTE: projectSpec has defaults assigned if versionString or repository missing"  self setDefaultsAndValidate: self projectSpec! !!MetacelloScriptEngine methodsFor: 'options' stamp: '9/28/2017 08:54:38'!silently    ^ self options at: #'silently' ifAbsent: [ false ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!unlock  | spec |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"      spec := self projectSpec.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :ignored |  ]        ifPresent: [ :existing :new | existing copyOnWrite: [ :existingCopy | existingCopy locked: false ] ].      self root: spec ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!unregister  | spec |  self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"  spec := self projectSpec.  MetacelloProjectRegistration    registrationForProjectSpec: spec    ifAbsent: [ :ignored |  ]    ifPresent: [ :existing :new | existing unregisterProject ].  self root: spec! !!MetacelloScriptEngine methodsFor: 'options' stamp: '9/28/2017 08:54:38'!useCurrentVersion    "private option used to implement the classic mode"    ^ self options at: #'useCurrentVersion' ifAbsent: [ false ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!executeBlock: selectBlock do: projectSpecBlock    (self projectSpecsFromRepositoryArg select: selectBlock)        do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!executeCollection: aCollection do: projectSpecBlock    self projectSpecsFromRepositoryArg        do: [ :projectSpec |             (aCollection includes: (MetacelloScriptEngine baseNameOf: projectSpec className))                ifTrue: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!executeString: aString do: projectSpecBlock  singleRoot ifNil: [ self singleRoot: true ].  (projectSpecGenerator projectSpecCreationBlock value: aString)    do: [ :projectSpec |       projectSpec        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!projectSpecsFromRepositoryArg    | spec repo projectSpecs |    repositoryArg ifNil: [ ^ #() ].    spec := (projectSpecGenerator projectSpecCreationBlock value: 'xxx') first.    repo := spec project createRepository: (spec project repositorySpec description: repositoryArg).    projectSpecs := OrderedCollection new.    ((Gofer new disablePackageCache        repository: repo;        allResolved) collect: [ :resolvedReference | resolvedReference packageName ]) asSet        do: [ :packageName |             (projectSpecGenerator projectSpecCreationBlock value: (MetacelloScriptEngine baseNameOf: packageName))                do: [ :projectSpec |                     projectSpec className = packageName                        ifTrue: [ projectSpecs add: (self applyArgsToProjectSpec: projectSpec copy) ] ] ].    ^ projectSpecs! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'ct 11/7/2020 14:05'!applyArgsToProjectSpec: aProjectSpec    classNameArg ifNotNil: [ aProjectSpec className: classNameArg ].    versionArg ifNotNil: [ aProjectSpec versionString: versionArg ].    repositoryArg ifNotNil: [ aProjectSpec repository: repositoryArg ].    usernameArg ifNotNil: [ aProjectSpec username: usernameArg ].    passwordArg ifNotNil: [ aProjectSpec password: passwordArg ].    ^ aProjectSpec! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!baselineArg	^ baselineArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!baselineArg: anObject	baselineArg := anObject! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!cacheRepository: aRepositoryDescription    self options at: #'cacheRepository' put: aRepositoryDescription! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!classNameArg    ^ classNameArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!classNameArg: anObject    classNameArg := anObject! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!configurationArg    ^ configurationArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!configurationArg: anObject    configurationArg := anObject! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: '9/28/2017 08:54:38'!execute: statements  statements    do: [ :assoc |       assoc value        ifNil: [ self perform: assoc key ]        ifNotNil: [ self perform: assoc key withArguments: assoc value ] ].  projectSpecGenerator := self projectSpecGenerator.  projectSpecGenerator target    execute: [ :projectSpec |       | engine |      engine := MetacelloScriptEngine new        options: self options copy;        projectSpec: projectSpec;        yourself.      engine perform: actionArg key withArguments: actionArg value.      engine root ifNotNil: [ :root | self roots add: root ] ]    against: self.  ^ (self singleRoot and: [ self roots size == 1 ])    ifTrue: [ self roots first ]    ifFalse: [ self roots ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!executeBlock: selectBlock do: projectSpecBlock    ((projectSpecGenerator projectSpecListBlock value select: selectBlock) select: self projectSpecSelectBlock)        do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!executeCollection: aCollection do: projectSpecBlock    aCollection        do: [ :projectName |             ((projectSpecGenerator projectSpecLookupBlock value: projectName) select: self projectSpecSelectBlock)                do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!executeString: aString do: projectSpecBlock  singleRoot ifNil: [ self singleRoot: true ].  ((projectSpecGenerator projectSpecLookupBlock value: aString)    select: self projectSpecSelectBlock)    do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!fetch: required    actionArg := #'fetch:' -> {required}! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!get    actionArg := #'get' -> #()! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!ignoreImage: aBool    self options at: #'ignoreImage' put: aBool! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!list  actionArg := #'list' -> #().  self singleRoot: false! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!load: required    actionArg := #'load:' -> {required}! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!lock    actionArg := #'lock' -> #()! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!onConflict: aBlock    self options at: #'onConflict' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!onDowngrade: aBlock    self options at: #'onDowngrade' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!onLock: aBlock  self options at: #'onLock' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!onUpgrade: aBlock    self options at: #'onUpgrade' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!onWarning: aBlock  self options at: #'onWarning' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!options    options ifNil: [ options := Dictionary new ].    ^ options! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'ct 11/1/2020 21:53'!passwordArg	^ passwordArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'ct 11/1/2020 21:52'!passwordArg: anObject	passwordArg := anObject! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!projectArg    ^ projectArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!projectArg: anObject    projectArg := anObject! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: '9/28/2017 08:54:38'!projectSpecGenerator    baselineArg        ifNotNil: [             configurationArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].            projectArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].            ^ MetacelloBaselineSpecGenerator new                target: baselineArg;                yourself ].    configurationArg        ifNotNil: [             baselineArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].            projectArg ifNotNil: [ self error: ' configuration and project are both be specified' ].            ^ MetacelloConfigurationSpecGenerator new                target: configurationArg;                yourself ].    projectArg        ifNotNil: [             configurationArg ifNotNil: [ self error: ' project and configuration: are both be specified' ].            baselineArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].            ^ MetacelloProjectSpecGenerator new                target: projectArg;                yourself ].    self error: 'project, baseline, or configuration not specified'! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!projectSpecSelectBlock    ^ [ :projectSpec | true ]! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!record: required    actionArg := #'record:' -> {required}! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!register  actionArg := #'register' -> #()! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!repositoryArg    ^ repositoryArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!repositoryArg: anObject    repositoryArg := anObject! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!repositoryOverrides: aRepositoryDescriptionList    self options at: #'repositoryOverrides' put: aRepositoryDescriptionList! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!roots    roots ifNil: [ roots := OrderedCollection new ].    ^ roots! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!silently: aBool    self options at: #'silently' put: aBool! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!singleRoot  singleRoot ifNil: [ singleRoot := false ].  ^ singleRoot! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!singleRoot: aBool  singleRoot := aBool! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!unlock    actionArg := #'unlock' -> #()! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!unregister  actionArg := #'unregister' -> #()! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: '9/28/2017 08:54:38'!useCurrentVersion: aBool    "private option used to implement the classic mode"    self options at: #'useCurrentVersion' put: aBool! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'ct 11/1/2020 21:56'!usernameArg	^ usernameArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'ct 11/1/2020 21:57'!usernameArg: aString	usernameArg := aString! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!versionArg    ^ versionArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: '9/28/2017 08:54:38'!versionArg: anObject    versionArg := anObject! !!MetacelloScriptImageExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!projectSpecSelectBlock    ^ [ :projectSpec |     projectSpec        ifNil: [ false ]        ifNotNil: [             MetacelloProjectRegistration                registrationForProjectSpec: projectSpec                ifAbsent: [ false ]                ifPresent: [ :existingRegistration :newRegistration | existingRegistration loadedInImage ] ] ]! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!prime! !!MetacelloScriptRegistryExecutor methodsFor: 'execution callback' stamp: '9/28/2017 08:54:38'!projectSpecSelectBlock  ^ [ :projectSpec | projectSpec notNil ]! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!remove! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: '9/28/2017 08:54:38'!reset! !!MetacelloAbstractPackageSpec methodsFor: 'adding' stamp: '9/28/2017 08:54:38'!addToMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!answers	answers == nil ifTrue: [ answers := #() ].	^answers! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!answers: aListOfPairs	self setAnswers: aListOfPairs! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodBodyOn: aStream hasName: hasName cascading: cascading indent: indent	| hasCascading hasRequires hasIncludes hasAnswers |	hasCascading := cascading.	hasRequires := self requires isEmpty not.	hasIncludes := self includes isEmpty not.	hasAnswers := self answers isEmpty not.	hasRequires		ifTrue: [ 			hasName | hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'requires: #('.			self requires do: [:str | aStream nextPutAll: str printString, ' ' ].			hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasIncludes		ifTrue: [ 			hasName | hasRequires | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'includes: #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasAnswers		ifTrue: [ 			hasName | hasRequires | hasIncludes | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'supplyingAnswers: #( '.			self answers do: [:ar | 				aStream nextPutAll: '#( '.				ar do: [:val | 					(val isString or: [ val isNumber or: [ val isSymbol or: [ val isCharacter ]]])						ifTrue: [  aStream nextPutAll: val printString, ' ' ].					val == true						ifTrue: [  aStream nextPutAll: 'true ' ].					val == false						ifTrue: [  aStream nextPutAll: 'false ' ]].				aStream nextPutAll: ') ' ].			hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream for: aValue selector: selector cascading: cascading cascade: cascade indent: indent	| valuePrintString |	aValue == nil ifTrue: [ ^self ].	cascading ifTrue: [ aStream cr; tab: indent ].	valuePrintString := aValue value isSymbol		ifTrue: [ '#' , aValue value asString printString ]		ifFalse: [ aValue value printString ].	aStream  nextPutAll: selector, valuePrintString.	cascade ifTrue: [ aStream nextPut: $; ]! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: '9/28/2017 08:53:29'!file 	"MetacelloPackageSpec compatibility"		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!forceUpdatePackageSpec: updatedSpecs using: anMCLoader	^self updatePackageSpec: updatedSpecs using: anMCLoader! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: '9/28/2017 08:53:29'!getFile  "MetacelloPackageSpec compatibility"  ^ nil! !!MetacelloAbstractPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasRepository    ^ false! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!includeSpecNamesForPackageOrdering: aVersionSpec  ^ self specs: self includesForPackageOrdering forPackageOrdering: aVersionSpec! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!includes	includes == nil ifTrue: [ includes := #() ].	^includes! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!includes: aCollection	aCollection setIncludesInMetacelloPackage: self! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!includesForPackageOrdering  ^ #()! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: '9/28/2017 08:53:29'!isPackageLoaded	^false! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!label	^self name! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!loadUsing: aLoader gofer: gofer	^self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap	| map |	map := super mergeMap.	map at: #requires put: requires.	map at: #includes put: includes.	map at: #answers put: answers.	^map! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeSpec: anotherSpec	| newSpec map anotherRequires anotherIncludes anotherAnswers |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	anotherSpec name ~~ nil 		ifTrue: [ newSpec name: anotherSpec name ].	(anotherRequires := map at: #requires) ~~ nil		ifTrue: [ newSpec setRequires: self requires, anotherRequires ].	(anotherIncludes := map at: #includes) ~~ nil		ifTrue: [ newSpec setIncludes: self includes, anotherIncludes ].	(anotherAnswers := map at: #answers) ~~ nil		ifTrue: [ newSpec setAnswers: self answers, anotherAnswers ].	^newSpec! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!name	^name! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!name: aString    ((aString at: 1) isSeparator or: [ (aString at: aString size) isSeparator ])        ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , aString printString ].    name := aString! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!nonOverridable	^#( includes requires answers )! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	"noop by default"! !!MetacelloAbstractPackageSpec methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy	super postCopy.	requires := requires copy.	includes := includes copy.	answers := answers copy.! !!MetacelloAbstractPackageSpec methodsFor: 'visiting' stamp: '9/28/2017 08:54:38'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!referencedSpec	^self! !!MetacelloAbstractPackageSpec methodsFor: 'removing' stamp: '9/28/2017 08:54:38'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 6/30/2012 12:32'!repository    self deprecated: 'Use repositories or repositorySpecs'.    ^ nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!repositorySpecs	^#()! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!requiredSpecNamesForPackageOrdering: aVersionSpec  ^ (self requiredSpecsForPackageOrdering: aVersionSpec)    collect: [ :spec | spec name ]! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!requiredSpecsForPackageOrdering: aVersionSpec  ^ self specs: self requires forPackageOrdering: aVersionSpec! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!requires	requires == nil ifTrue: [ requires := #() ].	^requires! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!requires: aCollection	aCollection setRequiresInMetacelloPackage: self! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!requiresSpecsForPackageOrdering: aVersionSpec  ^ {self}! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!resolveSpecsForPackageOrdering: aVersionSpec  ^ {self}! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToAllPackagesIn: aVersionSpec into: packages visited: visited	visited		visit: self		doing: [:spec |			self visitingWithPackages: packages.			(spec includes, spec requires) do: [:pkgName |				(aVersionSpec packageNamed: pkgName)					projectDo: [:prj | 						(prj resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg | 							packages at: pkg name put: pkg ]] 					packageDo: [:pkg | 						packages at: pkg name put: pkg.						(pkg resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:rpkg | 							packages at: rpkg name put: rpkg ] ] 					groupDo: [:grp | grp resolveToAllPackagesIn: aVersionSpec into: packages  visited: visited ]]]! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToAllPackagesIn: aVersionSpec visited: visited	| packages |	packages := Dictionary new.	self resolveToAllPackagesIn: aVersionSpec into: packages visited: visited.	^packages values asOrderedCollection! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToLoadableSpec	^self! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^ self resolveToPackagesIn: aVersionSpec visited: visited! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec visited: visited	^self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setAnswers: aCollection	answers := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setIncludes: aCollection	includes := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setRequires: aCollection	requires := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!specs: specNames forPackageOrdering: aVersionSpec  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  specNames    do: [ :specName |       | spec |      "get project/group/package specs"      spec := aVersionSpec        packageNamed: specName        ifAbsent: [           MetacelloNameNotDefinedError            signal:              'project group, or package named: ' , specName printString                ,                  ' not found when used in requires: or includes: field of package: '                , self name printString , ' for version: '                , aVersionSpec versionString , ' of '                , aVersionSpec projectLabel , '.'.          nil	"return nil if resumed" ].      spec        ifNotNil: [           packageOrProjectSpecs            addAll: (spec resolveSpecsForPackageOrdering: aVersionSpec) ] ].  ^ packageOrProjectSpecs! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	answers := name := requires := includes := nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!updatePackageRepositoriesFor: aVersionSpec	"noop by default"		^true! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: '9/28/2017 08:53:29'!version 	"MetacelloPackageSpec compatibility"		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!visitingWithPackages: packages	"noop"! !!MetacelloGroupSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!answers: aListOfPairs	self shouldNotImplement! !!MetacelloGroupSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector == #remove:		ifTrue: [ aStream nextPutAll: 'removeGroup: ', self name printString. ]		ifFalse: [			aStream 				nextPutAll: 'group: ', self name printString;				space; 				nextPutAll: aMember methodUpdateSelector asString, ' #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			aStream nextPut: $) ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloGroupSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream hasName: true cascading: false indent: indent + 1.	aStream nextPut: $.! !!MetacelloGroupSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!includeSpecNamesForPackageOrdering: aVersionSpec  ^ #()! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!loadUsing: aLoader gofer: gofer	"noop"! !!MetacelloGroupSpec methodsFor: 'visiting' stamp: '9/28/2017 08:54:38'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	groupBlock value: self! !!MetacelloGroupSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!requiredSpecsForPackageOrdering: aVersionSpec  ^ #()! !!MetacelloGroupSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!requires: aCollection	self shouldNotImplement! !!MetacelloGroupSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!requiresSpecsForPackageOrdering: aVersionSpec  "expand the names in the group to a package or project"  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  self includes    do: [ :specName |       (aVersionSpec packageNamed: specName ifAbsent: [  ])        ifNotNil: [ :pkgSpec |           packageOrProjectSpecs            addAll:              (pkgSpec                resolveToPackagesIn: aVersionSpec                andProjects: true                visited: MetacelloVisitedPackages new) ] ].  ^ packageOrProjectSpecs! !!MetacelloGroupSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!resolveSpecsForPackageOrdering: aVersionSpec  "expand the names in the group to a package or project"  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  self includes    do: [ :specName |       (aVersionSpec packageNamed: specName ifAbsent: [  ])        ifNotNil: [ :pkgSpec |           packageOrProjectSpecs            addAll:              (pkgSpec                resolveToPackagesIn: aVersionSpec                andProjects: true                visited: MetacelloVisitedPackages new) ] ].  ^ packageOrProjectSpecs! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToLoadableSpec	^nil! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool into: packages visited: visited  visited    visit: self    doing: [ :aSpec |       | map |      map := aVersionSpec packages map.      aSpec includes        do: [ :pkgName |           (aVersionSpec packageNamed: pkgName forMap: map ifAbsent: [  ])            projectDo: [ :prj |               andProjectsBool                ifTrue: [ packages at: prj name put: prj ] ]            packageDo: [ :pkg | packages at: pkg name put: pkg ]            groupDo: [ :grp |               grp                resolveToPackagesIn: aVersionSpec                andProjects: andProjectsBool                into: packages                visited: visited ] ] ]! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  | packages |  packages := Dictionary new.  self    resolveToPackagesIn: aVersionSpec    andProjects: andProjectsBool    into: packages    visited: visited.  ^ packages values asOrderedCollection! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec into: packages visited: visited  self    resolveToPackagesIn: aVersionSpec    andProjects: false    into: packages    visited: visited! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec visited: visited  | packages |  packages := Dictionary new.  self    resolveToPackagesIn: aVersionSpec    andProjects: false    into: packages    visited: visited.  ^ packages values asOrderedCollection! !!MetacelloCypressPackageSpec methodsFor: 'querying' stamp: '09/01/2013 00:03'!ancestors  ^ nil! !!MetacelloCypressPackageSpec methodsFor: 'testing' stamp: '08/31/2013 23:57'!compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader  ^ false! !!MetacelloCypressPackageSpec methodsFor: 'querying' stamp: '08/31/2013 23:54'!isPackageLoaded: aLoader  MCWorkingCopy allManagers    detect: [ :wc | wc packageName = self file ]    ifNone: [ ^ false ].  ^ true! !!MetacelloCypressPackageSpec methodsFor: 'fetching' stamp: 'dkh 07/07/2016 10:30'!searchCacheRepositoryForPackage: searchBlock  "evaluate the <searchBlock> if you want to search for the package in a local package cache"  "for Cypress packages the answer is NO!!"! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: '9/28/2017 08:53:29'!ancestors	^self goferPackage ancestors! !!MetacelloPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	self 		currentPackageLoaded: [:bool | ^bool ] 		comparing: anOperator 		notLoaded: [:ignored | ^false ]		using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!compareRelativeCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	^self compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!compareWorkingCopyNamed: wcName using: comarisonOperator	| fileRef wcRef |	fileRef := GoferResolvedReference name: self file.	wcRef := GoferResolvedReference name: wcName.	^ wcRef compare: fileRef using: comarisonOperator! !!MetacelloPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodBodyOn: aStream hasName: hasName indent: indent	| hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	hasRequiresOrIncludesOrAnswers		ifTrue: [ 			self 				configMethodBodyOn: aStream 				hasName: hasName 				cascading: hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt				indent: indent ].	self 		configMethodOn: aStream 		for: file 		selector: 'file: ' 		cascading: hasName | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt 		indent: indent.	hasRepositories		ifTrue: [ 			(self repositorySpecs size > 1)				ifTrue: [ 					hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers						ifTrue: [ 							aStream cr;							tab: indent. ].					aStream 						nextPutAll: 'repositories: ['; 						cr;						tab: indent + 1;						nextPutAll: 'spec'; 						cr.					self repositories configMethodCascadeOn: aStream indent: indent + 1.					aStream nextPutAll: ' ]' ]				ifFalse: [ 					hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers						ifTrue: [ aStream cr; tab: indent ].					self repositories configMethodCascadeOn: aStream indent: indent ].			hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream nextPut: $; ] ].	self 		configMethodOn: aStream 		for: self getPreLoadDoIt 		selector: 'preLoadDoIt: '		cascading: hasName | hasFile | hasRepositories | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: hasPostLoadDoIt 		indent: indent.	self 		configMethodOn: aStream 		for: self getPostLoadDoIt 		selector: 'postLoadDoIt: ' 		cascading: hasName | hasFile | hasRepositories | hasPreLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: false 		indent: indent.	aStream nextPut: $.! !!MetacelloPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector  == #remove:		ifTrue: [ aStream  nextPutAll: 'removePackage: ', self name printString ]		ifFalse: [ self configShortCutMethodBodyOn: aStream member: aMember indent: indent ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ]! !!MetacelloPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodOn: aStream indent: indent	| hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers hasFile |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	aStream tab: indent; nextPutAll: 'spec '.	hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers		ifTrue: [			aStream cr; tab: indent + 1; nextPutAll: 'name: ', self name printString; nextPut: $;.			self configMethodBodyOn: aStream hasName: true indent: indent + 1 ]		ifFalse: [			aStream nextPutAll: 'name: ', self name printString ]! !!MetacelloPackageSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configShortCutMethodBodyOn: aStream member: aMember indent: indent	| hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers		ifTrue: [			aStream 				nextPutAll: 'package: ', self name printString, ' ';				nextPutAll: aMember methodUpdateSelector asString, ' ['; cr.			aStream tab: indent + 1; nextPutAll: 'spec '.			self configMethodBodyOn: aStream hasName: false indent: indent + 2.			aStream nextPutAll: ' ]'.			^self ].	aStream nextPutAll: 'package: ', self name printString.	hasFile		ifTrue: [ aStream nextPutAll: ' with: ', file printString ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!copySpecTo: aRepositorySpec	"Copy current mcz file to the repository named in aRepositorySpec"	self loader copySpec: self from: self repositorySpecs to: aRepositorySpec createRepository! !!MetacelloPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!currentPackageLoaded: loadedBlock comparing: comarisonOperator notLoaded: notLoadedBlock using: anMCLoader  "Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"  | wcName vis |  vis := anMCLoader ancestorsFor: self.  vis notNil    ifTrue: [       | fileRef wcRef |      self getFile == nil        ifTrue: [ ^ loadedBlock value: false ].      vis        do: [ :vi |           wcName := vi name.          fileRef := GoferVersionReference name: self file.          fileRef versionNumber = 0            ifTrue: [               "a shame that GoferVersionReference doesn't have better method for recognizing a missing verion number"              "fix for: https://github.com/dalehenrich/metacello-work/issues/185"              ^ loadedBlock value: false ].          wcRef := GoferVersionReference name: wcName.          (wcRef compare: fileRef using: comarisonOperator)            ifTrue: [ ^ loadedBlock value: true ] ].      ^ loadedBlock value: false ].  ^ notLoadedBlock value: true! !!MetacelloPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!currentPackageLoaded: loadedBlock notLoaded: notLoadedBlock using: anMCLoader	"Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"	| vis |	vis := anMCLoader ancestorsFor: self.	vis notNil		ifTrue: [ 			self getFile == nil				ifTrue: [ ^ loadedBlock value: #() value: self file ].			^ loadedBlock value: vis value: self file ].	^ notLoadedBlock value! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: '9/28/2017 08:53:29'!currentVersionInfo	^self goferPackage currentVersionInfo! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureLoadUsing: mcLoader	self explicitLoadUsing: mcLoader ensureSpecLoader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureLoadedForDevelopmentUsing: mcLoader	"noop"		^true! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!explicitLoadUsing: mcLoader	| wc fetchingSpecLoader |	((wc := self workingCopy) ~~ nil and: [ wc needsSaving ]) 		ifTrue: [ 			(MetacelloSkipDirtyPackageLoad signal: self)				ifTrue:  [					Transcript cr; show: 'Skipping load of modified package: ', self file.					^self]				ifFalse: [Transcript cr; show: 'Load over modified package: ', self file] ].	"fetch and explicitly load it"	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		explicitLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!extractNameFromFile	file == nil ifTrue: [ ^nil ].	^(self loader nameComponentsFrom: self file) first! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!fetch	self fetchUsing: self loader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!fetchPackage: aLoaderPolicy	self fetchUsing: 		(self loader			loaderPolicy: aLoaderPolicy;			yourself)! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!fetchUsing: mcLoader	| fetchingSpecLoader |	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		linearLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!file	file == nil ifTrue: [ ^self name ].	^file! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!file: aString	file := aString! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!file: aString constructor: aVersionConstructor    aVersionConstructor fileForPackage: aString! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!forceUpdatePackageSpec: updatedSpecs using: anMCLoader		self updatePackageSpec: updatedSpecs force: true using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!getFile	"raw access to iv"		^file! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!getName    "raw access to iv"    ^ name! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!getPostLoadDoIt	^postLoadDoIt! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!getPreLoadDoIt	^preLoadDoIt! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!getRepositories    "raw access to iv"    ^ repositories! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!goferBranchPackage: branchName message: commitMessage	"uses gofer to do commit ... non-interactive"	| latestFile pkgSpec   |	(file notNil and: [ (self name, '.', branchName) = self file ])		ifTrue: [ 			latestFile := self loader latestPackage: self file fromRepository: self repositorySpecs.			pkgSpec := self copy.			latestFile ~~ nil				ifTrue: [ 					pkgSpec file: latestFile.					pkgSpec goferCommitPackage: commitMessage.					^ self ] ].	self loader goferCommitBranchPackage: branchName using: self repositorySpecs commitMessage: commitMessage! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!goferCommitPackage: commitMessage	"uses gofer to do commit ... non-interactive"		| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec goferCommitPackage: commitMessage ]		ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: commitMessage ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!goferLoaderReference	^file == nil 		ifTrue: [ GoferPackageReference name: self name ]		ifFalse: [ 			"does Monticello-style #versionInfoFromVersionNamed: matching"			MetacelloGoferPackage name: self name packageFilename: self file ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!goferPackage	goferPackage == nil 		ifTrue: [ goferPackage := MetacelloGoferPackage name: self name packageFilename: self file ].	^goferPackage! !!MetacelloPackageSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasRepository    ^ self repositorySpecs notEmpty! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!includes: anObject constructor: aVersionConstructor    aVersionConstructor includesForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!includesForPackageOrdering  ^ self includes! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!info	"test compatibility method"	^self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!isPackageLoaded	^self isPackageLoaded: self loader! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!isPackageLoaded: aLoader	^(self workingCopyNameFor: aLoader) ~~ nil! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!load	self explicitLoadUsing: self loader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadUsing: mcLoader	self loader doingLoads: [ self explicitLoadUsing: mcLoader ]! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!loadUsing: aLoader gofer: gofer	^aLoader linearLoadPackageSpec: self gofer: gofer! !!MetacelloPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeMap	| map |	map := super mergeMap.	map at: #file put: file.	map at: #repositories put: self repositories.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeSpec: anotherSpec	| newSpec map anotherRepositories |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherRepositories := map at: #repositories) notEmpty		ifTrue: [ 			newSpec 				repositories: (self repositories isEmpty					ifTrue: [ anotherRepositories ]					ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].	^newSpec! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!name	name == nil ifTrue: [ name := self extractNameFromFile ].	^name! !!MetacelloPackageSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!nonOverridable	^super nonOverridable, #( repositories)! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!packageSpecsInLoadOrder	^{ self. }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	^self loader packagesNeedSavingUsing: repos into: aCollection! !!MetacelloPackageSpec methodsFor: 'copying' stamp: '9/28/2017 08:53:29'!postCopy	super postCopy.	goferPackage := nil.	repositories := repositories copy.! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!postLoadDoIt	^postLoadDoIt! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!postLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor postLoadDoItForPackage: aSymbol! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!preLoadDoIt	^preLoadDoIt! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!preLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor preLoadDoItForPackage: aSymbol! !!MetacelloPackageSpec methodsFor: 'visiting' stamp: '9/28/2017 08:53:29'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	packageBlock value: self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!repositories	repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].	^ repositories! !!MetacelloPackageSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!repositories: anObject	repositories := anObject! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!repositories: aBlock constructor: aVersionConstructor    aVersionConstructor repositoriesForPackage: aBlock! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/30/2012 13:30'!repository    self deprecated: 'Use repositories or repositorySpecs'.    self repositorySpecs isEmpty        ifTrue: [ ^ nil ].    ^ self repositorySpecs first! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repository: aStringOrMetacelloRepositorySpec	self repositories repository: aStringOrMetacelloRepositorySpec! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repository: aString username: username password: password	self repositories repository: aString username: username password: password! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForPackage: aString username: username password: password! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!repositoryDescriptions    ^ self repositorySpecs collect: [ :repoSpec | repoSpec description ]! !!MetacelloPackageSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!repositorySpecs	^self repositories map values! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!requires: anObject constructor: aVersionConstructor    aVersionConstructor requiresForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec visited: visited	^{ self }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!savePackage	"Interactive save ... prompted for commit message and package name unless MCVersionNameAndMessageRequest handled"	| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec savePackage ]		ifFalse: [ self loader savePackageUsing: self repositorySpecs ]! !!MetacelloPackageSpec methodsFor: 'fetching' stamp: 'dkh 07/07/2016 10:29'!searchCacheRepositoryForPackage: searchBlock  "evaluate the <searchBlock> if you want to search for the package in a local package cache"  "for standard mcz repositories the answer is YES!!"  searchBlock value! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloPackageSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!supplyingAnswers: anObject constructor: aVersionConstructor    aVersionConstructor supplyingAnswersForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updateForSpawnMethod: sourceSpec    "This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"    | nm fl |    nm := name.    fl := file.    fl == nil        ifTrue: [             "if only name has been set, then force the file to be non-nil, if any attribute besides file is set, then leave file nil"            {answers.            requires.            includes.            repositories.            preLoadDoIt.            postLoadDoIt} detect: [ :each | each ~~ nil ] ifNone: [ fl := name ] ].    super updateForSpawnMethod: sourceSpec.    file := repositories := goferPackage := preLoadDoIt := postLoadDoIt := nil.    name := nm.    file := fl.    ^ file == nil! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updatePackageRepositories: repositorySpecs	| resolvedPackageRef |	Transcript cr; show: '  Looking up version -> ', self file.	resolvedPackageRef := self loader resolveSpec: self from: repositorySpecs.	Transcript cr; show: 'Update repositoryGroup -> ', resolvedPackageRef name, ' ' , resolvedPackageRef repository description.	resolvedPackageRef version workingCopy repositoryGroup addRepository: resolvedPackageRef repository! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updatePackageRepositoriesFor: aVersionSpec	"Don't update the repository unless the package is loaded in the image"		self workingCopy == nil ifTrue: [ ^self ].	self updatePackageRepositories: self repositorySpecs, aVersionSpec repositorySpecs.! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updatePackageSpec: updatedSpecs force: force using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"	| viName |	(force not and: [ self getFile == nil ])		ifTrue: [ ^ self ].	"no file explicitly specified in this spec"	(viName := self workingCopyNameFor: anMCLoader) == nil		ifTrue: [ ^ self ].	"no working copy"	viName ~= self file		ifTrue: [ 			| spec |			spec := self copy.			spec file: viName.			updatedSpecs at: spec name put: spec ]		ifFalse: [ updatedSpecs at: self name put: #uptodate ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"		self updatePackageSpec: updatedSpecs force: false using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'visiting' stamp: '9/28/2017 08:53:29'!visitingWithPackages: packages	packages at: self name put: self! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: '9/28/2017 08:53:29'!workingCopy	^self goferPackage workingCopy! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: '9/28/2017 08:53:29'!workingCopyName	| wc |	(wc := self workingCopy) == nil ifTrue: [ ^nil ].	wc ancestry ancestors isEmpty not		ifTrue: [ ^wc ancestry ancestors first name ].	^nil! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 6/8/2012 14:04:22'!workingCopyNameFor: anMCLoader	| vi |	(vi := anMCLoader currentVersionInfoFor: self) == nil ifTrue: [ ^nil ].	^vi name! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!aboutToCopy    self projectReference className! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!answers: aListOfPairs	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent    aMember methodUpdateSelector == #'remove:'        ifTrue: [ aStream nextPutAll: 'removeProject: ' , self name printString ]        ifFalse: [             self projectReference == nil                ifTrue: [ ^ self ].            aStream nextPutAll: self projectLabel , ': ' , self projectName printString , ' '.            (aMember methodUpdateSelector == #'copy:' and: [ self projectReference hasNonVersionStringField ])                ifTrue: [ aStream nextPutAll: 'copyFrom: ' , aMember sourceName printString , ' ' ].            self projectReference configShortCutMethodOn: aStream member: aMember indent: indent + 1 ].    lastCascade        ifTrue: [ aStream nextPut: $. ]        ifFalse: [             aStream                nextPut: $;;                cr ]! !!MetacelloProjectReferenceSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	aStream 		tab: indent; nextPutAll: 'spec '; cr;		tab: indent + 1; nextPutAll: 'name: ', self name printString; nextPut: $;; cr;		tab: indent + 1; nextPutAll: 'projectReference: '; nextPut: $[; cr.	aStream 		tab: indent + 2; nextPutAll: 'spec'.	self projectReference ifNotNil: [ self projectReference configMethodBodyOn: aStream indent: indent + 2].	aStream nextPutAll: ' ].'! !!MetacelloProjectReferenceSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasRepository    ^ self projectReference hasRepository! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!includes: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!loadUsing: aLoader gofer: ignored	| required |	required := self resolveToLoadableSpec.	required loader: aLoader.	^required load! !!MetacelloProjectReferenceSpec methodsFor: 'importing' stamp: '9/28/2017 08:54:38'!mergeImportLoads: aLoadList    self projectReference mergeImportLoads: aLoadList! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap	| map |	map := super mergeMap.	map at: #projectReference put: projectReference.	^map! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeSpec: anotherSpec	| newSpec map anotherProjectReference |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherProjectReference := map at: #projectReference) ~~ nil		ifTrue: [ 			newSpec projectReference: 				(newSpec projectReference == nil					ifTrue: [ anotherProjectReference ]					ifFalse: [ newSpec projectReference mergeSpec: anotherProjectReference ])].	^newSpec! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!nonOverridable	^super nonOverridable, #( projectReference )! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection		| prjct clsName vrsn |	prjct := self resolveToLoadableSpec.	(visitedProjects includes: (clsName := prjct className)) ifTrue: [ ^self ].	visitedProjects add: clsName.	(vrsn := self versionOrNil) == nil ifTrue: [ ^self ].	vrsn spec 		packagesNeedSavingVisited: visitedProjects 		into: aCollection! !!MetacelloProjectReferenceSpec methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy	super postCopy.	projectReference := projectReference copy.! !!MetacelloProjectReferenceSpec methodsFor: 'visiting' stamp: '9/28/2017 08:54:38'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	projectBlock value: self! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectLabel    ^ self projectReference projectLabel! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectName	^self projectReference name! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!projectReference	^ projectReference! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectReference: anObject	projectReference := anObject! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!referencedSpec	^self projectReference! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!relativeCurrentVersion	^self projectReference relativeCurrentVersion! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!repositories    ^ self referencedSpec repositories! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!repository: aStringOrMetacelloRepositorySpec    ^ self projectReference repository: aStringOrMetacelloRepositorySpec! !!MetacelloProjectReferenceSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!repositorySpecs	^self repositories map values! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!requires: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveProjectSpec	^self projectReference! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToAllPackagesIn: aVersionSpec into: packages visited: visited	(self resolveProjectSpec resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg |		packages at: pkg put: pkg ]! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToLoadableSpec	^self resolveProjectSpec resolveToLoadableSpec! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^ andProjectsBool    ifTrue: [ {self} ]    ifFalse: [ self resolveToPackagesIn: aVersionSpec visited: visited ]! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!resolveToPackagesIn: aVersionSpec visited: visited	^#()! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	| nm |	nm := name.	self projectReference updateForSpawnMethod: sourceSpec.	super updateForSpawnMethod: sourceSpec.	name := nm.! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!updatePackageSpec: updatedSpecs using: anMCLoader	"Add project copy to updatedSpecs if the current version of the project 	 is different from the receiver's version"		self projectReference updatePackageSpec: updatedSpecs! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!version	^self projectReference version! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionOrNil	^self projectReference versionOrNil! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!versionString	^self projectReference versionString! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionString: aString	^self projectReference versionString: aString! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!add: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'adding' stamp: '9/28/2017 08:54:38'!addMember: aMember	self list add: aMember.	self clearMemberMap! !!MetacelloMemberListSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!clearMemberMap	memberMap := nil.! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!collect: aBlock 	| newCollection |	newCollection :=OrderedCollection new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!copy: aMemberSpec	self addMember: aMemberSpec! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!copy: specNamed to: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'toolbox support' stamp: '9/28/2017 08:54:38'!deleteSpec: aSpec    "remove the spec from list"    | member |    member := self list detect: [ :aMember | aMember spec = aSpec ] ifNone: [ ^ self ].    self list remove: member! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!detect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [ self error: 'Object is not in the collection.' ]! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!detect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self		do: [ :each | 			(aBlock value: each)				ifTrue: [ ^ each ] ].	^ exceptionBlock value! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!do: aBlock	self map values do: aBlock! !!MetacelloMemberListSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isEmpty	^self list isEmpty! !!MetacelloMemberListSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!list	list == nil ifTrue: [ list := OrderedCollection new ].	^list! !!MetacelloMemberListSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!list: aCollection	list := aCollection.	self clearMemberMap! !!MetacelloMemberListSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!map		| map |	memberMap ~~ nil ifTrue: [ ^memberMap ].	map := Dictionary new.	self list do: [:member | 		member			applyAdd: [:memberSpec | self mapAdd: memberSpec into: map ] 			copy: [:memberSpec | self mapCopy: memberSpec into: map ]			merge: [:memberSpec | self mapMerge: memberSpec into: map ] 			remove: [:memberSpec | self mapRemove: memberSpec into: map ]].	memberMap := map.	^memberMap! !!MetacelloMemberListSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!mapAdd: aMemberSpec into: map		map at: aMemberSpec name put: aMemberSpec spec! !!MetacelloMemberListSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!mapCopy: aMemberSpec into: map    | spec |    spec := map at: aMemberSpec sourceName ifAbsent: [  ].    spec == nil        ifTrue: [ ^ self error: 'Source spec named ' , aMemberSpec sourceName printString , ' not found' ]        ifFalse: [             spec aboutToCopy.            map at: aMemberSpec name put: (spec copy mergeSpec: aMemberSpec spec copy) ]! !!MetacelloMemberListSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!mapMerge: aMemberSpec into: map	| spec |	spec :=  map at: aMemberSpec name ifAbsent: [].	spec == nil		ifTrue: [ map at: aMemberSpec name put: aMemberSpec spec copy ]		ifFalse: [ map at: aMemberSpec name put: (spec mergeSpec: aMemberSpec spec)]! !!MetacelloMemberListSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!mapRemove: aMemberSpec into: map		map removeKey: aMemberSpec name ifAbsent: []! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!merge: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeSpec: anotherSpec	| newSpec |	newSpec := super mergeSpec: anotherSpec.	newSpec list: self list copy.	anotherSpec list do: [:groupMember | groupMember applyToList: newSpec ].	^newSpec! !!MetacelloMemberListSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!notEmpty	^self list notEmpty! !!MetacelloMemberListSpec methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy	super postCopy.	list := list copy.	self clearMemberMap! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!remove: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!select: aBlock 	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!specListDetect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self specListDetect: aBlock ifNone: [ self error: 'Object is not in the collection.' ]! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!specListDetect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self		specListDo: [ :each | 			(aBlock value: each)				ifTrue: [ ^ each ] ].	^ exceptionBlock value! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!specListDo: aBlock	self list do: [:member |  aBlock value: member spec ]! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: '9/28/2017 08:54:38'!specListSelect: aBlock 	| newCollection |	newCollection := OrderedCollection new.	self specListDo: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!add: aSpec	aSpec addToMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!applyIncludesTo: orderedSpecs for: pkgSpec firstTime: firstTime for: aVersionSpec  | movedSpecs baseIndex |  movedSpecs := Set new.  baseIndex := orderedSpecs indexOf: pkgSpec.  (pkgSpec includeSpecNamesForPackageOrdering: aVersionSpec)    do: [ :includedSpec |       | includedSpecName spec |      includedSpecName := includedSpec name.      spec := orderedSpecs        detect: [ :aSpec | aSpec name = includedSpecName ]        ifNone: [  ].      (self        slideIn: orderedSpecs        spec: spec        baseIndex: baseIndex        seen: IdentitySet new        firstTime: firstTime        for: aVersionSpec)        ifTrue: [ movedSpecs add: spec name ] ].  ^ movedSpecs! !!MetacelloPackagesSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	| packageSpecs |	packageSpecs := self map values.	packageSpecs size = 0 ifTrue: [ ^aStream nextPutAll: 'spec add: []' ].	packageSpecs size = 1		ifTrue: [			aStream 				tab: indent; 				nextPutAll: 'spec add: ['; cr.			packageSpecs first configMethodOn: aStream indent: indent + 1.			aStream nextPut: $]; cr ]		ifFalse: [			aStream 				tab: indent; 				nextPutAll: 'spec'.			1 to: packageSpecs size do: [:index | | packageSpec |				packageSpec := packageSpecs at: index.				aStream 					tab: indent + 1;					nextPutAll: 'add: ['; cr.				packageSpec configMethodOn: aStream indent: indent + 2.				aStream nextPut: $].				index < packageSpecs size					ifTrue: [ aStream nextPut: $; ].				aStream cr ]]! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!copy: specNamed to: spec	self addMember: 		(self copyMember 			name: spec name;			sourceName: specNamed;			spec: spec;			yourself)! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!merge: aSpec	aSpec mergeIntoMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageNamed: aString ifAbsent: aBlock	^self map at: aString ifAbsent: aBlock! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packageSpecsInLoadOrderFor: aVersionSpec  "order only the packageSpecs and projectSpecs. groupSpec order does not matter"  | orderedPackageSpecs groupSpecs moved lastMovedSpecs count terminationLimit map specsWithIncludes firstTime groupLoops |  map := self map.  orderedPackageSpecs := OrderedCollection new.  groupSpecs := Set new.  self list    do: [ :member |       | spec |      spec := map at: member name ifAbsent: [  ].      (spec == nil or: [ orderedPackageSpecs includes: spec ])        ifFalse: [           spec            projectDo: [ :prjSpec |               "specification order is the default order"              orderedPackageSpecs add: prjSpec ]            packageDo: [ :pkgSpec |               "specification order is the default order"              orderedPackageSpecs add: pkgSpec ]            groupDo: [ :groupSpec | groupSpecs add: groupSpec ] ] ].  orderedPackageSpecs isEmpty    ifTrue: [ ^ orderedPackageSpecs , groupSpecs asOrderedCollection ].  moved := true.  count := 0.  terminationLimit := orderedPackageSpecs size * 2.  groupLoops := IdentitySet new.  [ moved ]    whileTrue: [       count := count + 1.      count > terminationLimit        ifTrue: [           "Cheap termination hack - an APPARENT loop"          self error: 'Apparent loop in before/after dependency definitions' ].      moved := false.      orderedPackageSpecs copy        do: [ :packageSpec |           moved := moved            or: [               self                sortPackageSpecs: orderedPackageSpecs                packageSpec: packageSpec                groupLoops: groupLoops                for: aVersionSpec ] ] ].  lastMovedSpecs := Set new.  moved := true.  count := 0.  specsWithIncludes := orderedPackageSpecs    select: [ :pkgSpec | pkgSpec includesForPackageOrdering isEmpty not ].  firstTime := true.  [ moved ]    whileTrue: [       | result |      count := count + 1.	"count > terminationLimit"      count > 14        ifTrue: [           "Cheap termination hack - an APPARENT loop"          self error: 'Apparent loop in before/after dependency definitions' ].      moved := false.      result := Set new.      specsWithIncludes        do: [ :packageSpec |           result            addAll:              (self                applyIncludesTo: orderedPackageSpecs                for: packageSpec                firstTime: firstTime                for: aVersionSpec) ].      result size = lastMovedSpecs size        ifTrue: [           result            do: [ :name |               (lastMovedSpecs includes: name)                ifFalse: [ moved := true ] ] ]        ifFalse: [ moved := true ].      lastMovedSpecs := result.      firstTime := false ].  ^ orderedPackageSpecs , groupSpecs asOrderedCollection! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!remove: aSpec	aSpec removeFromMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!slideIn: orderedSpecs spec: targetSpec baseIndex: baseIndex seen: seen firstTime: firstTime for: aVersionSpec  | targetIndex requiredSpecNames targetRequires targetRequiresIndexes minIndex baseSpec required |  (seen includes: targetSpec)    ifTrue: [ ^ false ].  targetIndex := orderedSpecs indexOf: targetSpec.  baseIndex >= targetIndex    ifTrue: [ ^ false ].  required := false.  baseSpec := orderedSpecs at: baseIndex.  baseIndex + 1 to: targetIndex - 1 do: [ :index |     | spec |    spec := orderedSpecs at: index.    ((spec requiredSpecNamesForPackageOrdering: aVersionSpec)      includes: baseSpec name)      ifTrue: [ required := true ] ].  firstTime    ifFalse: [       required        ifFalse: [ ^ false ] ].  requiredSpecNames := targetSpec    requiredSpecNamesForPackageOrdering: aVersionSpec.  targetRequires := orderedSpecs    select: [ :spec | requiredSpecNames includes: spec name ].  targetRequiresIndexes := targetRequires    collect: [ :spec | orderedSpecs indexOf: spec ].  targetRequiresIndexes add: baseIndex.  minIndex := targetRequiresIndexes detectMax: [ :each | each ].  minIndex + 1 < targetIndex    ifTrue: [       orderedSpecs remove: targetSpec.      orderedSpecs add: targetSpec afterIndex: minIndex.      seen add: targetSpec ]    ifFalse: [       ^ self        slideIn: orderedSpecs        spec: (orderedSpecs at: minIndex)        baseIndex: 1        seen: seen        firstTime: firstTime        for: aVersionSpec ].  ^ true! !!MetacelloPackagesSpec methodsFor: 'private' stamp: 'EstebanLorenzano 9/29/2017 13:42'!sortPackageSpecs: orderedSpecs packageSpec: packageSpec groupLoops: groupLoops for: aVersionSpec  | packageIndex moved movePackage targetPackage targetIndex targetSpecNames groupLoopDetected |  packageIndex := orderedSpecs indexOf: packageSpec.  moved := movePackage := false.  targetSpecNames := packageSpec    requiredSpecNamesForPackageOrdering: aVersionSpec.  groupLoopDetected := groupLoops includes: packageSpec.  groupLoopDetected    ifFalse: [       targetSpecNames        do: [ :targetPackageOrProjectName |           targetPackage := orderedSpecs            detect: [ :each | each name = targetPackageOrProjectName ]            ifNone: [               MetacelloNameNotDefinedError                signal:                  'project group, or package named: ' , targetPackageOrProjectName printString                    ,                      ' not found when used in requires: or includes: field of package: '                    , packageSpec name printString , ' for version: '                    , aVersionSpec versionString , ' of '                    , aVersionSpec projectLabel , '.'.              nil	"return nil if resumed" ].          targetIndex := orderedSpecs indexOf: targetPackage.          (groupLoopDetected not and: [ packageIndex = targetIndex ])            ifTrue: [               self                notify:                  'A group loop has been detected. The package: ' , packageSpec name printString                    ,                      ' requires a group that includes itself. If you resume, the group loop will be ignored and details will be written to the Transcript.'.              groupLoopDetected := true.              groupLoops add: packageSpec.              Transcript                cr;                show: 'Package: ' , packageSpec name printString;                cr;                tab;                show: 'Raw Requires:'.              packageSpec requires                do: [ :each |                   Transcript                    cr;                    tab;                    tab;                    show: each ].              Transcript                cr;                show:                    'Package: ' , packageSpec name printString , ' has a group loop:';                cr;                tab;                show: 'Expanded Requires:'.              targetSpecNames                do: [ :each |                   Transcript                    cr;                    tab;                    tab;                    show: each ] ].          movePackage := movePackage or: [ packageIndex <= targetIndex ].          false            ifTrue: [               "use for debugging non-obvious reference loops"              packageIndex < targetIndex                ifTrue: [                   Transcript                    cr;                    show:                        'Moving ' , targetPackageOrProjectName , ' from ' , targetIndex printString                            , ' to ' , packageIndex printString ] ] ] ].  groupLoopDetected    ifTrue: [       "old implementation that does not resolve group names"      targetSpecNames := packageSpec requires.      targetSpecNames        do: [ :targetPackageName |           targetPackage := orderedSpecs            detect: [ :each | each name = targetPackageName ]            ifNone: [  ].          targetIndex := orderedSpecs indexOf: targetPackage.          movePackage := movePackage or: [ packageIndex <= targetIndex ] ] ].  movePackage    ifTrue: [       moved := true.      orderedSpecs        remove: packageSpec        ifAbsent: [ ^ self error: 'unexpected error removing package' ].      targetIndex := 0.      targetSpecNames        do: [ :targetPackageOrProjectName |           (targetPackage := orderedSpecs            detect: [ :each | each name = targetPackageOrProjectName ]            ifNone: [  ]) ~~ nil            ifTrue: [ targetIndex := targetIndex max: (orderedSpecs indexOf: targetPackage) ] ].      targetIndex == 0        ifTrue: [ orderedSpecs add: packageSpec beforeIndex: packageIndex ]        ifFalse: [ orderedSpecs add: packageSpec afterIndex: targetIndex ] ].  ^ moved! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!add: aStringOrSpec	aStringOrSpec addToMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!canUpgradeTo: aMetacelloRepositoriesSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values    sort: [ :a :b | a description <= b description ].  anotherRepositorySpecs := aMetacelloRepositoriesSpec map values    sort: [ :a :b | a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size    ifTrue: [ ^ false ].  1 to: repositorySpecs size do: [ :index |     | repoSpec anotherRepoSpec |    repoSpec := repositorySpecs at: index.    anotherRepoSpec := anotherRepositorySpecs at: index.    (repoSpec canUpgradeTo: anotherRepoSpec)      ifTrue: [ ^ true ] ].  ^ false! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!compareEqual: aMetacelloProjectSpec    | repositorySpecs anotherRepositorySpecs |    repositorySpecs := (self map values sort: [ :a :b | a description <= b description ])        collect: [ :each | each description ].    anotherRepositorySpecs := (aMetacelloProjectSpec map values sort: [ :a :b | a description <= b description ])        collect: [ :each | each description ].    ^ repositorySpecs = anotherRepositorySpecs! !!MetacelloRepositoriesSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodCascadeOn: aStream indent: indent	| repositorySpecs |	repositorySpecs := self map values sort: [:a :b | a description <= b description ].	repositorySpecs size = 1		ifTrue: [ repositorySpecs first configMethodCascadeOn: aStream lastCascade: true ]		ifFalse: [			1 to: repositorySpecs size do: [:index | | repositorySpec |				aStream tab: indent + 1.				(repositorySpecs at: index)					configMethodCascadeOn: aStream 					lastCascade: index >= repositorySpecs size ]]! !!MetacelloRepositoriesSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodOn: aStream indent: indent	aStream 		tab: indent; 		nextPutAll: 'spec';		cr.	self configMethodCascadeOn: aStream indent: indent! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!hasNoLoadConflicts: aMetacelloRepositoriesSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values    sort: [ :a :b | a description <= b description ].  anotherRepositorySpecs := aMetacelloRepositoriesSpec map values    sort: [ :a :b | a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size    ifTrue: [ ^ false ].  1 to: repositorySpecs size do: [ :index |     | repoSpec anotherRepoSpec |    repoSpec := repositorySpecs at: index.    anotherRepoSpec := anotherRepositorySpecs at: index.    (repoSpec hasNoLoadConflicts: anotherRepoSpec)      ifFalse: [ ^ false ] ].  ^ true! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!merge: aRepositorySpec	aRepositorySpec mergeIntoMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!metacelloRegistrationHash    ^ ((self map values sort: [ :a :b | a description <= b description ]) collect: [ :each | each description ]) hash! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!remove: aRepositorySpec	aRepositorySpec removeFromMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!repository: aStringOrSpec	aStringOrSpec addToMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForRepositories: anObject! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!repository: description username: username password: password	| spec |	spec := 		(self project repositorySpec)			description: description;			username: username;			password: password;			yourself.	self addMember: 		(self addMember 			name: spec name;			spec: spec;			yourself)! !!MetacelloRepositoriesSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForRepositories: aString username: username password: password! !!MetacelloAddMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	addBlock value: self! !!MetacelloAddMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyToList: aListSpec	aListSpec add: self! !!MetacelloAddMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodUpdateSelector	^#overrides:! !!MetacelloCopyMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock    copyBlock value: self! !!MetacelloCopyMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyToList: aListSpec	aListSpec copy: self! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodUpdateSelector	^#copy:! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!sourceName	^sourceName! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!sourceName: aString	sourceName := aString! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!addToMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyToList: aListSpec	self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodCascadeOn: aStream last: lastCascade indent: indent	self spec 		configMethodCascadeOn: aStream 		member: self 		last: lastCascade 		indent: indent! !!MetacelloMemberSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	aStream nextPutAll: self class name asString, ' member: ('.	self spec configMethodOn: aStream indent: indent.	aStream nextPutAll: ')'.! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodUpdateSelector	^self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!name	^name! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!name: aString	name := aString! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!sourceName	^self name! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!spec	^spec! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!spec: aMetacelloSpec	spec := aMetacelloSpec! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	mergeBlock value: self! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyToList: aListSpec	aListSpec merge: self! !!MetacelloMergeMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodUpdateSelector	^#with:! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	removeBlock value: self! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!applyToList: aListSpec	aListSpec remove: self! !!MetacelloRemoveMemberSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!methodUpdateSelector	^#remove:! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!compareEqual: aMetacelloProjectSpec    "'projectPackage repositories'"    ^ (super compareEqual: aMetacelloProjectSpec)        and: [ self repositories compareEqual: aMetacelloProjectSpec repositories ]! !!MetacelloGenericProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!determineCurrentVersionForLoad    self subclassResponsibility! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getRepositories    "raw access to iv"    ^ repositories! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!hasNoLoadConflicts: aMetacelloProjectSpec  "'projectPackage repositories'"  ^ (super hasNoLoadConflicts: aMetacelloProjectSpec)    and: [       (self repositories isEmpty or: [ aMetacelloProjectSpec repositories isEmpty ])        or: [ self repositories hasNoLoadConflicts: aMetacelloProjectSpec repositories ] ]! !!MetacelloGenericProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasRepository    ^ self repositorySpecs notEmpty! !!MetacelloGenericProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!load    (MetacelloLookupProjectSpecForLoad new        projectSpec: self;        yourself) signal performLoad! !!MetacelloGenericProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!loadVersion: aVersionOrNil    self subclassResponsibility! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap    | map |    map := super mergeMap.    map at: #'repositories' put: repositories.    ^ map! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeRepositoriesSpec: anotherRepositories  self    repositories:      (self getRepositories == nil        ifTrue: [ anotherRepositories ]        ifFalse: [ self repositories mergeSpec: anotherRepositories ])! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!mergeScriptRepository: anotherSpec    self repositories: anotherSpec repositories! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeSpec: anotherSpec  | newSpec map anotherRepositories |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherRepositories := map at: #'repositories') ~~ nil    ifTrue: [ newSpec mergeRepositoriesSpec: anotherRepositories ].  ^ newSpec! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!metacelloRegistrationHash    "projectPackage (ignored) repositories"    ^ super metacelloRegistrationHash bitXor: self repositories metacelloRegistrationHash! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!name: aString    super name: aString.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!nonOverridable    ^ super nonOverridable , #(#'projectPackage' #'repositories')! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'ct 11/7/2020 14:04'!password: password	self repositories do: [:repository |		repository password: password].! !!MetacelloGenericProjectSpec methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy    super postCopy.    repositories := repositories copy.    projectPackage := nil! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectPackage    self subclassResponsibility! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectPackage: aProjectPackage    self shouldBeMutable.    projectPackage := aProjectPackage! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!projectPackage: aBlock constructor: aVersionConstructor    aVersionConstructor projectPackageForProject: aBlock! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositories    repositories ifNil: [ repositories := self project repositoriesSpec ].    ^ repositories! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repositories: anObject    self shouldBeMutable.    repositories := anObject.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!repositories: aBlock constructor: aVersionConstructor    aVersionConstructor repositoriesForProject: aBlock! !!MetacelloGenericProjectSpec methodsFor: 'querying' stamp: 'dkh 6/30/2012 12:32'!repository    | specs |    self deprecated: 'Use repositories or repositorySpecs'.    (specs := self repositorySpecs) isEmpty        ifTrue: [ ^ nil ].    ^ specs first! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repository: aStringOrMetacelloRepositorySpec    self repositories repository: aStringOrMetacelloRepositorySpec.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForProject: anObject! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!repository: aString username: username password: password    self repositories repository: aString username: username password: password.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForProject: aString username: username password: password! !!MetacelloGenericProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!repositoryDescriptions    ^ self repositorySpecs collect: [ :repoSpec | repoSpec description ]! !!MetacelloGenericProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!repositorySpecs    repositories ifNil: [ ^ #() ].    ^ self repositories map values! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'ct 11/7/2020 14:04'!username: username	self repositories do: [:repository |		repository username: username].! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asBaselineProjectSpec    ^ self! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asProjectRegistration    ^ MetacelloProjectRegistration fromMCBaselineProjectSpec: self! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!canDowngradeTo: aProjectSpec    "cannot upgrade between baselines"    ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!canUpgradeTo: aProjectSpec  "cannot upgrade between baselines unless repositories can be upgraded"  (self repositories canUpgradeTo: aProjectSpec repositories)    ifTrue: [ ^ true ].  ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configHasVersionString  ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!constructClassName    ^ 'BaselineOf' , self name! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'mutability' stamp: '9/28/2017 08:53:29'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  | copy |  aMetacelloProjectRegistration    baselineProjectSpecIfPresent: [ :spec |       copy := spec copy.      aBlock value: copy.      aMetacelloProjectRegistration baselineProjectSpec: copy ]    ifAbsent: [       aMetacelloProjectRegistration        configurationProjectSpecIfPresent: [ :spec |           copy := spec copy.          aBlock value: copy.          aMetacelloProjectRegistration configurationProjectSpec: copy ]        ifAbsent: [ aBlock value: nil ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!determineCurrentVersionForLoad    ^ self version! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureConfigurationLoaded: vrsn ensured: ensured  "answer true if the configuration should be reloaded"  "see Issue #181 for details ... basically we always want to consider loading the baseline from a project reference, especially if the two project specs are not the same..."  "https://github.com/dalehenrich/metacello-work/issues/181"  ^ true! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureLoadUsing: aLoader  "see https://github.com/dalehenrich/metacello-work/issues/244 ... uncoditionally load   baseline"  [ super ensureLoadUsing: aLoader ]    on: MetacelloIgnorePackageLoaded    do: [ :ex | ex resume: ex packageSpec name = self name ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!hasClassName    ^ className ~~ nil and: [ className ~= self constructClassName ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithConfigurationSpec: projectSpec  "baseline can be loaded on top of a configuration without a conflict"  ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithProjectSpec: projectSpec	^ projectSpec hasConflictWithBaselineSpec: self! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isBaselineOfProjectSpec	^ true! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'importing' stamp: '9/28/2017 08:53:29'!mergeImportLoads: aLoadList    aLoadList        ifNotNil: [ :otherLoads | self loads ifNil: [ loads := otherLoads ] ifNotNil: [ loads := loads , otherLoads ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeRepositoriesSpec: anotherRepositories  "anotherRepositories wins ... there can ever only be one repository for the    baseline to load from"  "https://github.com/dalehenrich/metacello-work/issues/251"  self repositories: anotherRepositories! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeSpec: anotherSpec    ^ super mergeSpec: anotherSpec asBaselineProjectSpec! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!projectLabel    ^ 'baseline'! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!repositoryBranchName  "extract a branch name from the repository ... if possible"  "must parallel implementation of MetacelloMCBaselineProject>>setBaselineRepositoryDescription: we want the same repoSpec"  | spec repo |  self repositorySpecs do: [ :repoSpec | spec := repoSpec ].  repo := spec createRepository.  ^ repo repositoryBranchName! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!repositoryVersionString  "extract a version string from the repository ... if possible"  "must parallel implementation of MetacelloMCBaselineProject>>setBaselineRepositoryDescription: we want the same repoSpec"  | spec repo |  self repositorySpecs do: [ :repoSpec | spec := repoSpec ].  [ repo := spec createRepository ]    on: Error    do: [ :ex | ^ '' ].  ^ repo repositoryVersionString! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'merging' stamp: 'ct 11/7/2020 15:04:55'!validateMergeForSpec: aSpec  (aSpec validateMergeWithBaselineOfSpec: self)    ifFalse: [       self        error:          'The project spec ' , self name printString , ' in project '            , self project label , ' has incompatible specs. '            , aSpec class name asString , ' and ' , self class name asString            , ' are not compatible.' ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'merging' stamp: 'ct 11/7/2020 15:04:55'!validateMergeWithBaselineOfSpec: aSpec  ^ true! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!validateVersionString: issues withDefaultVersionString: ignored    self versionString        ifNotNil: [ :vs |             | prj |            prj := self project asBaselineProject.            vs ~= prj singletonVersionName                ifTrue: [                     issues                        add:                            (MetacelloValidationError                                configurationClass: self projectClass                                reasonCode: #'invalidVersionString'                                callSite:                                    #'validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:'                                explanation:                                    'version field is incorrect, should be: ' , prj singletonVersionName printString) ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!version    self projectClass == nil        ifTrue: [ ^ nil ].    ^ self projectClassProject version! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!version: anObject constructor: aVersionConstructor    self error: 'version: not allowed in a baseline project spec'! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!versionString    ^ versionString ifNil: [ self version ifNotNil: [:v | v versionString] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!versionString: anObject constructor: aVersionConstructor    self error: 'versionString: not allowed in a baseline project spec'! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asConfigurationProjectSpec    ^ self! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asProjectRegistration    ^ MetacelloProjectRegistration fromMCConfigurationProjectSpec: self! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!constructClassName    ^ 'ConfigurationOf' , self name! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'mutability' stamp: '9/28/2017 08:53:29'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  | copy |  aMetacelloProjectRegistration    configurationProjectSpecIfPresent: [ :spec |       copy := spec copy.      aBlock value: copy.      aMetacelloProjectRegistration configurationProjectSpec: copy ]    ifAbsent: [       aMetacelloProjectRegistration        baselineProjectSpecIfPresent: [ :spec |           copy := spec copy.          aBlock value: copy.          aMetacelloProjectRegistration baselineProjectSpec: copy ]        ifAbsent: [ aBlock value: nil ] ]! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!hasClassName    ^ className ~~ nil and: [ className ~= self constructClassName ]! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithBaselineSpec: projectSpec	projectSpec name = self name		ifFalse: [ ^ true ].	projectSpec project configuration className = self project configuration className		ifFalse: [ ^ true ].	^ ((projectSpec repositories isEmpty or: [ self repositories isEmpty ])		or: [ projectSpec repositories hasNoLoadConflicts: self repositories ]) not! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithProjectSpec: projectSpec	^ projectSpec hasConflictWithConfigurationSpec: self! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isConfigurationOfProjectSpec	^ true! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeSpec: anotherSpec    ^ super mergeSpec: anotherSpec asConfigurationProjectSpec! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!projectLabel    ^ 'configuration'! !!MetacelloMCNamelessProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asProjectSpecForVersion: vrsn  "I'm a reference spec and my project comes from the project I'm loaded from, not the project I am loading"  "https://github.com/dalehenrich/metacello-work/issues/331"  | proj spec |  proj := vrsn ifNil: [ ^ self ] ifNotNil: [ vrsn versionSpec project ].  spec := proj configurationOfProjectSpecClass for: proj.  self copyForScriptingInto: spec.  spec loader: self loader.  self assert: (self className beginsWith: 'BaselineOf') not.  ^ spec! !!MetacelloMCNamelessProjectSpec methodsFor: 'mutability' stamp: '9/28/2017 08:53:29'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock	self error: 'Should be converting to configuration spec for the registration, so we should not get here'! !!MetacelloMCProjectSpec class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:29'!new	self name == #MetacelloMCProjectSpec		ifTrue: [ self error: 'This class is abstract' ].	^ super new! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!allPackagesLoaded: aLoader    "answer true if all of the packages (excluding projects) are loaded"    | vrsn pkgs |    (vrsn := self versionOrNil) == nil        ifTrue: [ ^ false ].    pkgs := OrderedCollection new.    (self loadListForVersion: vrsn)        do: [ :nm |             vrsn packages                do: [ :pkg |                     (pkg isPackageLoaded: aLoader)                        ifFalse: [ ^ false ] ] ].    ^ true! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asBaselineProjectSpec    ^ self copyForScriptingInto: (MetacelloMCBaselineOfProjectSpec for: self project asBaselineProject)! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asConfigurationProjectSpec    ^ self copyForScriptingInto: (MetacelloMCConfigurationOfProjectSpec for: self project asConfigurationProject)! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asProjectRegistration  (self className beginsWith: 'BaselineOf')    ifTrue: [       ^ MetacelloProjectRegistration        fromMCBaselineProjectSpec: self asBaselineProjectSpec ].  ^ MetacelloProjectRegistration    fromMCConfigurationProjectSpec: self asConfigurationProjectSpec! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asProjectSpec    ^ self! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!asProjectSpecForVersion: vrsn  ^ self! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!baseName	^ MetacelloScriptEngine baseNameOf: self className! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!canDowngradeTo: aMetacelloProjectSpec    ^ (super canDowngradeTo: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!canUpgradeTo: aMetacelloProjectSpec    ^ (super canUpgradeTo: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!className: aString    super className: aString.    self projectPackage: nil! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!compareCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader    ^ (MetacelloLookupProjectSpecForLoad new        projectSpec: self;        yourself) signal        performCurrentVersionTestAgainst: self versionOrNil        operator: anOperator        targetVersionStatus: targetVersionStatus        using: anMCLoader! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!compareEqual: aMetacelloProjectSpec    "'projectPackage repositories'"    ^ (super compareEqual: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!compareRelativeCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader	| cv vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(cv := self relativeCurrentVersion) == nil ifTrue: [ ^false ].	(targetVersionStatus includes: cv versionStatus)		ifTrue: [ ^cv perform: anOperator with: vrsn ].	^false! !!MetacelloMCProjectSpec methodsFor: 'mutability' stamp: '9/28/2017 08:53:29'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock    self subclassResponsibility! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!copyForScriptingInto: aProjectSpec    ^aProjectSpec        setName: name;        className: className;        versionString: versionString;        operator: operator;        setLoads: loads;        preLoadDoIt: preLoadDoIt;        postLoadDoIt: postLoadDoIt;        repositories: repositories copy;        file: file! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!determineCurrentVersionForLoad    "don't use self currentVersion, because we are interested in the currentVersion of the project as loaded in image, not the current version relative to our load list"    | prjct version currentVersion cvs |    self projectClass == nil        ifTrue: [ ^ nil ].    (version := self versionOrNil) == nil        ifTrue: [ ^ nil ].    version blessing == #'baseline'        ifTrue: [ ^ version ].    self loader ignoreImage        ifTrue: [ ^ version ].    prjct := self projectClass new project.    prjct loader: self loader.    (currentVersion := prjct currentVersion) == nil        ifTrue: [ ^ nil ].    (cvs := currentVersion versionStatus) == #'somethingLoaded'        ifTrue: [ ^ nil ].    (#(#'allLoadedToSpec' #'loadedToSpec' #'loadedMatchConstraints') includes: (cvs := currentVersion versionStatus))        ifTrue: [             (currentVersion perform: self operator with: version)                ifTrue: [                     "load currentVersion"                    ^ currentVersion ].	"load version"            ^ nil ].    version = currentVersion        ifTrue: [ ^ currentVersion ].	"I don't believe that it is possible to reach this point in the method, so I will be interested if I run across a case that produces this error"    (MetacelloProjectSpecLoadConflict projectSpec: self)        signal:            'Project load conflict for' , prjct label printString , ' between current version ' , currentVersion printString , '('                , cvs asString , ') and specified version ' , version printString                , '. Press resume to continue with load anyway'.    ^ nil! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureConfigurationLoaded: vrsn ensured: ensured  "answer true if the configuration should be reloaded:    blessing is #development    symbolic version (https://github.com/dalehenrich/metacello-work/issues/283)"  (vrsn blessing == #'development' or: [ self versionString isSymbol ])    ifTrue: [       ensured ~~ #'latest'        ifTrue: [ ^ MetacelloScriptEnsureProjectLoadedForDevelopment signal ] ].  ^ false! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureLoadUsing: aLoader  | pp |  pp := (MetacelloLookupProjectSpec new    projectSpec: self;    yourself) signal projectPackage.  pp    ifNil: [       self        error:          'Unable to resolve project package for ' , self name printString            ,              '. It is likely that that the configuration referencing this project will not validate properly (see MetacelloToolBox class>>validateConfiguration:).' ].  pp ensureLoadUsing: aLoader! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureLoadedForDevelopmentUsing: mcLoader  "for #development projects, always need latest version of package when contemplating a load"  | ensured |  ensured := mcLoader ensuredMap at: self name ifAbsent: [ nil ].  self projectClass ~~ nil    ifTrue: [       | vrsn |      vrsn := self versionOrNil.      vrsn ~~ nil        ifTrue: [           (self ensureConfigurationLoaded: vrsn ensured: ensured)            ifTrue: [               mcLoader ensureForDevelopment                ifTrue: [                   | pc |                  (pc := self projectClass) ~~ nil                    ifTrue: [                       MetacelloClearStackCacheNotification                        signal:                          #(#'currentVersion' #'currentVersionAgainst:' #'currentVersionInfo' #'versionConstructor' #'loadableSpecNames')                            , {pc} ].                  self ensureLoadUsing: mcLoader ]                ifFalse: [ self projectPackage fetchUsing: mcLoader ].              mcLoader ensuredMap at: self name put: #'latest' ].          ^ self ] ].  ensured == nil    ifTrue: [       "projectClass == nil or version == nil"      mcLoader ensureForDevelopment        ifTrue: [           | pc |          (pc := self projectClass) ~~ nil            ifTrue: [               MetacelloClearStackCacheNotification                signal:                  #(#'currentVersion' #'currentVersionAgainst:' #'currentVersionInfo' #'versionConstructor' #'loadableSpecNames')                    , {pc} ].          self ensureLoadUsing: mcLoader ]        ifFalse: [ self fetchUsing: mcLoader ].      mcLoader ensuredMap at: self name put: #'present' ]! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!ensureProjectLoaded  "Ensure that the MetacelloProject is loaded in image. 	 projectClass == nil or requested version non-existent warrants a project package load."  "answer true if the projectClass exists"  (self projectClass == nil    or: [       self versionOrNil == nil        or: [ (loader notNil or: [ self isMutable ]) and: [ self loader ignoreImage ] ] ])    ifTrue: [       | pc |      (pc := self projectClass) ~~ nil        ifTrue: [           MetacelloClearStackCacheNotification            signal:              #(#'currentVersion' #'currentVersionAgainst:' #'currentVersionInfo' #'versionConstructor' #'loadableSpecNames')                , {pc} ].      self projectPackage ifNil: [ ^ true ].      self ensureLoadUsing: self loader ].  ^ self projectClass ~~ nil! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!fetchUsing: aLoader    (MetacelloLookupProjectSpec new        projectSpec: self;        yourself) signal projectPackage fetchUsing: aLoader! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!file    file ifNil: [ ^ self className ].    ^ file! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!file: aString    self shouldBeMutable.    file := aString.    self projectPackage: nil! !!MetacelloMCProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!file: aString constructor: aVersionConstructor    aVersionConstructor fileForProject: aString! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!getFile    "raw access to iv"    ^ file! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithBaselineSpec: projectSpec	^ self hasLoadConflicts: projectSpec! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithConfigurationSpec: projectSpec	^ self hasLoadConflicts: projectSpec! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasConflictWithProjectSpec: projectSpec  (self className beginsWith: 'BaselineOf')    ifTrue: [ ^ projectSpec hasConflictWithBaselineSpec: self asBaselineProjectSpec ].  ^ projectSpec    hasConflictWithConfigurationSpec: self asConfigurationProjectSpec! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!hasNoLoadConflicts: aMetacelloProjectSpec  "'projectPackage repositories'"  ^ (super hasNoLoadConflicts: aMetacelloProjectSpec)    and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isBaselineOfProjectSpec	^ false! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isConfigurationOfProjectSpec	^ false! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isPartiallyLoaded: aLoader	| vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(self loadListForVersion: vrsn) do: [:nm |		(vrsn packagesForSpecNamed: nm ) do: [:pkg |			(pkg isPackageLoaded: aLoader) ifTrue: [ ^true ]]].	^false! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isPossibleBaseline	| vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(vrsn allPackagesForSpecNamed: (self loadListForVersion: vrsn)) do: [:pkg |		pkg workingCopy == nil ifTrue: [ ^false ]].	^true! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadPackageList	| vrsn pkgs |	(vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].	pkgs := OrderedCollection new.	(self loadListForVersion: vrsn) do: [:nm |		pkgs addAll: ((vrsn packagesForSpecNamed: nm ) collect: [:each | each name ])].	^pkgs! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'EstebanLorenzano 10/2/2017 19:23'!loadVersion: aVersionOrNil	"Load the correct version of the project"	| vrsn mcLoader list |	self ensureProjectLoaded.	vrsn := aVersionOrNil.	vrsn == nil		ifTrue: [ [ vrsn := self version ]				on: MetacelloVersionDoesNotExistError				do: [ :ex | 					^ (MetacelloProjectSpecLoadError projectSpec: self)						versionDoesNotExistException: ex;						signal:							'No version found for ' , self versionString printString , ' of '								, self className asString , ' because: ' , ex description ] ].	mcLoader := self loader copy.	mcLoader operator: self operator.	vrsn loader: mcLoader.	list := (mcLoader ignoreImage		ifTrue: [ self loadListForVersion: vrsn ]		ifFalse: [ vrsn				packageAndProjectNamesToLoad: (self loadListForVersion: vrsn)				loader: mcLoader ]) asSet.	MetacelloPlatform current		useStackCacheDuring: [ :dict | 			| projectCache cachedList |			projectCache := dict				at: self projectClass				ifAbsent: [ dict at: self projectClass put: Dictionary new ].			(cachedList := projectCache at: vrsn ifAbsent: [  ]) == nil				ifTrue: [ projectCache at: vrsn put: list ]				ifFalse: [ 					(cachedList size = list size 					and: [ cachedList allSatisfy: [ :each | list  includes: each ] ])						ifTrue:							[ "no need to refetch list ... recursion stoppper (Issue 95)" ^ self ]						ifFalse: [ projectCache at: vrsn put: list ] ].			vrsn versionString ~= self versionString				ifTrue: [ Transcript show: ' [' , vrsn versionString , ']' ].			mcLoader preLoad: self.			vrsn fetchRequiredFromArray: list.	"do the load"			(MetacelloProjectSpecLoadedNotification new				projectSpec: (self copy versionString: vrsn versionString)) signal.			mcLoader postLoad: self ]		defaultDictionary: Dictionary new! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadedPackageNames: aLoader	| vrsn pkgs |	(vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].	pkgs := OrderedCollection new.	(self loadListForVersion: vrsn) do: [:nm |		(vrsn packagesForSpecNamed: nm ) do: [:pkg |			(pkg isPackageLoaded: aLoader) ifTrue: [ pkgs add: pkg name ]]].	^pkgs! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!metacelloRegistrationHash    "file"    ^ String stringHash: self file initialHash: super metacelloRegistrationHash! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!projectClass    self className == nil        ifTrue: [ ^ nil ].    ^ Smalltalk at: self className asSymbol ifAbsent: [  ]! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!projectClassProject    "indirection needed when projectClass is _not_ a subclass of MetacelloProject"    ^ self projectClass new project        setBaselineRepositoryDescription: self repositoryDescriptions;        yourself! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!projectPackage    projectPackage        ifNil: [             self className ifNil: [ ^ nil ].            projectPackage := self project packageSpec.            projectPackage name: self className.            self getFile ifNotNil: [ projectPackage file: self file ].            projectPackage repositories: self getRepositories ].    ^ projectPackage! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!relativeCurrentVersion    "currentVersion calculated relative to the loadList"    | vrsn expanded loadList |    (vrsn := self versionOrNil) == nil        ifTrue: [ ^ nil ].    expanded := [ vrsn expandToLoadableSpecNames: (loadList := self loadListForVersion: vrsn) ]        on: Error        do: [ :ex |             vrsn blessing == #'development'                ifTrue: [                     self ensureLoadUsing: self loader.                    vrsn := self versionOrNil.                    ex return: (vrsn expandToLoadableSpecNames: loadList) ].            ex pass ].    ^ self projectClassProject currentVersionAgainst: expanded! !!MetacelloMCProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolveToAllPackagesIn: aVersionSpec visited: visited    | vrsn |    visited        pushProject: [             visited                visit: self                doing: [ :spec |                     spec ensureProjectLoaded.                    vrsn := spec version.                    ^ vrsn                        allPackagesForSpecNamed: (self loadListForVersion: vrsn)                        ifAbsent: [ self error: 'invalid loads: spec' ] ] ].    ^ #()! !!MetacelloMCProjectSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		repositories := className := operator := loads := projectPackage := nil.	sourceSpec ~~ nil ifTrue: [ versionString := sourceSpec versionString ].! !!MetacelloMCProjectSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updatePackageSpec: updatedSpecs    "Add project copy to updatedSpecs if the current version of the project 	 is different from the receiver's version"    | prj currentVersion spec |    className == nil        ifTrue: [ ^ self ].    prj := self projectClassProject.    (currentVersion := prj currentVersion) = self versionOrNil        ifTrue: [ ^ self ].    currentVersion == nil        ifTrue: [ ^ self ].    spec := self copy.    spec versionString: currentVersion versionString.    updatedSpecs at: spec name put: spec! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!validateForScriptLoad: aScriptEngine withDefaultVersionString: defaultVersionString withDefaultRepositoryDecription: defaultRepositoryDecription    | issues callSite |    issues := OrderedCollection new.    callSite := #'validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:'.    self name        ifNil: [             issues                add:                    (MetacelloValidationError                        configurationClass: self projectClass                        reasonCode: #'incompleteProjectSpec'                        callSite: callSite                        explanation: 'name field required') ].    self className        ifNil: [             issues                add:                    (MetacelloValidationError                        configurationClass: self projectClass                        reasonCode: #'incompleteProjectSpec'                        callSite: callSite                        explanation: 'className field required') ].    self repositories isEmpty        ifTrue: [             defaultRepositoryDecription                ifNotNil: [ self repository: defaultRepositoryDecription ]                ifNil: [                     issues                        add:                            (MetacelloValidationError                                configurationClass: self projectClass                                reasonCode: #'incompleteProjectSpec'                                callSite: callSite                                explanation: 'repository field required') ] ].    self validateVersionString: issues withDefaultVersionString: defaultVersionString.    ^ issues! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!validateVersionString: issues withDefaultVersionString: defaultVersionString    self versionString        ifNil: [             defaultVersionString                ifNotNil: [ self versionString: defaultVersionString ]                ifNil: [                     issues                        add:                            (MetacelloValidationError                                configurationClass: self projectClass                                reasonCode: #'incompleteProjectSpec'                                callSite:                                    #'validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:'                                explanation: 'version field required') ] ]! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!version	"Empty version string means use latestVersion or #bleedingEdge"	self projectClass == nil		ifTrue: [ ^ nil ].	^ self versionString == nil		ifTrue: [ 			| vrsn |			"Eventually it will become an error to not specify a project reference version as default: #stable is the preferred default"			"self deprecated: 'Must specify a project reference version.'."			self flag: 'deprecate after version 1.0'.			(vrsn := self projectClassProject latestVersion) == nil				ifTrue: [ self projectClassProject version: #bleedingEdge ]				ifFalse: [ vrsn ] ]		ifFalse: [ self projectClassProject version: self versionString ]! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:53:29'!versionForScriptEngine: aMetacelloScriptEngine    | prj |    prj := self projectClass ifNil: [ self project ] ifNotNil: [ self projectClassProject ].    ^ ((prj projectForScriptEngine: aMetacelloScriptEngine) version: self versionString)        silently: aMetacelloScriptEngine silently;        ignoreImage: aMetacelloScriptEngine ignoreImage;        cacheRepository: aMetacelloScriptEngine cacheRepository;        repositoryOverrides: aMetacelloScriptEngine repositoryOverrides! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!workingCopy  ^ self projectPackage workingCopy! !!MetacelloProjectSpec methodsFor: 'adding' stamp: '9/28/2017 08:54:38'!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := (aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!canDowngradeTo: aMetacelloProjectSpec  (self className = aMetacelloProjectSpec className    and: [ self operator == aMetacelloProjectSpec operator ])    ifFalse: [ ^ false ].  self versionOrNil == nil    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/198#issuecomment-21737458"      ^ true ].  ^ (self compareVersions: aMetacelloProjectSpec usingOperator: self operator)    not! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!canUpgradeTo: aMetacelloProjectSpec  (self className = aMetacelloProjectSpec className    and: [ self operator == aMetacelloProjectSpec operator ])    ifFalse: [ ^ false ].  self versionOrNil == nil    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/198#issuecomment-21737458"      ^ true ].  ^ self compareVersions: aMetacelloProjectSpec usingOperator: self operator! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!className    className ifNil: [ self name ifNotNil: [ self className: self constructClassName ] ].    ^ className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!className: aString    self shouldBeMutable.    className := aString! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!className: aString constructor: aVersionConstructor    aVersionConstructor classNameForProject: aString! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!compareEqual: aMetacelloProjectSpec  "name className versionString operator loads preLoadDoIt postLoadDoIt"  ^ self className = aMetacelloProjectSpec className    and: [       (self compareVersionsEqual: aMetacelloProjectSpec)        and: [           self operator == aMetacelloProjectSpec operator            and: [               self loads = aMetacelloProjectSpec loads                and: [                   self preLoadDoIt value == aMetacelloProjectSpec preLoadDoIt value                    and: [ self postLoadDoIt value == aMetacelloProjectSpec postLoadDoIt value ] ] ] ] ]! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!compareVersions: aMetacelloProjectSpec usingOperator: anOperator  ^ aMetacelloProjectSpec versionOrNil == nil    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/199#issuecomment-21739622"      aMetacelloProjectSpec versionString asMetacelloVersionNumber        perform: anOperator        with: self version versionNumber ]    ifFalse: [ ^ aMetacelloProjectSpec version perform: anOperator with: self version ]! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!compareVersionsEqual: aMetacelloProjectSpec  | vrsn otherVrsn |  vrsn := self versionOrNil.  otherVrsn := aMetacelloProjectSpec versionOrNil.  vrsn ifNil: [ ^ vrsn = otherVrsn ].  otherVrsn ifNil: [ ^ false ].  ^ vrsn versionNumber = otherVrsn versionNumber! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configHasVersionString  ^ self versionString ~~ nil! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodBodyOn: aStream indent: indent  ^ self configMethodBodyOn: aStream indent: indent fromShortCut: false! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodBodyOn: aStream indent: indent fromShortCut: fromShortCut  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self configHasVersionString.  hasOperator := operator ~~ nil.  hasProjectPackage := self hasRepository    or: [ hasClassName & (self getFile ~~ nil) ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasClassName    ifTrue: [       hasVersionString | hasOperator | hasProjectPackage | hasLoads        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'className: ' , self className printString.      hasVersionString | hasPreLoadDoIt | hasPostLoadDoIt | hasOperator        | hasLoads | hasProjectPackage        ifTrue: [ aStream nextPut: $; ] ].  hasVersionString    ifTrue: [       | vs |      hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt        | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      vs := self versionString.      aStream nextPutAll: 'versionString: '.      vs isSymbol        ifTrue: [ aStream nextPut: $# ].      aStream nextPutAll: vs asString printString.      hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasProjectPackage        | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasPreLoadDoIt    ifTrue: [       hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'preLoadDoIt: '.      self preLoadDoIt value isSymbol        ifTrue: [           aStream            nextPut: $#;            nextPutAll: self preLoadDoIt value asString printString ]        ifFalse: [ aStream nextPutAll: self preLoadDoIt value asString ].      hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasPostLoadDoIt    ifTrue: [       hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'postLoadDoIt: '.      self postLoadDoIt value isSymbol        ifTrue: [           aStream            nextPut: $#;            nextPutAll: self postLoadDoIt value asString printString ]        ifFalse: [ aStream nextPutAll: self postLoadDoIt value asString ].      hasOperator | hasProjectPackage | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasOperator    ifTrue: [       hasClassName | hasVersionString | hasProjectPackage | hasLoads | hasPreLoadDoIt        | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'operator: #' , self operator asString printString.      hasProjectPackage | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasLoads    ifTrue: [       hasClassName | hasVersionString | hasOperator | hasProjectPackage        | hasPreLoadDoIt | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'loads: #('.      self loads do: [ :str | aStream nextPutAll: str printString , ' ' ].      aStream nextPut: $).      hasProjectPackage        ifTrue: [ aStream nextPut: $; ] ].  hasProjectPackage    ifTrue: [       | hasName hasRepo |      hasRepo := self hasRepository.      hasName := self file ~= self className.      hasName        ifTrue: [           hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt            | hasPostLoadDoIt            ifTrue: [               aStream                cr;                tab: indent + 1 ]            ifFalse: [ aStream space ].          aStream nextPutAll: 'file: ' , self file printString.          hasRepo            ifTrue: [ aStream nextPut: $; ] ].      hasRepo        ifTrue: [           | repos |          repos := self repositories map values.          repos size = 1            ifTrue: [               fromShortCut                ifTrue: [                   hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt                    | hasPostLoadDoIt | hasName                    ifTrue: [                       aStream                        cr;                        tab: indent + 1 ]                    ifFalse: [ aStream space ] ]                ifFalse: [                   aStream                    cr;                    tab: indent + 1 ].              repos first configMethodCascadeOn: aStream lastCascade: true ]            ifFalse: [               aStream cr.              self repositories configMethodCascadeOn: aStream indent: indent ] ] ]! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream indent: indent.	aStream nextPut: $.! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configShortCutMethodOn: aStream member: aMember indent: indent  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self configHasVersionString.  hasOperator := operator ~~ nil.  hasProjectPackage := self hasRepository    or: [ hasClassName & (self getFile ~~ nil or: [ className ~= self name ]) ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt    | hasPostLoadDoIt    ifTrue: [       (aMember methodUpdateSelector == #'copy:'        or: [ aMember methodUpdateSelector == #'with:' ])        ifTrue: [           aStream            nextPutAll: 'with: [';            cr ]        ifFalse: [           aStream            nextPutAll: 'overrides: [';            cr ].      aStream        tab: indent;        nextPutAll: 'spec'.      self configMethodBodyOn: aStream indent: indent fromShortCut: true.      aStream nextPutAll: ' ]'.      ^ self ].  hasVersionString    ifTrue: [       | vs |      vs := self versionString.      aStream nextPutAll: 'with: '.      vs isSymbol        ifTrue: [ aStream nextPut: $# ].      aStream nextPutAll: vs asString printString ]! !!MetacelloProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!constructClassName    ^ nil! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!currentlyLoadedClassesInVersion    self versionOrNil ifNotNil: [ :vrsn | ^ vrsn currentlyLoadedClassesInVersion ].    ^ #()! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!file    ^ self className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getClassName    "raw access to iv"    ^ className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getFile    "raw access to iv"    ^ nil! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getOperator	^operator! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!getPostLoadDoIt	^postLoadDoIt! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!getPreLoadDoIt	^preLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getRepositories    "raw access to iv"    ^ nil! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!hasClassName    ^ className ~~ nil! !!MetacelloProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasLoadConflicts: aMetacelloProjectSpec  ^ (self hasNoLoadConflicts: aMetacelloProjectSpec) not! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!hasNoLoadConflicts: aMetacelloProjectSpec  "same as compareEqual:, except if versionString and/or repositories are not 	specified for either one, then there are not conflicts"  ^ self className = aMetacelloProjectSpec className    and: [       (self compareVersionsEqual: aMetacelloProjectSpec)        and: [ self operator == aMetacelloProjectSpec operator ] ]! !!MetacelloProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasNonVersionStringField    | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |    hasClassName := self hasClassName.    hasVersionString := self versionString ~~ nil.    hasOperator := operator ~~ nil.    hasProjectPackage := (self file ~~ nil and: [ hasClassName and: [ self className ~= self name ] ])        or: [ self hasRepository ].    hasLoads := self loads ~~ nil.    hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.    hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.    ^ hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt! !!MetacelloProjectSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!hasRepository    ^ false! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!isLocked  ^ self registration locked! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!label	^self name! !!MetacelloProjectSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!load	self subclassResponsibility! !!MetacelloProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!loadListForVersion: vrsn 	^ (self loads == nil			or: [self loads isEmpty])		ifTrue: [vrsn spec defaultPackageNames]		ifFalse: [self loads]! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!loads	^ loads! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loads: aCollection	aCollection setLoadsInMetacelloProject: self! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!loads: anObject constructor: aVersionConstructor    aVersionConstructor loadsForProject: anObject! !!MetacelloProjectSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap	| map |	map := super mergeMap.	map at: #name put: name.	map at: #className put: className.	map at: #versionString put: versionString.	map at: #operator put: operator.	map at: #loads put: loads.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!mergeScriptLoads: aSpec    self shouldBeMutable.    aSpec loads        ifNotNil: [ :otherLoads | self loads ifNil: [ loads := otherLoads ] ifNotNil: [ loads := (loads , otherLoads) asSet asArray ] ].    self loader: aSpec loader! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!metacelloRegistrationHash    "name className versionString operator loads preLoadDoIt postLoadDoIt"    | hash |    hash := String stringHash: name initialHash: 0.    hash := String stringHash: self className initialHash: hash.    hash := String stringHash: self versionString initialHash: hash.    hash := String stringHash: self operator asString initialHash: hash.    hash := String stringHash: self preLoadDoIt asString initialHash: hash.    hash := String stringHash: self postLoadDoIt asString initialHash: hash.    ^ hash bitXor: loads hash! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!name	^name! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!name: aString    ((aString at: 1) isSeparator or: [ (aString at: aString size) isSeparator ])        ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , aString printString ].    self shouldBeMutable.    name := aString! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!name: aString constructor: aVersionConstructor    aVersionConstructor nameForProject: aString! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!operator	operator == nil ifTrue: [ ^#>= ].	^ operator! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!operator: anObject    " #= #~= #> #< #>= #<= #~> "    self shouldBeMutable.    operator := anObject! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!operator: anObject constructor: aVersionConstructor    aVersionConstructor operatorForProject: anObject! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!postLoadDoIt	^postLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!postLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor postLoadDoItForProject: aSymbol! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!preLoadDoIt	^preLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!preLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor preLoadDoItForProject: aSymbol! !!MetacelloProjectSpec methodsFor: 'visiting' stamp: '9/28/2017 08:54:38'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock    projectBlock value: self! !!MetacelloProjectSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!projectLabel    ^ 'project'! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!projectPackage	^nil! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!registration    ^ MetacelloProjectRegistration        registrationForProjectSpec: self        ifAbsent: [ :ignored |  ]        ifPresent: [ :existing :new | existing ]! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!registrationsCompareEqual: aMetacelloProjectSpec    "name className versionString operator loads preLoadDoIt postLoadDoIt"    ^ self className = aMetacelloProjectSpec className        and: [ self versionString = aMetacelloProjectSpec versionString and: [ self operator == aMetacelloProjectSpec operator ] ]! !!MetacelloProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!resolveToLoadableSpec	^self copy! !!MetacelloProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setLoads: aCollection    self shouldBeMutable.    loads := aCollection! !!MetacelloProjectSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setName: aStringOrNil    self shouldBeMutable.    name := aStringOrNil! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setPostLoadDoIt: aSymbol    self shouldBeMutable.    postLoadDoIt := aSymbol! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setPreLoadDoIt: aSymbol    self shouldBeMutable.    preLoadDoIt := aSymbol! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: '9/28/2017 08:54:38'!unregisterProject    ^ MetacelloProjectRegistration        registrationForProjectSpec: self        ifAbsent: [  ]        ifPresent: [ :existing :new | existing unregisterProject ]! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!version    self subclassResponsibility! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!version: anObject constructor: aVersionConstructor    aVersionConstructor versionForProject: anObject! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionKey	"suitable for using as a unique key for the receiver's version in a dictionary"	^ self version versionKey! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionOrNil	^[ self version ] on: MetacelloVersionDoesNotExistError do: [:ex | ^nil ].! !!MetacelloProjectSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionString	^ versionString! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject    self shouldBeMutable.    versionString := anObject! !!MetacelloProjectSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!versionString: anObject constructor: aVersionConstructor    aVersionConstructor versionStringForProject: anObject! !!MetacelloRepositorySpec methodsFor: 'adding' stamp: '9/28/2017 08:53:29'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: '9/28/2017 08:53:29'!canUpgradeTo: aMetacelloRepositorySpec  self description = aMetacelloRepositorySpec description    ifTrue: [ ^ true ].  (#('github' 'gitorious' 'bitbucket') includes: self type)    ifTrue: [ ^ self createRepository canUpgradeTo: aMetacelloRepositorySpec createRepository ].  ^ false! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodCascadeOn: aStream lastCascade: lastCascade	aStream nextPutAll: 'repository: ', self description printString.	(self username isEmpty not or: [ self password isEmpty not ])		ifTrue: [ aStream nextPutAll: ' username: ', self username printString, ' password: ', self password printString ].	lastCascade ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodOn: aStream indent: indent	aStream 		tab: indent; 		nextPutAll: 'spec '.	self configMethodCascadeOn: aStream lastCascade: true! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'ct 11/7/2020 18:48'!createRepository  | repo |  repo := self project createRepository: self.  ^ self updateRepository: (MCRepositoryGroup default repositories    detect: [ :each | each = repo ]    ifNone: [       MCRepositoryGroup default addRepository: repo.      repo ])! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!description	^description! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!description: aString	description := aString! !!MetacelloRepositorySpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!extractTypeFromDescription	^MetacelloPlatform current extractTypeFromDescription: self description! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 02/26/2016 12:32'!hasNoLoadConflicts: aMetacelloRepositorySpec  self description = aMetacelloRepositorySpec description    ifTrue: [ ^ true ].  self type = aMetacelloRepositorySpec type    ifFalse: [       "if the types are different then we don't need to create the repoitory to        know that there will be conflicts"      ^ false ].  (#('github' 'gitorious' 'bitbucket') includes: self type)    ifTrue: [       ^ self createRepository        hasNoLoadConflicts: aMetacelloRepositorySpec createRepository ].  ^ false! !!MetacelloRepositorySpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeMap    | map |    map := super mergeMap.    map at: #'description' put: description.    map at: #'type' put: self type.    map at: #'username' put: username.    map at: #'password' put: password.    ^ map! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!name	^self description! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!password	password == nil ifTrue: [ password := '' ].	^password! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!password: aString	password := aString! !!MetacelloRepositorySpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!type	type == nil ifTrue: [ type := self extractTypeFromDescription ].	^type! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!type: aString	type := aString! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'ct 11/7/2020 20:09'!updateRepository: aRepository    (self username notNil and: [self username notEmpty]) ifTrue: [        aRepository username: self username].	(self password notNil and: [self password notEmpty]) ifTrue: [        aRepository password: self password].	^ aRepository! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!username	username == nil ifTrue: [ username := '' ].	^username! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!username: aString	username := aString! !!MetacelloSpec class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!for: aVersionMap	^(self platformClass new)		for: aVersionMap;		yourself! !!MetacelloSpec class methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!platformClass	^self! !!MetacelloSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!aboutToCopy! !!MetacelloSpec methodsFor: 'spec creation' stamp: '9/28/2017 08:54:38'!addMember	^MetacelloAddMemberSpec for: self project! !!MetacelloSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!answers	^#()! !!MetacelloSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	self subclassResponsibility! !!MetacelloSpec methodsFor: 'spec creation' stamp: '9/28/2017 08:54:38'!copyMember	^MetacelloCopyMemberSpec for: self project! !!MetacelloSpec methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!copyOnWrite: aBlock    "assume that only registered projects are immutable ... otherwise you'll get an error"    | copy |    copy := self copy.    aBlock value: copy.    ^ copy! !!MetacelloSpec methodsFor: 'doits' stamp: '9/28/2017 08:54:38'!doItBlock: selector	selector == nil ifTrue: [ ^nil ].	selector numArgs = 0		ifTrue: [ ^[ self project configuration perform: selector ] ].	selector numArgs = 1		ifTrue: [ ^[:aLoader | self project configuration perform: selector with: aLoader ] ].	selector numArgs = 2		ifTrue: [ ^[:aLoader :pkgSpec | self project configuration perform: selector with: aLoader with: pkgSpec ] ].	^nil! !!MetacelloSpec methodsFor: 'initialization' stamp: '9/28/2017 08:54:38'!for: aProject    self shouldBeMutable.    project := aProject! !!MetacelloSpec methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!immutable    mutable := false! !!MetacelloSpec methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!isMutable    mutable ifNil: [ ^ true ].    ^ mutable! !!MetacelloSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!label	^self printString! !!MetacelloSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loader	loader == nil 		ifTrue: [ | prjctLoader |			(prjctLoader := self project loader) == nil				ifTrue: [ self loader: (self project loaderClass on: self) ]				ifFalse: [ self loader: prjctLoader ]].	^loader! !!MetacelloSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loader: aLoader    "We're interested in propogating the loader state, _except_ for the spec"    self shouldBeMutable.    loader := aLoader copy.    loader spec: self! !!MetacelloSpec methodsFor: 'importing' stamp: '9/28/2017 08:54:38'!mergeImportLoads: aLoadList    self error: 'import: can only be used with baseline project specs'! !!MetacelloSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap	^Dictionary new.! !!MetacelloSpec methodsFor: 'spec creation' stamp: '9/28/2017 08:54:38'!mergeMember	^MetacelloMergeMemberSpec for: self project! !!MetacelloSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeSpec: aSpec    | newSpec nonOverridable |    self validateMergeForSpec: aSpec.    newSpec := self copy.    nonOverridable := self nonOverridable.    aSpec mergeMap        keysAndValuesDo: [ :key :value |             (nonOverridable includes: key)                ifFalse: [                     value ~~ nil                        ifTrue: [ newSpec instVarNamed: key asString put: value ] ] ].    ^ newSpec! !!MetacelloSpec methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!mutable    mutable := true! !!MetacelloSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!nonOverridable	^#()! !!MetacelloSpec methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy    super postCopy.    mutable := nil.    loader ~~ nil        ifTrue: [ self loader: loader ].! !!MetacelloSpec methodsFor: 'doits' stamp: '9/28/2017 08:54:38'!postLoadDoIt	"noop unless non-nil value returned"	^nil! !!MetacelloSpec methodsFor: 'doits' stamp: '9/28/2017 08:54:38'!postLoadDoItBlock	^self doItBlock: self postLoadDoIt value! !!MetacelloSpec methodsFor: 'doits' stamp: '9/28/2017 08:54:38'!preLoadDoIt	"noop unless non-nil value returned"		^nil! !!MetacelloSpec methodsFor: 'doits' stamp: '9/28/2017 08:54:38'!preLoadDoItBlock	^self doItBlock: self preLoadDoIt value! !!MetacelloSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!project	^project! !!MetacelloSpec methodsFor: 'spec creation' stamp: '9/28/2017 08:54:38'!removeMember	^MetacelloRemoveMemberSpec for: self project! !!MetacelloSpec methodsFor: 'mutability' stamp: '9/28/2017 08:54:38'!shouldBeMutable    self isMutable        ifTrue: [ ^ self ].    self error: 'Not allowed to modify an immutable object'! !!MetacelloSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!validateMergeForSpec: aSpec    aSpec class = self class        ifFalse: [             self                error:                    'The project spec ' , self name printString , ' in project ' , self project label , ' has incompatible specs. '                        , aSpec class name asString , ' and ' , self class name asString , ' are not compatible.' ]! !!MetacelloSpec methodsFor: 'merging' stamp: 'ct 11/7/2020 15:01:25'!validateMergeWithBaselineOfSpec: aSpec  ^ aSpec class = self class! !!MetacelloValueHolderSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	aStream tab: indent; nextPutAll: 'spec value: ', self value printString! !!MetacelloValueHolderSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap	| map |	map := super mergeMap.	map at: #value put: value.	^map! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: self! !!MetacelloValueHolderSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!value	^ value! !!MetacelloValueHolderSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!value: anObject	value := anObject! !!MetacelloValueHolderSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!value: anObject constructor: aVersionConstructor    aVersionConstructor valueForValueHolder: anObject! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!computeVersionStatus: matchBlock	self computeVersionStatus: (self expandToLoadableSpecNames: #('ALL')) matchBlock: matchBlock! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!computeVersionStatus: resolvedPackageAndProjectNames matchBlock: matchBlock	| status |	status := resolvedPackageAndProjectNames isNil		ifTrue: [ self isPartiallyCurrent ]		ifFalse: [ self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].	status isAllLoadedToSpec: matchBlock.	status isLoadedToSpec: matchBlock.	status isLoadedMatchConstraints: matchBlock.	status isSomethingLoaded: matchBlock! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configMethodOn: aStream last: last indent: indent    | spec hasRepositories hasPackageSpecs hasImport |    hasRepositories := (spec := self repositoriesSpec) ~~ nil and: [ spec list isEmpty not ].    hasImport := self import ~~ nil.    hasPackageSpecs := false.    self packagesSpec list        do: [ :member |             member spec                projectDo: [ :proj |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                packageDo: [ :package |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                groupDo: [ :group |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ] ].    self configMethodBasicOn: aStream last: (hasRepositories | hasPackageSpecs | hasImport) not indent: indent.    hasImport        ifTrue: [             self                configMethodValueOn: aStream                for: self import                selector: 'import:'                last: (hasRepositories | hasPackageSpecs) not                indent: indent ].    hasRepositories        ifTrue: [             spec map values size = 1                ifTrue: [                     aStream                        tab: indent;                        nextPutAll: 'spec repository: ';                        nextPutAll: spec map values first description printString , '.'.                    hasPackageSpecs                        ifTrue: [ aStream cr ] ]                ifFalse: [                     self                        configMethodOn: aStream                        for: spec                        selector: 'repositories:'                        last: hasPackageSpecs not                        indent: indent ] ].    self configPackagesSpecMethodOn: aStream indent: indent.    last        ifFalse: [ aStream cr ]! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!configSpawnMethodOn: aStream indent: indent	super configSpawnMethodOn: aStream indent: indent.	self configPackagesSpecMethodOn: aStream indent: indent.! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!currentlyLoadedClassesInVersion  | classes |  classes := Set new.  self    projectDo: [ :ignored |  ]    packageDo: [ :packageSpec |       | wc |      wc := [ packageSpec workingCopy ]        on: Error        do: [ :ex | ex return: nil ].      wc ~~ nil        ifTrue: [ classes addAll: (MetacelloPlatform current packageInfoFor: wc) classes ] ]    groupDo: [ :ignored |  ].  ^ classes! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!currentlyLoadedExtensionClassesInVersion  | classes |  classes := Dictionary new.  self    projectDo: [ :ignored |  ]    packageDo: [ :packageSpec |       | wc |      wc := [ packageSpec workingCopy ]        on: Error        do: [ :ex | ex return: nil ].      wc ~~ nil        ifTrue: [           | packageInfo |          packageInfo := MetacelloPlatform current packageInfoFor: wc.          packageInfo extensionClasses            do: [ :cl | classes at: cl put: (packageInfo extensionCategoriesForClass: cl) ] ] ]    groupDo: [ :ignored |  ].  ^ classes! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!difference: otherVersionSpec    "Return a dictionary of additions, removals and modifications"    | report myProjectSpecs myPackageSpecs otherProjectSpecs otherPackageSpecs |    report := MetacelloVersionDiffReport new.    myProjectSpecs := Dictionary new.    myPackageSpecs := Dictionary new.    self        projectDo: [ :projectSpec | myProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :packageSpec | myPackageSpecs at: packageSpec name put: packageSpec ]        groupDo: [ :ignored |  ].    otherProjectSpecs := Dictionary new.    otherPackageSpecs := Dictionary new.    otherVersionSpec        projectDo: [ :projectSpec | otherProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :packageSpec | otherPackageSpecs at: packageSpec name put: packageSpec ]        groupDo: [ :ignored |  ].    myProjectSpecs        valuesDo: [ :myProjectSpec |             | otherProjectSpec |            otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].            otherProjectSpec == nil                ifTrue: [                     report removals                        at: myProjectSpec name                        put:                            {(myProjectSpec versionString).                            ''} ]                ifFalse: [                     myProjectSpec versionString = otherProjectSpec versionString                        ifFalse: [                             report modifications                                at: myProjectSpec name                                put:                                    {(myProjectSpec versionString).                                    (otherProjectSpec versionString)} ] ] ].    otherProjectSpecs        valuesDo: [ :otherProjectSpec |             (myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil                ifTrue: [                     report additions                        at: otherProjectSpec name                        put:                            {''.                            (otherProjectSpec versionString)} ] ].    myPackageSpecs        valuesDo: [ :myPackageSpec |             | otherPackageSpec |            otherPackageSpec := otherPackageSpecs at: myPackageSpec name ifAbsent: [  ].            otherPackageSpec == nil                ifTrue: [                     report removals                        at: myPackageSpec name                        put:                            {(myPackageSpec file).                            ''} ]                ifFalse: [                     myPackageSpec file = otherPackageSpec file                        ifFalse: [                             report modifications                                at: myPackageSpec name                                put:                                    {(myPackageSpec file).                                    (otherPackageSpec file)} ] ] ].    otherPackageSpecs        valuesDo: [ :otherPackageSpec |             (myPackageSpecs at: otherPackageSpec name ifAbsent: [  ]) == nil                ifTrue: [                     report additions                        at: otherPackageSpec name                        put:                            {''.                            (otherPackageSpec file)} ] ].    ^ report! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!forceUpdatedPackageSpecs	| updatedSpecs mcLoader |	updatedSpecs := Dictionary new.	mcLoader := self loader.	self packages map valuesDo: [:pkg | pkg forceUpdatePackageSpec: updatedSpecs using: mcLoader].	^updatedSpecs! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isAllLoadedToSpec	"all projects and packages are loaded and match specification"	self isPartiallyCurrent isAllLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isAllLoadedToSpecAgainst: resolvedPackageAndProjectNames	"all projects and packages are loaded and match specification"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isAllLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isLoadedMatchConstraints	"all loaded projects and packages match constraints (at least one package loaded)"		self isPartiallyCurrent isLoadedMatchConstraints: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isLoadedMatchConstraintsAgainst: resolvedPackageAndProjectNames	"all loaded projects and packages match constraints (at least one package loaded)"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedMatchConstraints: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isLoadedToSpec	"all loaded projects and packages match specifications (at least one package loaded)"		self isPartiallyCurrent isLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isLoadedToSpecAgainst: resolvedPackageAndProjectNames	"all loaded projects and packages match specifications (at least one package loaded)"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isPartiallyCurrent	^self isPartiallyCurrentAgainst: (self expandToLoadableSpecNames: #('ALL'))! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isPartiallyCurrentAgainst: resolvedPackageAndProjectNames	| mcLoader status |	status := MetacelloMCPartiallyLoadedStatus new.	mcLoader := self loader.	self		specsNamed: resolvedPackageAndProjectNames		projectDo: [ :prj | 			| vrsn currentVersion |			status hasNoProject: false.			vrsn := prj versionOrNil.			vrsn ~~ nil				ifTrue: [ 					(currentVersion := prj relativeCurrentVersion) ~~ nil						ifTrue: [ status vrsnStatus add: currentVersion versionStatus ] ].			currentVersion ~~ nil				ifTrue: [ 					status aProjectIsLoaded: true.					(currentVersion perform: #= with: vrsn)						ifTrue: [ status aLoadedProjectIsExact: true ]						ifFalse: [ 							(currentVersion perform: prj projectReference operator with: vrsn)								ifTrue: [ status aLoadedProjectIsCurrent: true ]								ifFalse: [ status aLoadedProjectIsNotCurrent: true ] ] ]				ifFalse: [ status aProjectNotLoaded: true ] ]		packageDo: [ :pkg | 			status hasNoPackage: false.			pkg				currentPackageLoaded: [ :versionInfos :file | 					| wcName wcRef fileRef exact current |					status aPackageIsLoaded: true.					versionInfos isEmpty						ifTrue: [ status aLoadedPackageIsNotCurrent: true ]						ifFalse: [ 							exact := current := false.							versionInfos								do: [ :vi | 									wcName := vi name.									fileRef := GoferResolvedReference name: file.									wcRef := GoferResolvedReference name: wcName.									(wcRef compare: fileRef using: #=)										ifTrue: [ exact := true ] ].							exact								ifTrue: [ status aLoadedPackageIsExact: true ]								ifFalse: [ 									versionInfos										do: [ :vi | 											wcName := vi name.											fileRef := GoferResolvedReference name: file.											wcRef := GoferResolvedReference name: wcName.											(wcRef compare: fileRef using: #>=)												ifTrue: [ current := true ] ].									current										ifTrue: [ status aLoadedPackageIsCurrent: true ]										ifFalse: [ status aLoadedPackageIsNotCurrent: true ] ] ] ]				notLoaded: [ status aPackageNotLoaded: true ]				using: mcLoader ]		groupDo: [ :ignoredGroup | 			"if we encounter a group, trouble"			status abort: true.			^ status ].	^ status! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isPossibleBaseline	self 		projectDo: [:prj | prj isPossibleBaseline ifFalse: [ ^false ]] 		packageDo: [:pkg | pkg isPackageLoaded ifFalse: [ ^false ]] 		groupDo: [:ignored | ].	^true! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isSomethingLoaded	"at least one package loaded"		self isPartiallyCurrent isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!isSomethingLoadedAgainst: resolvedPackageAndProjectNames	"at least one package loaded"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeMap    | map |    map := super mergeMap.    map at: #'repositories' put: self repositories.    ^ map! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!mergeSpec: anotherSpec    | newSpec map anotherRepositories |    newSpec := super mergeSpec: anotherSpec.    map := anotherSpec mergeMap.    (anotherRepositories := map at: #'repositories') isEmpty not        ifTrue: [             newSpec                repositories:                    (self repositories isEmpty                        ifTrue: [ anotherRepositories ]                        ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].    ^ newSpec! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: '9/28/2017 08:53:29'!nonOverridable    ^ super nonOverridable , #(#'repositories')! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!package: aString constructor: aVersionConstructor    aVersionConstructor packageForVersion: aString! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!package: aString overrides: aBlock constructor: aVersionConstructor    aVersionConstructor packageForVersion: aString overrides: aBlock! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!package: packageName with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor packageForVersion: packageName with: aBlockOrString! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!packageNames    "leave reference to packages for upgrade purposes"    packages == nil        ifTrue: [ ^ super packageNames ].    ^ self packages map keys asSet! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:53:29'!packageSpecsInLoadOrderForMap: packageMap  | loadOrder pkgs packageNames importNames importSpec importProjectSpecs importProjectNameMap |  loadOrder := self packageSpecsInLoadOrder.  importNames := (packageNames := (packageMap values    collect: [ :pkg | pkg name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ])    ifTrue: [ ^ loadOrder select: [ :pkg | packageNames includes: pkg name ] ].  loadOrder do: [ :pkg | importNames remove: pkg name ifAbsent: [  ] ].  pkgs := OrderedCollection new.  importProjectSpecs := Dictionary new.  importProjectNameMap := Dictionary new.  importArray    ifNotNil: [       loadOrder        do: [ :pkg |           importArray            do: [ :assoc |               assoc key = pkg name                ifTrue: [                   importProjectSpecs at: pkg name put: pkg.                  (assoc value select: [ :each | importNames includes: each ])                    do: [ :each |                       (importProjectNameMap                        at: pkg name                        ifAbsent: [ importProjectNameMap at: pkg name put: Set new ])                        add: each ] ] ] ] ].  self import    ifNotNil: [       loadOrder        do: [ :pkg |           pkg name = self import            ifTrue: [               importProjectSpecs at: pkg name put: pkg.              importProjectNameMap at: pkg name put: importNames ] ] ].  loadOrder    do: [ :pkg |       (packageNames includes: pkg name)        ifTrue: [ pkgs add: pkg ].      importProjectSpecs        at: pkg name        ifPresent: [ :importProjectSpec |           "insert the imports at this point"          (importProjectNameMap at: pkg name ifAbsent: [ #() ])            do: [ :importedName |               pkgs                add:                  (importSpec := importProjectSpec copy                    name: importedName;                    mergeImportLoads: {importedName};                    yourself).              importSpec projectReference name: importedName ] ] ].  ^ pkgs! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packages    "leave reference to packages for upgrade purposes"    packages == nil        ifTrue: [ ^ super packages ].    ^ packages! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!packagesNeedSavingVisited: visitedProjects into: aCollection	self packages map valuesDo: [:pkg | pkg packagesNeedSavingVisited: visitedProjects using: self repositories map values into: aCollection ].! !!MetacelloMCVersionSpec methodsFor: 'copying' stamp: '9/28/2017 08:53:29'!postCopy    super postCopy.    repositories := repositories copy.    packages := packages copy	"leave reference to packages for upgrade purposes"! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:53:29'!removePackage: aString constructor: aVersionConstructor    aVersionConstructor removePackageForVersion: aString! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositories	repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].	^ repositories! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositories: anObject	repositories := anObject! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositoriesSpec	^self repositories! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repository: aString	self repositoriesSpec add: aString! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repository: aString username: username password: password	self repositoriesSpec repository: aString username: username password: password! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: '9/28/2017 08:53:29'!repositorySpecs	^self repositories map values! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!specListProjectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self packages specListDo: [:pkgSpec |		pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: '9/28/2017 08:53:29'!specsNamed: packageAndProjectNames projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	| map |	map := self packages map.	packageAndProjectNames do: [:name | | pkgSpec |		(pkgSpec := map at: name ifAbsent: [ ]) ~~ nil			ifTrue: [ pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]]! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		repositories := preLoadDoIt := postLoadDoIt := nil.! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!updatedPackageSpecs	| updatedSpecs mcLoader |	updatedSpecs := Dictionary new.	mcLoader := self loader.	self packages map valuesDo: [:pkg | pkg updatePackageSpec: updatedSpecs using: mcLoader].	^updatedSpecs! !!MetacelloMCVersionSpec methodsFor: 'private' stamp: '9/28/2017 08:53:29'!versionClass	^MetacelloMCVersion! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!author	author == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ author! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!author: anObject	anObject setAuthorInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!author: aBlockOrString constructor: aVersionConstructor    aVersionConstructor authorForVersion: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!baseline: aString constructor: aVersionConstructor    aVersionConstructor baselineForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!baseline: aString with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor baselineForVersion: aString with: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!blessing	blessing == nil 		ifTrue: [			^self project valueHolderSpec				value: self project defaultBlessing;				yourself].	^ blessing! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!blessing: anObject	anObject setBlessingInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!blessing: aBlockOrString constructor: aVersionConstructor    aVersionConstructor blessingForVersion: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodBasicOn: aStream last: last indent: indent    | values lastIndex lastBlock |    last        ifTrue: [             "need to calculate last statement with a value"            values := {(self getBlessing).            (self getDescription).            (self getPreLoadDoIt).            (self getPostLoadDoIt).            (self getAuthor).            (self getTimestamp)}.            1 to: values size do: [ :index |                 (values at: index) ~~ nil                    ifTrue: [ lastIndex := index ] ].            lastBlock := [ :arg | arg = lastIndex ] ]        ifFalse: [ lastBlock := [ :arg | false ] ].    self        configMethodValueOn: aStream        for: self getBlessing        selector: 'blessing:'        last: (lastBlock value: 1)        indent: indent.    self        configMethodValueOn: aStream        for: self getDescription        selector: 'description:'        last: (lastBlock value: 2)        indent: indent.    self        configMethodValueOn: aStream        for: self getPreLoadDoIt        selector: 'preLoadDoIt:'        last: (lastBlock value: 3)        indent: indent.    self        configMethodValueOn: aStream        for: self getPostLoadDoIt        selector: 'postLoadDoIt:'        last: (lastBlock value: 4)        indent: indent.    self        configMethodValueOn: aStream        for: self getAuthor        selector: 'author:'        last: (lastBlock value: 5)        indent: indent.    self        configMethodValueOn: aStream        for: self getTimestamp        selector: 'timestamp:'        last: (lastBlock value: 6)        indent: indent! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream for: spec selector: selector last: last indent: indent	spec == nil		ifTrue: [ ^ self ].	aStream		tab: indent;		nextPutAll: 'spec ' , selector , ' [';		cr.	spec configMethodOn: aStream indent: indent + 1.	aStream nextPutAll: ' ].'.	last		ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream indent: indent	self configMethodOn: aStream last: true indent: indent! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodOn: aStream last: last indent: indent    | hasPackageSpecs |    hasPackageSpecs := false.    self packagesSpec list        do: [ :member |             member spec                projectDo: [ :proj |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                packageDo: [ :package |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                groupDo: [ :group |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ] ].    self configMethodBasicOn: aStream last: hasPackageSpecs not indent: indent.    self configPackagesSpecMethodOn: aStream indent: indent.    last        ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configMethodValueOn: aStream for: spec selector: selector last: last indent: indent	| valuePrintString |	spec == nil		ifTrue: [ ^ self ].	valuePrintString := spec value isSymbol		ifTrue: [ '#' , spec value asString printString ]		ifFalse: [ spec value printString ].	aStream		tab: indent;		nextPutAll: 'spec ' , selector , ' ' , valuePrintString , '.'.	last		ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configPackagesSpecMethodOn: aStream indent: indent	| projectSpecs packageSpecs groupSpecs |	projectSpecs := OrderedCollection new.	packageSpecs := OrderedCollection new.	groupSpecs := OrderedCollection new.	self packagesSpec list do: [:member |		member spec 			projectDo: [:proj | member spec name ~~ nil ifTrue: [ projectSpecs add: member ]]			packageDo: [:package | member spec name ~~ nil ifTrue: [ packageSpecs add: member ]]			groupDo: [:group | member spec name ~~ nil ifTrue: [ groupSpecs add: member ]]].	projectSpecs isEmpty not		ifTrue: [			aStream tab: indent; nextPutAll: 'spec '.			projectSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: projectSpecs size  do: [:index | 				(projectSpecs at: index) configMethodCascadeOn: aStream last: index == projectSpecs size indent: indent + 1.				index ~= projectSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	packageSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			packageSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: packageSpecs size  do: [:index | 				(packageSpecs at: index) configMethodCascadeOn: aStream last: index == packageSpecs size indent: indent + 1.				index ~= packageSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	groupSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not | packageSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			groupSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: groupSpecs size  do: [:index | 				(groupSpecs at: index) configMethodCascadeOn: aStream last: index == groupSpecs size indent: indent + 1.				index ~= groupSpecs size ifTrue: [ aStream tab: indent + 1 ]]].! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!configSpawnMethodOn: aStream indent: indent	self configMethodValueOn: aStream for: self getBlessing selector: 'blessing:' last: false indent: indent.	self configMethodValueOn: aStream for: self getAuthor selector: 'author:' last: false indent: indent.	self configMethodValueOn: aStream for: self getTimestamp selector: 'timestamp:' last: false indent: indent.! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!configuration: aString with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor configurationForVersion: aString with: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!createVersion	^self versionClass fromSpec: self! !!MetacelloVersionSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!defaultPackageNames	"if there is a package named 'default' (a group) then it defines the default package names,	 otherwise answer a list of all of the package names in this version"	self packages packageNamed: 'default' ifAbsent: [ ^self packageNames ].	^#('default')! !!MetacelloVersionSpec methodsFor: 'toolbox support' stamp: '9/28/2017 08:54:38'!deleteSpec: aSpec    "remove the spec from packages"    self packages deleteSpec: aSpec! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!description	description == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ description! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!description: anObject	anObject setDescriptionInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!description: aBlockOrString constructor: aVersionConstructor    aVersionConstructor descriptionForVersion: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!difference: otherVersionSpec    "Return a dictionary of additions, removals and modifications"    | report myProjectSpecs otherProjectSpecs |    report := MetacelloVersionDiffReport new.    myProjectSpecs := Dictionary new.    self        projectDo: [ :projectSpec | myProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :ignored |  ]        groupDo: [ :ignored |  ].    otherProjectSpecs := Dictionary new.    otherVersionSpec        projectDo: [ :projectSpec | otherProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :ignored |  ]        groupDo: [ :ignored |  ].    myProjectSpecs        valuesDo: [ :myProjectSpec |             | otherProjectSpec |            otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].            otherProjectSpec == nil                ifTrue: [                     report removals                        at: myProjectSpec name                        put:                            {(myProjectSpec versionString).                            ''} ]                ifFalse: [                     myProjectSpec versionString = otherProjectSpec versionString                        ifFalse: [                             report modifications                                at: myProjectSpec name                                put:                                    {(myProjectSpec versionString).                                    (otherProjectSpec versionString)} ] ] ].    otherProjectSpecs        valuesDo: [ :otherProjectSpec |             (myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil                ifTrue: [                     report additions                        at: otherProjectSpec name                        put:                            {''.                            (otherProjectSpec versionString)} ] ].    ^ report! !!MetacelloVersionSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!expandToLoadableSpecNames: nameList	| cacheKey names |	cacheKey := Array with: self label with: nameList.	^MetacelloPlatform current		stackCacheFor: #loadableSpecNames		at: cacheKey		doing: [ :cache | 			names := (self resolveToLoadableSpecs: nameList) collect: [:spec | spec name ].			cache at: cacheKey put: names ].! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getAuthor	^author! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getBlessing	^blessing! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getDescription	^description! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getPostLoadDoIt	^postLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getPreLoadDoIt	^preLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!getTimestamp	^timestamp! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!group: aString overrides: aStringOrCollection constructor: aVersionConstructor    aVersionConstructor groupForVersion: aString overrides: aStringOrCollection! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!group: aString with: aStringOrCollection constructor: aVersionConstructor    aVersionConstructor groupForVersion: aString with: aStringOrCollection! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!import    ^ importName! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!import: aString  importName := aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!import: aString constructor: aVersionConstructor    aVersionConstructor importForVersion: aString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!import: aString provides: anArray  importArray := importArray    ifNil: [ {(aString -> anArray)} ]    ifNotNil: [ importArray , {(aString -> anArray)} ]! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!import: aString provides: anArray constructor: aVersionConstructor  aVersionConstructor importForVersion: aString provides: anArray! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!importArray  ^ importArray! !!MetacelloVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isPartiallyCurrent: notLoadedMatters useEquality: useEquality	self subclassResponsibility! !!MetacelloVersionSpec methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isPossibleBaseline    self subclassResponsibility! !!MetacelloVersionSpec methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!label	^self versionString, ' [', self projectLabel, ']'! !!MetacelloVersionSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeMap    | map |    map := super mergeMap.    map at: #'versionString' put: versionString.    map at: #'blessing' put: blessing.    map at: #'description' put: description.    map at: #'author' put: author.    map at: #'timestamp' put: timestamp.    map at: #'preLoadDoIt' put: preLoadDoIt.    map at: #'postLoadDoIt' put: postLoadDoIt.    map at: #'packageList' put: self packages.    ^ map! !!MetacelloVersionSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!mergeSpec: anotherSpec    | newSpec map anotherPackages |    newSpec := super mergeSpec: anotherSpec.    map := anotherSpec mergeMap.    (anotherPackages := map at: #'packageList') isEmpty not        ifTrue: [             newSpec                packages:                    (self packages isEmpty                        ifTrue: [ anotherPackages ]                        ifFalse: [ self packages mergeSpec: anotherPackages ]) ].    ^ newSpec! !!MetacelloVersionSpec methodsFor: 'merging' stamp: '9/28/2017 08:54:38'!nonOverridable    ^ super nonOverridable , #(#'packageList')! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNamed: aString	^self packageNamed: aString ifAbsent: [ nil ]! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNamed: aString forLoad: ignored forMap: map ifAbsent: absentBlock  "at the end of the day, I don't the forLoad arg is important ...    it just ends up triggering an error ... when during a real load, you would    not get error. After a decent period of mourning we should just scrub this    arg from system"  | importSpec |  ^ map    at: aString    ifAbsent: [       (self importArray notNil or: [ self import notNil ])        ifTrue: [           "expect the 'missing' name to be satisfied within context of imported project"          importArray            ifNotNil: [               importArray                do: [ :assoc |                   ((assoc value includes: aString) and: [ map includesKey: assoc key ])                    ifTrue: [                       importSpec := (map at: assoc key)                        mergeImportLoads: {aString};                        yourself ] ].              importSpec ifNotNil: [ ^ importSpec ] ].          (importSpec isNil and: [ self import notNil ])            ifTrue: [               ^ (map at: self import ifAbsent: absentBlock)                mergeImportLoads: {aString};                yourself ] ].      (aString = 'default' or: [ aString = 'ALL' ])        ifTrue: [           self project groupSpec            name: aString;            includes: self packageNames;            yourself ]        ifFalse: [ absentBlock value ] ]! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNamed: aString forMap: map ifAbsent: absentBlock    "import: only allowed to be used with baseline project specs"    ^ self        packageNamed: aString        forLoad: true        forMap: map        ifAbsent: absentBlock! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNamed: aString ifAbsent: aBlock	^self packageNamed: aString forMap: self packages map ifAbsent: aBlock! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageNames    packageList == nil        ifTrue: [ ^ #() ].    ^ self packages map keys asSet! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!packageSpecsInLoadOrder  ^ self packages packageSpecsInLoadOrderFor: self! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packages    packageList == nil        ifTrue: [ packageList := self project packagesSpec ].    ^ packageList! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packages: anObject    packageList := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!packagesSpec	^self packages! !!MetacelloVersionSpec methodsFor: 'copying' stamp: '9/28/2017 08:54:38'!postCopy    super postCopy.    blessing := blessing copy.    description := description copy.    author := author copy.    timestamp := timestamp copy.    packageList := packageList copy! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!postLoadDoIt	^postLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!postLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor postLoadDoItForVersion: aSymbol! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!preLoadDoIt	^preLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!preLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor preLoadDoItForVersion: aSymbol! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!project: aString constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!project: aString copyFrom: oldSpecName with: aBlock constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString copyFrom: oldSpecName with: aBlock! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!project: aString overrides: aBlock constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString overrides: aBlock! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!project: aString with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString with: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'enumerating' stamp: '9/28/2017 08:54:38'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self packageSpecsInLoadOrder do: [:pkgSpec |		pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!projectLabel	^self project label! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!removeGroup: aString constructor: aVersionConstructor    aVersionConstructor removeGroupForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!removeProject: aString constructor: aVersionConstructor    aVersionConstructor removeProjectForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!repositories: aBlock constructor: aVersionConstructor    aVersionConstructor repositoriesForVersion: aBlock! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForVersion: anObject! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForVersion: aString username: username password: password! !!MetacelloVersionSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!resolveToLoadableSpec: aString forLoad: forLoad forMap: map packages: packageMap    | package |    package := self        packageNamed: aString        forLoad: forLoad        forMap: map        ifAbsent: [ ^ self error: 'Name not found: ' , aString ].    packageMap at: package name put: package.    ^ {package}! !!MetacelloVersionSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!resolveToLoadableSpecs: nameList  "Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"  | map |  map := Dictionary new.  self resolveToLoadableSpecs: nameList forLoad: false map: map.  ^ map values! !!MetacelloVersionSpec methodsFor: 'loading' stamp: '9/28/2017 08:54:38'!resolveToLoadableSpecs: required forLoad: forLoad map: packageMap  | reqd allReqd map newReqd spec |  reqd := required copy.  allReqd := Set new.  map := self packages map.  [ reqd isEmpty ]    whileFalse: [       newReqd := Set new.      reqd        do: [ :req |           (self            resolveToLoadableSpec: req            forLoad: forLoad            forMap: map            packages: packageMap)            do: [ :loadableSpec |               newReqd addAll: loadableSpec requires.              newReqd addAll: loadableSpec includes ] ].      allReqd addAll: reqd.      newReqd removeAllFoundIn: allReqd.      reqd := newReqd ].  packageMap keys    do: [ :pkgName |       (spec := (packageMap at: pkgName) resolveToLoadableSpec) == nil        ifTrue: [ packageMap removeKey: pkgName ]        ifFalse: [ packageMap at: pkgName put: (packageMap at: pkgName) resolveToLoadableSpec ] ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setAuthor: anObject	author := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setBlessing: anObject	blessing := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setDescription: anObject	description := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setImport: anArray  importArray := importArray    ifNil: [ anArray ]    ifNotNil: [ importArray , anArray ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!setTimestamp: anObject	timestamp := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!timestamp	timestamp == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ timestamp! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!timestamp: anObject	anObject setTimestampInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!timestamp: aBlockOrStringOrDateAndTime constructor: aVersionConstructor    aVersionConstructor timestampForVersion: aBlockOrStringOrDateAndTime! !!MetacelloVersionSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!versionClass	^MetacelloVersion! !!MetacelloVersionSpec methodsFor: 'private' stamp: '9/28/2017 08:54:38'!versionNumber    ^ self project versionNumberClass fromString: self versionString! !!MetacelloVersionSpec methodsFor: 'querying' stamp: '9/28/2017 08:54:38'!versionString	versionString == nil ifTrue: [ ^'' ].	^ versionString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!versionString: anObject	versionString := anObject! !!MetacelloVersionSpec methodsFor: 'construction' stamp: '9/28/2017 08:54:38'!versionString: anObject constructor: aVersionConstructor    aVersionConstructor versionStringForVersion: anObject! !!MetacelloCommonMCSpecLoader class methodsFor: 'utilities' stamp: '9/28/2017 08:53:29'!nameComponentsFrom: aVersionName	| ar |	ar := (aVersionName last isDigit and: [ (aVersionName indexOf: $.) > 0 ])ifFalse: [Array with: aVersionName with: '' with: 0 with: aVersionName with: self]		ifTrue: [ | vrsn str |			str := ((aVersionName copyAfterLast: $-) copyAfterLast: $.).			vrsn := str isEmpty				ifTrue: [0]				ifFalse: [str asInteger].			Array				with: (aVersionName copyUpToLast:  $-)								"base pkg name"				with: ((aVersionName copyAfterLast: $-) copyUpTo: $.)				"user"				with:  vrsn "version"				with: aVersionName				with: self ].	^ar! !!MetacelloCommonMCSpecLoader class methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!retryPackageResolution    "if true, 		errors during #retryingResolvePackageSpecReferences:gofer: are caught and 		the resolution is retried 3 times. After the thrid time, a MetacelloPackageSpecResolutionError		is thrown	if false,		an error during #retryingResolvePackageSpecReferences:gofer: will be passed,		likely resulting in a walkback ... useful for debugging."    RetryPackageResolution ifNil: [ RetryPackageResolution := true ].    ^ RetryPackageResolution! !!MetacelloCommonMCSpecLoader class methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!retryPackageResolution: aBool    RetryPackageResolution := aBool! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: '9/28/2017 08:53:29'!ancestorsFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #ancestors		at: cacheKey		doing: [ :cache | 			vi := packageSpec ancestors.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: '9/28/2017 08:53:29'!currentVersionInfoFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #currentVersionInfo		at: cacheKey		doing: [ :cache | 			vi := packageSpec currentVersionInfo.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!doLoad	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"		aBlock value! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!ensureForDevelopment  ^ true! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ensureSpecLoader	^ self! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!fetchingSpecLoader	^self! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!hasRepositoryOverrides	^self loaderPolicy hasRepositoryOverrides! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ignoreImage	^self loaderPolicy ignoreImage! !!MetacelloCommonMCSpecLoader methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:29'!initialize	self loaderPolicy! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!linearLoadPackageSpec: packageSpec gofer: gofer	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!linearLoadPackageSpecs: packageSpecs repositories: repositories		| gofer |	gofer := MetacelloGofer new.	repositories do: [:repo | gofer repository: repo ].	packageSpecs do: [:pkg | pkg loadUsing: self gofer: gofer ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!load	| repos |	repos := self repositoriesFrom: self spec repositorySpecs.	^ self loadType == #atomic		ifTrue: [self atomicLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos]		ifFalse: ["assume #linear"			self linearLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos ]! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadPackageDirective: aPackageLoadDirective gofer: aGofer  | packageSpec |  packageSpec := aPackageLoadDirective spec.  MetacelloPlatform current    do: [       | loadBlock goferLoad answers resolvedReference |      aGofer disablePackageCache.	"for good luck:)"      resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.      resolvedReference isNil        ifTrue: [           "Package version already loaded into image"          ^ self ].      loadBlock := [       "mcLoader preLoad: packageSpec."      goferLoad := MetacelloGoferLoad on: aGofer.      goferLoad addResolved: resolvedReference.      goferLoad execute.      MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec" ].      (answers := packageSpec answers) notEmpty        ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]        ifFalse: [ loadBlock value ].      resolvedReference workingCopy repositoryGroup        addRepository: aPackageLoadDirective repository.      Transcript        cr;        show:            'Loaded -> ' , resolvedReference name , ' --- '                , aPackageLoadDirective repository repositoryDescription                , ' --- ' , resolvedReference repository description ]    displaying: 'Loading ' , packageSpec file! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadPackageDirectives: pkgLoads gofer: aGofer  MetacelloPlatform current    do: [       | goferLoad loadBlock answers |      goferLoad := MetacelloGoferLoad on: aGofer.      answers := OrderedCollection new.      pkgLoads        do: [ :packageLoadDirective |           | resolvedReference |          aGofer disablePackageCache.	"for good luck:)"          (resolvedReference := self            resolvePackageSpec: packageLoadDirective spec            gofer: aGofer) ~~ nil            ifTrue: [               goferLoad addResolved: resolvedReference.              answers addAll: packageLoadDirective spec answers.              packageLoadDirective resolvedReference: resolvedReference ] ].      Transcript        cr;        show: 'Starting atomic load'.      loadBlock := [       "pkgLoads do: [:packageLoadDirective |  mcLoader preLoad: packageLoadDirective spec ]."      goferLoad execute.      pkgLoads        do: [ :packageLoadDirective |           packageLoadDirective resolvedReference == nil            ifTrue: [               Transcript                cr;                tab;                show: 'Already Loaded -> ' , packageLoadDirective file ]            ifFalse: [               Transcript                cr;                tab;                show:                    'Loaded -> ' , packageLoadDirective file , ' --- '                        , packageLoadDirective repository repositoryDescription                        , ' --- '                        ,                          packageLoadDirective resolvedReference repository description.              packageLoadDirective resolvedReference workingCopy repositoryGroup                addRepository: packageLoadDirective repository ] ].      MetacelloPlatform current clearCurrentVersionCache	"pkgLoads do: [:packageLoadDirective | 					packageLoadDirective resolvedReference ~~ nil						ifTrue: [mcLoader postLoad: packageLoadDirective spec ]]" ].      answers notEmpty        ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]        ifFalse: [ loadBlock value ].      Transcript        cr;        show: 'Finished atomic load' ]    displaying: 'Atomic Load...'! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loaderPolicy	loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].	^loaderPolicy! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadingSpecLoader	^self! !!MetacelloCommonMCSpecLoader methodsFor: 'packages' stamp: '9/28/2017 08:53:29'!nameComponentsFrom: aVersionName	^self class nameComponentsFrom: aVersionName! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!operator	operator == nil ifTrue: [ ^#= ].	^operator! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!operator: aSymbol	operator := aSymbol! !!MetacelloCommonMCSpecLoader methodsFor: 'doits' stamp: '9/28/2017 08:53:29'!postLoad: packageOrVersionSpec	"subclassResponsibility, but it gets called during an upgrade, so leave it as NOOP"! !!MetacelloCommonMCSpecLoader methodsFor: 'doits' stamp: '9/28/2017 08:53:29'!preLoad: packageOrVersionSpec	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!recordingSpecLoader	^(MetacelloNullRecordingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: '9/28/2017 08:53:29'!repositoriesFrom: aMetacelloMVRepositorySpecs	^self repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: false! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: 'ct 11/7/2020 14:49'!repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: ignoreOverrides	| repositories repos |	(ignoreOverrides not and: [self hasRepositoryOverrides]) ifTrue: [ ^self loaderPolicy overrideRepositories ].	repositories := MCRepositoryGroup default repositories.	repos := OrderedCollection new.	aMetacelloMVRepositorySpecs do: [:aSpec | | description repo |		description := aSpec description.		(repo := repositories			detect: [ :rep | rep description = description ]			ifNone: [ aSpec createRepository ]) ~~ nil				ifTrue: [ repos add: (aSpec updateRepository: repo) ]].	^repos! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!repositoryMap	^self loaderPolicy repositoryMap! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolvePackageSpec: packageSpec gofer: gofer  | references resolvedReference mcVersion loadedVersionInfos |  references := self    retryingResolvePackageSpecReferences: packageSpec    gofer: gofer.  resolvedReference := references last asMetacelloCachingResolvedReference.  mcVersion := resolvedReference version.  (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil    ifTrue: [       loadedVersionInfos        do: [ :info |           info name = mcVersion info name            ifTrue: [               | spc |              "package already loaded, don't load again"              spc := packageSpec copy.              spc file: info name.              (MetacelloIgnorePackageLoaded signal: spc)                ifFalse: [ ^ nil ] ] ] ].  ^ resolvedReference! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolvePackageSpecReferences: packageSpec gofer: gofer	|  versionReference references localGofer |	localGofer := gofer.	self hasRepositoryOverrides not		ifTrue: [			packageSpec repositorySpecs notEmpty				ifTrue: [ 					localGofer := MetacelloGofer new.					(self repositoriesFrom: packageSpec repositorySpecs) do: [:repo | localGofer repository: repo ]]].	(packageSpec getFile == nil or: [ self shouldDisablePackageCache ])		ifTrue: [ 			"don't use package-cache when trying to get latest version"			localGofer disablePackageCache ].	versionReference := packageSpec goferLoaderReference.	references := versionReference resolveAllWith: localGofer.	localGofer enablePackageCache.	^references! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!retryingResolvePackageSpecReferences: packageSpec gofer: gofer    | retryCount references repositoryError |    retryCount := 0.    references := #().    [ references isEmpty and: [ retryCount < 3 ] ]        whileTrue: [             retryCount > 0                ifTrue: [                     Transcript                        cr;                        show: '...RETRY->' , packageSpec file ].            references := [ self resolvePackageSpecReferences: packageSpec gofer: gofer ]                on: Error , GoferRepositoryError                do: [ :ex |                     self class retryPackageResolution                        ifFalse: [ ex pass ].                    retryCount >= 2                        ifTrue: [                             (ex isKindOf: GoferRepositoryError)                                ifTrue: [                                     "ignore repository errors at this point, in case an alternate repository is in the list "                                    Transcript                                        cr;                                        show: 'gofer repository error: ' , ex description printString , '...ignoring'.                                    repositoryError := ex.                                    ex resume: #() ]                                ifFalse: [ ex pass ] ].                    ex return: #() ].            retryCount := retryCount + 1 ].    references isEmpty        ifTrue: [             Transcript                cr;                show: '...FAILED->' , packageSpec file.            (MetacelloPackageSpecResolutionError new                packageSpec: packageSpec;                repositories: gofer repositories;                repositoryError: repositoryError;                yourself) signal ].    ^ references! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!shouldDisablePackageCache	disablePackageCache == nil ifTrue: [ disablePackageCache := false ].	^ disablePackageCache! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!shouldDisablePackageCache: anObject	disablePackageCache := anObject! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ensureSpecLoader	^ self! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!scheduleFetchFor: packageSpec cachedReference: reference  "reference already in the cache during fetch ...schedule a load directive for reference, so ensured load will come from cache"  ^ self    scheduleFetchFor: packageSpec    reference: reference    message:      'Fetched -> (cached) ' , reference name , ' --- '        , reference repository repositoryDescription , ' --- '        , reference repository description! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!scheduleFetchFor: packageSpec nearestReference: reference  "latest version in repository already matches the cached reference...schedule a load directive for reference, so ensured load will come from cache"  ^ self    scheduleFetchFor: packageSpec    reference: reference    message:      'Fetched -> (nearest) ' , reference name , ' --- '        , reference repository repositoryDescription , ' --- '        , reference repository description! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!actionLabel	^'Fetching '! !!MetacelloFetchingMCSpecLoader methodsFor: 'versionInfo' stamp: '9/28/2017 08:53:29'!ancestorsFor: packageSpec	^self loadData		ancestorsFor: packageSpec 		ifAbsent: [ super ancestorsFor: packageSpec ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!atomicLoadPackageSpecs: packageSpecs repositories: repositories	self loaderPolicy 		pushAtomicLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!cacheRepository	^self loaderPolicy cacheRepository! !!MetacelloFetchingMCSpecLoader methodsFor: 'versionInfo' stamp: '9/28/2017 08:53:29'!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ super currentVersionInfoFor: packageSpec ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!doLoad	self loaderPolicy copy load! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ensureSpecLoader	^ (MetacelloEnsureFetchingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy; "explicitly share the loaderPolicy"		yourself! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!ensuredMap	^self loaderPolicy ensuredMap! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!explicitLoadPackageSpecs: packageSpecs repositories: repositories		| directive |	directive := self loaderPolicy 		pushExplicitLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self.	directive explicitLoadWithPolicy: self loaderPolicy.! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 07/07/2016 10:30'!linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current    do: [       | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |      cachedReference := nil.      packageSpec        searchCacheRepositoryForPackage: [           "check to see if mcz file is already in cacheRepository"          cachedReference := self            resolvePackageSpec: packageSpec            cachedGofer: self loaderPolicy cacheGofer.          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])            ifTrue: [               cachedReference name = packageSpec file                ifTrue: [                   "exact match between packageSpec file and cache"                  ^ self                    scheduleFetchFor: packageSpec                    cachedReference: cachedReference ] ] ].      references := self        retryingResolvePackageSpecReferences: packageSpec        gofer: gofer.	"look up mcz file"      nearestReference := references last asMetacelloCachingResolvedReference.      (cachedReference ~~ nil        and: [ cachedReference name = nearestReference name ])        ifTrue: [           "latest reference in repository matches cachedReference ... "          ^ self            scheduleFetchFor: packageSpec            nearestReference: nearestReference ].      (self ignoreImage not        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])        ifTrue: [           "If the mcz is already loaded into the image, no need to copy"          loadedVersionInfos            do: [ :info |               info name = nearestReference name                ifTrue: [                   | spc |                  spc := packageSpec copy.                  spc file: info name.                  (MetacelloIgnorePackageLoaded signal: spc)                    ifFalse: [ ^ self ] ] ] ].      externalReference := (references        select: [ :ref | ref name = nearestReference name ]) first        asMetacelloCachingResolvedReference.      self repositoryMap        at: externalReference name        put: externalReference repository.      (self        resolveDependencies: externalReference        nearest: nearestReference        into: (OrderedCollection with: nearestReference))        do: [ :reference |           | pSpec l |          mcVersion := reference version.          (l := (GoferVersionReference name: reference name)            resolveAllWith: self loaderPolicy cacheGofer) isEmpty            ifTrue: [               self cacheRepository storeVersion: mcVersion.              reference == nearestReference                ifTrue: [ pSpec := packageSpec ]                ifFalse: [                   pSpec := packageSpec project packageSpec.                  pSpec name: mcVersion package name ].              self loadData                addVersion: mcVersion                versionInfo: mcVersion info                resolvedReference: reference                packageSpec: pSpec ] ].      self scheduleFetchFor: packageSpec externalReference: externalReference ]    displaying: 'Fetching ' , packageSpec file! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!linearLoadPackageSpecs: packageSpecs repositories: repositories		self loaderPolicy 		pushLinearLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		 for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadData	^self loaderPolicy loadData! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadDirective	^self loaderPolicy loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadingSpecLoader	^(MetacelloLoadingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: '9/28/2017 08:53:29'!postLoad: packageOrVersionSpec	(MetacelloDirective postLoadSpec: packageOrVersionSpec loader: self)  addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: '9/28/2017 08:53:29'!preLoad: packageOrVersionSpec	(MetacelloDirective preLoadSpec: packageOrVersionSpec loader: self) addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'printing' stamp: '9/28/2017 08:53:29'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self loadDirective printOn: aStream.	aStream nextPut: $)! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolveDependencies: aResolvedReference nearest: nearestReference into: aCollection  | block retryCount coll notDone |  self flag: 'Not used, but retained to avoid upgrade issues'.  block := [ :dependency |   | reference |  reference := MetacelloCachingGoferResolvedReference    name: dependency versionInfo name    repository: aResolvedReference repository.  coll add: reference.  Transcript    cr;    show:        'Fetched dependency -> ' , reference name , ' --- '            , reference repository repositoryDescription.  self resolveDependencies: reference nearest: reference into: coll ].  retryCount := 0.  notDone := true.  coll := OrderedCollection new.  [ notDone and: [ retryCount < 3 ] ]    whileTrue: [       retryCount > 0        ifTrue: [           Transcript            cr;            show: '...RETRY' ].      [       "ensure that all resolved references have cached their version while wrapped by error handler"      aCollection do: [ :each | each version ].      nearestReference version dependencies do: block.      notDone := false ]        on: Error        do: [ :ex |           retryCount := retryCount + 1.          retryCount >= 3            ifTrue: [ ex pass ].          coll := OrderedCollection new ] ].  aCollection addAll: coll.  ^ aCollection! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolvePackageSpec: packageSpec cachedGofer: gofer	|  versionReference references |	versionReference := packageSpec goferLoaderReference.	(references := versionReference resolveAllWith: gofer) isEmpty 		ifTrue: [ ^nil ].	^references last asMetacelloCachingResolvedReference.! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!scheduleFetchFor: packageSpec cachedReference: reference	"reference already in the cache during fetch ...no need to schedule fetch"	^ self! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!scheduleFetchFor: packageSpec externalReference: reference  ^ self    scheduleFetchFor: packageSpec    reference: reference    message:      'Fetched -> ' , reference name , ' --- '        , reference repository repositoryDescription , ' --- '        , reference repository description! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!scheduleFetchFor: packageSpec nearestReference: reference	"latest version in repository already matches the cached reference...no need to schedule fetch"	^ self! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!scheduleFetchFor: packageSpec reference: reference message: message	self loaderPolicy resetCacheGofer.	self preLoad: packageSpec.	(MetacelloDirective loadPackage: packageSpec externalReference: reference loader: self) addTo: self loadDirective.	self postLoad: packageSpec.	Transcript		cr;		show: message! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!actionLabel	^'Recording '! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!afterLoads	afterLoads == nil ifTrue: [ afterLoads := OrderedCollection new ].	^afterLoads! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!beforeLoads	beforeLoads == nil ifTrue: [ beforeLoads := OrderedCollection new ].	^beforeLoads! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'versionInfo' stamp: '9/28/2017 08:53:29'!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ nil ]! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'testing' stamp: '9/28/2017 08:53:29'!ensureForDevelopment	^false! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!evalDoits	evalDoits == nil ifTrue: [ evalDoits := false ].	^evalDoits! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!evalDoits: aBool	evalDoits := aBool! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do:  [ | externalReference loadBlock answers fake |			externalReference := self resolveRecordingPackageSpecReference: packageSpec gofer: gofer.			loadBlock := [					self preLoad: packageSpec.					(MetacelloDirective 						loadPackage: packageSpec 						externalReference: externalReference 						loader: self) addTo: self loadDirective.					self postLoad: packageSpec ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value ].			fake := packageSpec copy.			fake name: fake file.			self loadData 				addVersion: fake				versionInfo: fake				resolvedReference: externalReference 				packageSpec: packageSpec ]		displaying: 'Recording ', packageSpec file! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	"Noop"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!loadPackageDirectives: pkgLoads gofer: aGofer	"Noop"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadedPackages	| packages |	packages := OrderedCollection new.	self loadDirective packageDirectivesDo: [:directive | packages add: directive file ].	^packages! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadedRepositories	| repos |	repos := OrderedCollection new.	self repositoryMap values collect: [:coll | repos addAll: coll ].	^repos! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!loadingSpecLoader	^self! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!packages	| packages |	packages := OrderedCollection new.	self loadDirective packageDirectivesDo: [:directive | packages add: directive spec ].	^packages! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'doits' stamp: 'EstebanLorenzano 9/29/2017 13:18'!postLoad: packageOrVersionSpec	self evalDoits ifFalse: [ ^self ].	packageOrVersionSpec postLoadDoItBlock ~~ nil		ifTrue: [ self afterLoads add: packageOrVersionSpec printString, ' load' ].	super postLoad: packageOrVersionSpec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'doits' stamp: 'EstebanLorenzano 9/29/2017 13:18'!preLoad: packageOrVersionSpec	self evalDoits ifFalse: [ ^self ].	packageOrVersionSpec preLoadDoItBlock ~~ nil		ifTrue: [ self beforeLoads add: packageOrVersionSpec printString, ' load' ].	super preLoad: packageOrVersionSpec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!recordingSpecLoader	^self! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolvePackageSpecReferences: packageSpec gofer: gofer	|  versionReference references localGofer |	localGofer := gofer.	self hasRepositoryOverrides not		ifTrue: [			packageSpec repositorySpecs notEmpty				ifTrue: [ 					localGofer := MetacelloGofer new.					(self repositoriesFrom: packageSpec repositorySpecs) do: [:repo | localGofer repository: repo ]]].	(packageSpec getFile == nil or: [ self shouldDisablePackageCache ])		ifTrue: [ 			"don't use package-cache when trying to get latest version"			localGofer disablePackageCache ].	versionReference := packageSpec goferLoaderReference.	references := versionReference resolveAllWith: localGofer.	localGofer enablePackageCache.	^references! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!resolveRecordingPackageSpecReference: packageSpec gofer: gofer  | externalPackageReference |  externalPackageReference := packageSpec file == nil    ifTrue: [ GoferPackageReference name: packageSpec name ]    ifFalse: [ GoferResolvedReference name: packageSpec file repository: nil ].  packageSpec repositorySpecs isEmpty    ifTrue: [       self repositoryMap        at: externalPackageReference packageName        put:          (gofer repositories            reject: [ :repo | repo = MetacelloPlatform current defaultPackageCache ]) ]    ifFalse: [       self repositoryMap        at: externalPackageReference packageName        put:          (packageSpec repositorySpecs collect: [ :repoSpec | repoSpec createRepository ]) ].  ^ externalPackageReference! !!MetacelloLoadingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!actionLabel	^'Loading '! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!copySpec: pkgSpec from: repositorySpecs to: repository	| gofer |	gofer := MetacelloGofer new.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^self copySpec: pkgSpec with: gofer to: repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!copySpec: pkgSpec with: gofer to: aRepository	| repository resolvedReference |	[resolvedReference := pkgSpec goferLoaderReference resolveWith: gofer]		on: Error		do: [:ignored | ^nil ].	repository := MCRepositoryGroup default repositories		detect: [ :each | each = aRepository ]		ifNone: [ aRepository ].	repository storeVersion: resolvedReference version.	^resolvedReference repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:53:29'!doLoad	"NOOP"! !!MetacelloLoadingMCSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:53:29'!fetchingSpecLoader	^(MetacelloFetchingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!goferCommitBranchPackage: branchName using: repositorySpecs commitMessage: commitMessage	| gofer repoSpecs wc |	repoSpecs := self spec repositorySpecs notEmpty		ifTrue: [ self spec repositorySpecs ]		ifFalse: [ repositorySpecs ].	gofer := MetacelloGofer new.	gofer disablePackageCache.	wc := self spec workingCopy.	repositorySpecs		do: [ :repoSpec | 			| repo |			repo := repoSpec createRepository.			(wc possiblyNewerVersionsIn: repo) notEmpty				ifTrue: [ 					self						notify:							'There are possibly newer versions of the package ' , self spec name printString , ' in the repository '								, repo description printString								, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].			gofer repository: repo ].	gofer package: self spec name.	[ gofer interactiveCommit ]		on: MCVersionNameAndMessageRequest		do: [ :ex | 			| ref |			ref := GoferVersionReference name: ex suggestedName.			ex				resume:					{(ref packageName , '.' , branchName , '-' , ref author , '.' , ref versionNumber printString).					commitMessage} ].	^ true! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!goferCommitPackageUsing: repositorySpecs commitMessage: commitMessage	| gofer repoSpecs wc |	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	gofer := MetacelloGofer new.	gofer disablePackageCache.	wc := self spec workingCopy.	repositorySpecs do: [:repoSpec | | repo |		repo := repoSpec createRepository.		(wc possiblyNewerVersionsIn: repo) notEmpty			ifTrue: [ self notify: 'There are possibly newer versions of the package ', self spec name printString, ' in the repository ', repo description printString, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].		gofer repository: repo ].	gofer package: self spec name.	gofer commit: commitMessage.	^true! !!MetacelloLoadingMCSpecLoader methodsFor: 'packages' stamp: '9/28/2017 08:53:29'!latestPackage: aString fromRepository: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^([(GoferPackageReference name: aString) resolveWith: gofer]		on: Error		do: [:ignored | ^ nil ]) name! !!MetacelloLoadingMCSpecLoader methodsFor: 'private' stamp: '9/28/2017 08:53:29'!linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current    do: [       | loadBlock goferLoad answers resolvedReference repo |      resolvedReference := self resolvePackageSpec: packageSpec gofer: gofer.      resolvedReference isNil        ifTrue: [           "Package version already loaded into image"          ^ self ].      loadBlock := [       self preLoad: packageSpec.      goferLoad := MetacelloGoferLoad on: MetacelloGofer new.      goferLoad addResolved: resolvedReference.      goferLoad execute.      MetacelloPlatform current clearCurrentVersionCache.      self postLoad: packageSpec ].      (answers := packageSpec answers) notEmpty        ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]        ifFalse: [ loadBlock value ].      repo := resolvedReference repository.      self hasRepositoryOverrides        ifTrue: [           repo := self loaderPolicy repositoryMap            at: resolvedReference name            ifAbsent: [ resolvedReference repository ].          resolvedReference workingCopy repositoryGroup addRepository: repo ]        ifFalse: [           resolvedReference workingCopy repositoryGroup            addRepository: resolvedReference repository ].      Transcript        cr;        show:            'Loaded -> ' , resolvedReference name , ' --- ' , repo repositoryDescription                , ' --- ' , resolvedReference repository description ]    displaying: 'Loading ' , packageSpec file! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!packagesNeedSavingUsing: repositorySpecs into: aCollection	| wc repoSpecs repo |	(wc := self spec workingCopy) == nil ifTrue: [ ^self ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^self ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	repo := (self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			([ self resolveSpec: self spec from: repoSpecs ] 				on: Error 				do: [:ignored | ^self ]) repository ].	aCollection add: self spec -> repo! !!MetacelloLoadingMCSpecLoader methodsFor: 'doits' stamp: '9/28/2017 08:53:29'!postLoad: packageOrVersionSpec	| block |	(block := packageOrVersionSpec postLoadDoItBlock) ~~ nil		ifTrue: [ block valueWithPossibleArgs: { self. packageOrVersionSpec. } ]! !!MetacelloLoadingMCSpecLoader methodsFor: 'doits' stamp: '9/28/2017 08:53:29'!preLoad: packageOrVersionSpec	| block |	(block := packageOrVersionSpec preLoadDoItBlock) ~~ nil		ifTrue: [ block valueWithPossibleArgs: { self. packageOrVersionSpec. } ]! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!repositoryFor: pkgSpec from: repositorySpecs	^([self resolveSpec: pkgSpec from: repositorySpecs]		on: Error		do: [:ignored | ^nil ]) repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!repositoryFor: pkgSpec with: gofer	^([self resolveSpec: pkgSpec with: gofer]		on: Error		do: [:ignored | ^nil ]) repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!resolveSpec: pkgSpec from: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs ignoreOverrides: true) 		do: [:repo | gofer repository: repo ].	^self resolveSpec: pkgSpec with: gofer! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!resolveSpec: pkgSpec with: gofer	^pkgSpec goferLoaderReference resolveWith: gofer! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: '9/28/2017 08:53:29'!savePackageUsing: repositorySpecs	| wc repo repoSpecs newVersion |	(wc := self spec workingCopy) == nil ifTrue: [ ^false ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^false ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	(self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ repo := (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			[ 	| newer |				repo := (self resolveSpec: self spec from: repoSpecs) repository.				newer := wc possiblyNewerVersionsIn: repo.				newer isEmpty not 					ifTrue: [						(MetacelloPlatform current confirm: 'CAUTION!! These versions in the repository may be newer:', 							String cr, newer printString, String cr,							'Do you really want to save this version?') ifFalse: [ ^false ]] ] 				on: Error 				do: [:ignored | ^false ] ].	(newVersion :=  MetacelloPlatform current newVersionForWorkingCopy: wc) == nil ifTrue: [ ^false ].	repo storeVersion: newVersion.	^true! !!MetacelloSpecLoader class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!on: aMetacelloPackagesSpec	^(self new) 		spec: aMetacelloPackagesSpec;		yourself! !!MetacelloSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!load	self subclassResponsibility! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!loadType	"#atomic or #linear"		^self project loadType! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!project	^self spec project! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!spec	^spec! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!spec: aMetacelloPackagesSpec	spec := aMetacelloPackagesSpec! !!MetacelloSpecLoader methodsFor: 'actions' stamp: '9/28/2017 08:54:38'!unload	self subclassResponsibility! !!MetacelloToolBox class methodsFor: 'private' stamp: '9/28/2017 08:53:18'!appendDescription: aString to: versionSpec	aString isEmpty		ifTrue: [ ^ self ].	^ versionSpec description value isEmpty		ifTrue: [ versionSpec description: aString ]		ifFalse: [ 			| strm |			strm := WriteStream on: String new.			strm				nextPutAll: versionSpec description value;				cr;				nextPutAll: aString.			versionSpec description: strm contents ]! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!baseNameOf: configurationClassName  "Return the baseName for the given configuration class name."  <apiDocumentation>  ^ (configurationClassName beginsWith: 'ConfigurationOf')    ifTrue: [       configurationClassName        copyFrom: 'ConfigurationOf' size + 1        to: configurationClassName size ]    ifFalse: [ configurationClassName ]! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!baseNameOfConfiguration: aConfigurationClass	"Return the baseName for the given configuration class."	<apiDocumentation>	^self baseNameOf: aConfigurationClass name asString! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!baselineNameFrom: baseName  "Return the fully-qualified baseline class name."  <apiDocumentation>  ^ MetacelloScriptEngine baselineNameFrom: baseName! !!MetacelloToolBox class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:18'!baselineNamed: baseName  ^ self new    baselineNamed: baseName;    yourself! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!checkForCriticalValidationIssues: configurationBasename	"Validate the named configuration and filter out all non-critical issues."	<apiDocumentation>	^ (MetacelloMCVersionValidator		validateConfiguration: (Smalltalk at: (self configurationNameFrom: configurationBasename) asSymbol))		select: [ :issue | issue isCritical ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!compareVersion: fromVersionString for: configurationBasename to: toVersionString	"Return a MetacelloMCVersionDiffReport that whose fields 		#additions		#removals		#modifications	   refer to a dictionary whose keys are package names and whose 	   values are a 2 element array. The first element is the mcz file 	   name for the first version and the second element is the mcz file 	   name for second version.	There are also fields for the name of the configuration (#configuration), 	the #from version string and the #to version string.		The printString of the version report should provide all of the necessary info for 	a developer."	<apiDocumentation>	| toolbox report |	toolbox := self configurationNamed: configurationBasename.	report := (toolbox project version: fromVersionString) difference: (toolbox project version: toVersionString).	report 		from: fromVersionString;		to: toVersionString;		configuration: configurationBasename.	^ report! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!compareVersionsIn: aConfigurationClass	"Compare the current #stable version to current #development version"	<apiDocumentation>	| developmentVersion previousVersion |	developmentVersion := aConfigurationClass project version: #development.	previousVersion := aConfigurationClass project version: #stable.	^self		compareVersion: previousVersion versionString		for: aConfigurationClass name asString		to: developmentVersion versionString	! !!MetacelloToolBox class methodsFor: 'tool support' stamp: '9/28/2017 08:53:18'!compiledMethodForVersion: aMetacelloVersion	| toolbox pragma |	toolbox := MetacelloToolBox new project: aMetacelloVersion project.	pragma := (toolbox constructor extractAllVersionPragmas at: aMetacelloVersion versionString ifAbsent: [ ^ nil ]) first.	^pragma method! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!configurationClasses    "Return a set of the Metacello configuration classes that have been loaded into the image."    <apiDocumentation>    ^ MetacelloProjectRegistration configurationClasses! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!configurationNameFrom: baseName    "Return the fully-qualified configuration class name."    <apiDocumentation>    ^ MetacelloScriptEngine configurationNameFrom: baseName! !!MetacelloToolBox class methodsFor: 'instance creation' stamp: '9/28/2017 08:53:18'!configurationNamed: baseName	^self new 		configurationNamed: baseName;		yourself! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!copyConfiguration: aConfigurationClass to: metacelloRepositoryString	"Copy the current configuration mcz file to the given repository (i.e., http: //... or directory://, etc.)"	<apiDocumentation>	| project |	project := aConfigurationClass project.	project projectPackage		copySpecTo:			((project repositorySpec)				description: metacelloRepositoryString;				yourself)! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createBaseline: baselineVersionString for: configurationBasename from: existingBaselineVersionString description: aString	"Create a new baseline version based on the specification in an existing baseline"	<apiDocumentation>	^ self		createBaseline: baselineVersionString		for: configurationBasename		from: existingBaselineVersionString		description: aString		versionSpecsDo: [ :attribute :versionSpec | true ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createBaseline: baselineVersionString for: configurationBasename from: existingBaselineVersionString description: aString versionSpecsDo: versionSpecBlock	"Create a new baseline version based on the specification in an existing baseline. Evaluate <versionSpecBlock> for each section."	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'baseline' , (self stripVersionStringForSelector: baselineVersionString) , ':'			inCategory: 'baselines'			forVersion: baselineVersionString;		addSectionsFrom: existingBaselineVersionString			forBaseline: true			updateProjects: false			updatePackages: false			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						aString notEmpty							ifTrue: [ versionSpec description: aString ] ].				versionSpecBlock value: attribute value: versionSpec ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'deprecated' stamp: 'dkh 3/7/2012 17:08:50'!createBaseline: baselineVersionString for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies groups: groups    "Create a new baseline version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"    <apiDocumentation>    self        deprecated:            'Use createBaseline:for: repository:requiredProjects:packages:repositories:dependencies:groups: instead'.    ^ self        createBaseline: baselineVersionString        for: configurationBasename        repository: repositoryDescription        requiredProjects: projectList        packages: packageList        repositories: #()        dependencies: dependencies        groups: groups! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createBaseline: baselineVersionString for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups	"Create a new baseline version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'baseline' , (self stripVersionStringForSelector: baselineVersionString) , ':'			inCategory: 'baselines'			forVersion: baselineVersionString;		addSection: #common			repository: repositoryDescription			requiredProjects: projectList			packages: packageList			dependencies: dependencies			includes: includes			files: files			repositories: repositories			preLoadDoIts: preLoadDoIts			postLoadDoIts: postLoadDoIts			supplyingAnswers: supplyingAnswers			groups: groups			versionSpecsDo: [ :versionSpec | versionSpec blessing: #baseline ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createBaseline: baselineVersionString for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependencies groups: groups    "Create a new baseline version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"    <apiDocumentation>    | toolbox |    (toolbox := self configurationNamed: configurationBasename)        createVersionMethod: 'baseline' , (self stripVersionStringForSelector: baselineVersionString) , ':'            inCategory: 'baselines'            forVersion: baselineVersionString;        addSection: #'common'            repository: repositoryDescription            requiredProjects: projectList            packages: packageList            repositories: repositories            dependencies: dependencies            groups: groups            versionSpecsDo: [ :versionSpec | versionSpec blessing: #'baseline' ];        commitMethod.    ^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createBaselineOf: baselineBasename requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependencies groups: groups  "Create a new baseline in a BaselinOf based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"  <apiDocumentation>  | toolbox |  (toolbox := self baselineNamed: baselineBasename)    createBaselineOfMethod: 'baseline:' inCategory: 'baseline';    addBaselineOfSection: #'common'      requiredProjects: projectList      packages: packageList      repositories: repositories      dependencies: dependencies      groups: groups      versionSpecsDo: [ :versionSpec |  ];    commitBaselineOfMethod.  ^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createBranch: branchName for: configurationBasename description: commitMessage	"Create a new branch for the project and save the configuration to it's repository."		<apiDocumentation>	| toolbox criticalIssues |	branchName isEmpty ifTrue: [ ^self saveConfigurationPackageFor: configurationBasename description: commitMessage ].	(criticalIssues := self checkForCriticalValidationIssues: configurationBasename) isEmpty		ifTrue: [ 			toolbox := self configurationNamed: configurationBasename.			toolbox project goferBranch: branchName project: commitMessage.			^toolbox ].	 self error: 'There are critical issues in configuration ' , configurationBasename printString, '. Configuration not saved'.	^nil! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createDevelopment: developmentVersionString for: configurationBasename from: existingDevelopmentVersionString description: aString	"Create a new development version based on the specifications in an existing development version. Modify the #development symbolic version to reference the new version."	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'version' , (self stripVersionStringForSelector: developmentVersionString) , ':'			inCategory: 'versions'			forVersion: developmentVersionString;		addSectionsFrom: existingDevelopmentVersionString			forBaseline: false			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							description: aString;							blessing: #development;							timestamp: MetacelloPlatform current timestamp ].				true ];		commitMethod.	toolbox		symbolicVersionMethod: #development;		addSymbolicSection: #common version: developmentVersionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createDevelopment: developmentVersionString for: configurationBasename from: existingDevelopmentVersionString imports: imports description: aString	"Create a new development version based on the specifications in an existing version, but override the imports for the new version. Modify the #development symbolic version to reference the new version."	<apiDocumentation>	| toolbox |	toolbox := self		createVersion: developmentVersionString		for: configurationBasename		from: existingDevelopmentVersionString		description: aString.	toolbox		modifyVersionMethodForVersion: developmentVersionString;		imports: imports;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createDevelopment: developmentVersionString for: configurationBasename importFromBaseline: baselineVersionString description: aString	"Create a new development version based on the specifications in an existing baseline version. Modify the #development symbolic version to reference the new version."	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'version' , (self stripVersionStringForSelector: developmentVersionString) , ':'			inCategory: 'versions'			forVersion: developmentVersionString;		importFrom: baselineVersionString			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							blessing: #development;							description: aString;							timestamp: MetacelloPlatform current timestamp ].				true ];		commitMethod.	toolbox		symbolicVersionMethod: #development;		addSymbolicSection: #common version: developmentVersionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!createNewBaselineVersionIn: aConfigurationClass description: creationMessage	"Create a new baseline version based upon #stable version's baseline.	 A new baseline should be created if new packages or projects have been added or package dependencies have changed."	<apiDocumentation>	| currentVersion existingBaselineVersionString baselineVersionNumber |	currentVersion := aConfigurationClass project version: #stable.	existingBaselineVersionString := currentVersion importedVersions first.	baselineVersionNumber := existingBaselineVersionString asMetacelloVersionNumber incrementMinorVersionNumber.	self		createBaseline: baselineVersionNumber versionString		for: aConfigurationClass name asString		from: existingBaselineVersionString		description: creationMessage! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!createNewBaselineVersionIn: aConfigurationClass description: creationMessage versionSpecsDo: versionSpecBlock	"Create a new baseline version based upon #stable version's baseline. Evaluate <versionSpecBlock> for each section.	 A new baseline should be created if new packages or projects have been added or package dependencies have changed."	<apiDocumentation>	| currentVersion existingBaselineVersionString baselineVersionNumber |	currentVersion := aConfigurationClass project version: #stable.	existingBaselineVersionString := currentVersion importedVersions first.	baselineVersionNumber := existingBaselineVersionString asMetacelloVersionNumber incrementMinorVersionNumber.	self		createBaseline: baselineVersionNumber versionString		for: aConfigurationClass name asString		from: existingBaselineVersionString		description: creationMessage		versionSpecsDo: versionSpecBlock! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!createNewBaselineVersionIn: aConfigurationClass requiredProjects: projectList packages: packageList dependencies: dependencies  groups: groups	"Create a new baseline version based upon #stable version's baseline, modify the baseline based on the provided structural additions:		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| currentVersion existingBaselineVersionString baselineVersionNumber |	currentVersion := aConfigurationClass project version: #development.	existingBaselineVersionString := currentVersion importedVersions first.	baselineVersionNumber := existingBaselineVersionString asMetacelloVersionNumber incrementMinorVersionNumber.	self		createBaseline: baselineVersionNumber versionString		for: aConfigurationClass name asString		from: existingBaselineVersionString		description: ''.	self		modifyVersion: baselineVersionNumber versionString		section: #common		for: aConfigurationClass name asString		repository: nil		requiredProjects: projectList		packages: packageList		dependencies: dependencies		includes: #()		files: #()		repositories: #()		preLoadDoIts: #()		postLoadDoIts: #()		supplyingAnswers: #()		groups: groups! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!createNewDevelopmentVersionIn: aConfigurationClass description: creationMessage	"Create a new development version using the #stable version as model."	<apiDocumentation>	| currentVersion developmentVersion |	currentVersion := aConfigurationClass project version: #stable.	developmentVersion := currentVersion versionNumber copy incrementMinorVersionNumber.	self		createDevelopment: developmentVersion versionString		for: aConfigurationClass name asString		from: currentVersion versionString		imports: currentVersion importedVersions		description: creationMessage! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!createVersion: targetVersionString for: configurationBasename from: sourceVersionString description: aString	"Create a new version based on the specifications in the given version. 	 If the new version string contains 'baseline', then create a new baseline version.	 If the given version is a baseline, then create a new version based on the given baseline.	 If the given version is a non-baseline version, then create a new version based on the given version."	<apiDocumentation>	| toolbox sourceVersion |	toolbox := self configurationNamed: configurationBasename.	sourceVersion := toolbox project version: sourceVersionString.	^ (targetVersionString indexOfSubCollection: 'baseline') > 0		ifTrue: [ 			"create baseline version from baseline version"			sourceVersion blessing ~~ #baseline				ifTrue: [ 					self						error:							'Cannot create a baseline version ' , sourceVersionString printString , ' from a non-baseline version '								, targetVersionString printString ].			self				createBaseline: targetVersionString				for: configurationBasename				from: sourceVersionString				description: aString ]		ifFalse: [ 			sourceVersion blessing == #baseline				ifTrue: [ 					"create development version version from baseline version"					self						createDevelopment: targetVersionString						for: configurationBasename						importFromBaseline: sourceVersion versionString						description: aString ]				ifFalse: [ 					"create development version version from development version"					self						createDevelopment: targetVersionString						for: configurationBasename						from: sourceVersion versionString						description: aString ] ]! !!MetacelloToolBox class methodsFor: 'help' stamp: '9/28/2017 08:53:18'!defaultTopic: pageSelector for: aConfigurationClass	| stream helpTopicClass |	(helpTopicClass := self helpTopicClass) ifNil: [^self error: 'Help system not installed'].	stream := WriteStream on: String new.	pageSelector == #helpInstallation		ifTrue: [ 			stream				nextPutAll: 'To install this configuration, execute the following expression in a workspace:'; cr; tab.			(aConfigurationClass project hasVersion: #stable)				ifTrue: [ stream nextPutAll: '(', aConfigurationClass name asString, ' project version: #stable) load.' ]				ifFalse: [ 					(aConfigurationClass respondsTo: #load)						ifTrue: [ stream nextPutAll: aConfigurationClass name asString , ' load.' ]						ifFalse: [ stream nextPutAll: aConfigurationClass name asString, ' project latestVersion load.' ]].			^ helpTopicClass perform: #title:contents: withArguments: { 'Installing'.  stream contents} ].	pageSelector == #helpIntro		ifTrue: [ 			stream				nextPutAll: 'I am a Metacello configuration for the ', (MetacelloToolBox baseNameOfConfiguration: aConfigurationClass), ' project.'.			^ helpTopicClass perform: #title:contents: withArguments: { 'Intro' . stream contents} ].	pageSelector == #helpGettingStarted		ifTrue: [ 			stream				nextPutAll: 'I guess you''re on your own:).'.			^ helpTopicClass perform: #title:contents: withArguments: { 'Getting Started' .stream contents} ].! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!descriptionForValidationReasonCode: reasonCode	"Description of validation reasonCode"	<apiDocumentation>	^MetacelloMCVersionValidator descriptionForReasonCode: reasonCode! !!MetacelloToolBox class methodsFor: 'help' stamp: '9/28/2017 08:53:18'!helpTopicClass	^Smalltalk at: #HelpTopic ifAbsent: []! !!MetacelloToolBox class methodsFor: 'help' stamp: '9/28/2017 08:53:18'!helpTopicFor: aConfigurationClass	| topic pages page helpTopicClass |	(helpTopicClass := self helpTopicClass) ifNil: [^self error: 'Help system not installed'].	topic := helpTopicClass named: (self baseNameOfConfiguration: aConfigurationClass).	pages := (aConfigurationClass respondsTo: #helpPages)		ifTrue: [ aConfigurationClass perform: #helpPages ]		ifFalse: [ #(#helpIntro #helpInstallation #helpGettingStarted) ].	pages		do: [ :pageSelectorOrClass | 			page := (Smalltalk hasClassNamed: pageSelectorOrClass asString)				ifTrue: [ (Smalltalk classNamed: pageSelectorOrClass asString) perform: #asHelpTopic ]				ifFalse: [ 					[ aConfigurationClass perform: pageSelectorOrClass ]						on: MessageNotUnderstood						do: [ :ex | self defaultTopic: pageSelectorOrClass for: aConfigurationClass ] ].			topic perform: #addSubtopic: with: page ].	^ topic! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!modifyBaselineVersionIn: aConfigurationClass repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups	"Modify #development version's baseline version based on the given structure		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| currentVersion existingBaselineVersionString |	currentVersion := aConfigurationClass project version: #development.	existingBaselineVersionString := currentVersion importedVersions first.	self		modifyVersion: existingBaselineVersionString		section: #common		for: aConfigurationClass name asString		repository: repositoryDescription		requiredProjects: projectList		packages: packageList		dependencies: dependencies		includes: includes		files: files		repositories: repositories		preLoadDoIts: preLoadDoIts		postLoadDoIts: postLoadDoIts		supplyingAnswers: supplyingAnswers		groups: groups! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!modifyDevelopmentVersionIn: aConfigurationClass imports: imports requiredProjects: projectList packages: packageList description: message	"Modify #development version's baseline version based on the given structure		imports - imports array		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names	"	<apiDocumentation>	| developmentVersion files |	developmentVersion := aConfigurationClass project version: #development.	files := OrderedCollection new.	packageList do: [:packageName | files add: packageName -> packageName ].	self		modifyVersion: developmentVersion versionString		section: #common		for: aConfigurationClass name asString		repository: nil		requiredProjects: projectList		packages: packageList		dependencies: #()		includes: #()		files: files		repositories: #()		preLoadDoIts: #()		postLoadDoIts: #()		supplyingAnswers: #()		groups: #().	(self configurationNamed: aConfigurationClass name asString)		modifyVersionMethodForVersion: developmentVersion versionString;		imports: imports;		commitMethod.	self		updateDevelopment: developmentVersion versionString		for: aConfigurationClass name asString		updateProjects: false 		description: message! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!modifySymbolicVersion: symbolicVersionSymbol for: configurationBasename attribute: attribute to: versionString	"Set the value of the symbolic version for the given attribute to the given version string"	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		modifySymbolicVersionMethodFor: symbolicVersionSymbol;		addSymbolicSection: attribute version: versionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!modifyVersion: sourceVersionString for: configurationBasename projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	"Modify the project, package and/or group specifications for the given version"	<apiDocumentation>	self		modifyVersion: sourceVersionString		for: configurationBasename		versionSpecsDo: [ :attribute :versionSpec | 			versionSpec				specListProjectDo: [ :spec | projectBlock value: attribute value: versionSpec value: spec ]				packageDo: [ :spec | packageBlock value: attribute value: versionSpec value: spec ]				groupDo: [ :spec | groupBlock value: attribute value: versionSpec value: spec ].			true ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!modifyVersion: sourceVersionString for: configurationBasename versionSpecsDo: aBlock	"Modify the version specifications for the given version"	<apiDocumentation>	(self configurationNamed: configurationBasename)		modifyVersionMethodForVersion: sourceVersionString versionSpecsDo: aBlock;		commitMethod! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!modifyVersion: sourceVersionString section: sectionAttributeOrPath for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups	"Modify a new version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		modifyVersionMethodForVersion: sourceVersionString versionSpecsDo: [:attribute :versionSpec | true ];		modifySection: sectionAttributeOrPath asMetacelloAttributePath			repository: repositoryDescription			requiredProjects: projectList			packages: packageList			dependencies: dependencies			includes: includes			files: files			repositories: repositories			preLoadDoIts: preLoadDoIts			postLoadDoIts: postLoadDoIts			supplyingAnswers: supplyingAnswers			groups: groups			versionSpecsDo: [ :versionSpec | true ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'utility' stamp: '9/28/2017 08:53:18'!platformAttributes	"Answer the list of platform attributes for the current platform"	<apiDocumentation>	^MetacelloPlatform current defaultPlatformAttributes! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!releaseDevelopmentVersionIn: aConfigurationClass description: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	<apiDocumentation>	| version |	version := aConfigurationClass project version: #development.	self		releaseVersion: version versionString for: aConfigurationClass name asString;		saveConfigurationPackageFor: aConfigurationClass name asString description: commitMessage! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!releaseEarlyAccessVersion: earlyAccessVersionString for: configurationBasename from: developmentVersionString	"Update the #development and #earlyAccess symbolic versions."	<apiDocumentation>	| toolbox message previousEarlyAccessVersion previousEarlyAccessSeparator index earlyAccessDescription |	self flag: 'Make this more general purpose'.	toolbox := self configurationNamed: configurationBasename.	message := (toolbox project version: developmentVersionString) description.	previousEarlyAccessVersion := (MetacelloVersionNumber fromString: earlyAccessVersionString) decrementMinorVersionNumber		asString.	previousEarlyAccessSeparator := '---' , previousEarlyAccessVersion , '---'.	(index := message indexOfSubCollection: previousEarlyAccessSeparator) > 0		ifTrue: [ 			index + previousEarlyAccessSeparator size + 1 <= message size				ifTrue: [ earlyAccessDescription := message copyFrom: index + previousEarlyAccessSeparator size + 1 to: message size ] ].	toolbox		createVersionMethod: 'version' , (self stripVersionStringForSelector: earlyAccessVersionString) , ':'			inCategory: 'versions'			forVersion: earlyAccessVersionString;		addSectionsFrom: developmentVersionString			forBaseline: false			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							description: earlyAccessDescription;							blessing: #development;							timestamp: MetacelloPlatform current timestamp ].				true ];		commitMethod.	toolbox		symbolicVersionMethod: #earlyAccess;		addSymbolicSection: #common version: earlyAccessVersionString;		commitMethod.	toolbox		modifyVersionMethodForVersion: developmentVersionString			versionSpecsDo: [ :attribute :versionSpec | 					attribute == #common						ifTrue: [ 							"update the author, description and timeStamp"							versionSpec								author: MetacelloPlatform current authorName;								timestamp: MetacelloPlatform current timestamp.							self appendDescription: '---' , earlyAccessVersionString , '---' to: versionSpec ].					true ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!releaseVersion: developmentVersionString for: configurationBasename	"Set the #common blessing to #release and set the #common #stable symbolic version to the given version."	<apiDocumentation>	^ self		releaseVersion: developmentVersionString		for: configurationBasename		blessingAttribute: #common		platformAttribute: #common! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!releaseVersion: developmentVersionString for: configurationBasename blessingAttribute: attribute platformAttribute: platformAttribute	<apiDocumentation>	"Set the blessing to #release and set the #stable symbolic version to the given version, using the given attributes for each."		| toolbox |	(toolbox := self configurationNamed: configurationBasename)		modifyVersionMethodForVersion: developmentVersionString			versionSpecsDo: [ :attr :versionSpec | 					attr == attribute						ifTrue: [ versionSpec blessing: #release ].					true ];		commitMethod;		symbolicVersionMethod: #development;		addSymbolicSection: platformAttribute version: #notDefined;		commitMethod;		symbolicVersionMethod: #stable;		addSymbolicSection: platformAttribute version: developmentVersionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!saveConfigurationPackageFor: configurationBasename description: commitMessage	"Save mcz file that contains the configuration to it's repository."		<apiDocumentation>	| toolbox criticalIssues |	(criticalIssues := self checkForCriticalValidationIssues: configurationBasename) isEmpty		ifTrue: [ 			toolbox := self configurationNamed: configurationBasename.			toolbox project goferCommitProject: commitMessage.			^toolbox ].	 self error: 'There are critical issues in configuration ' , configurationBasename printString, '. Configuration not saved'.	^nil! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!saveModifiedDevelopmentPackages: developmentVersionString for: configurationBasename description: commitMessage  "Save modified mcz files associated with the project. Then update given version to reflect the new mcz file versions."  <apiDocumentation>  | toolbox modifiedPackages cacheRepository |  modifiedPackages := Dictionary new.  (toolbox := self configurationNamed: configurationBasename)    modifiedPackageSpecs: developmentVersionString    packageSpecsDo: [ :versionSpec :packageSpec :monticelloWorkingCopy |       | repositories repositoryGroup wcRepositoryGroup |      wcRepositoryGroup := monticelloWorkingCopy repositoryGroup.      repositoryGroup := MCRepositoryGroup new.      repositories := packageSpec repositories        collect: [ :each | each createRepository ].      repositories isEmpty        ifTrue: [           repositories := versionSpec repositories            collect: [ :repoSpec | repoSpec createRepository ].          wcRepositoryGroup repositories notEmpty            ifTrue: [               repositories := repositories                select: [ :repo | wcRepositoryGroup includes: repo ] ].          repositories isEmpty            ifTrue: [               repositories := monticelloWorkingCopy repositoryGroup repositories                reject: [ :repo | repo = MetacelloPlatform current defaultPackageCache ] ] ].      repositories        do: [ :repo |           (monticelloWorkingCopy possiblyNewerVersionsIn: repo) notEmpty            ifTrue: [               self                notify:                  'There are possibly newer versions of the package '                    , packageSpec name printString , ' in the repository '                    , repo description printString                    ,                      '. Cancel and manually merge if you want to pick up the changes from the later version.' ].          repositoryGroup addRepository: repo ].      modifiedPackages at: packageSpec name put: repositoryGroup ].  cacheRepository := MetacelloPlatform current defaultPackageCache.  modifiedPackages isEmpty    ifTrue: [ self notify: 'Empty modified packages list'	"actually here for debugging purposes" ].  modifiedPackages    keysAndValuesDo: [ :packageName :repositoryGroup |       | gofer repositoryList packageSpec |      gofer := Gofer new.      gofer disablePackageCache.      (repositoryGroup repositories reject: [ :repo | repo = cacheRepository ])        do: [ :repository | gofer repository: repository ].      gofer package: packageName.      gofer commit: commitMessage ].  ^ modifiedPackages! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!saveModifiedPackagesAndConfigurationIn: aConfigurationClass description: commitMessage	"Save modified mcz files, update and then save the configuration."	<apiDocumentation>	| version |	version := aConfigurationClass project version: #development.	self		saveModifiedDevelopmentPackages: version versionString		for: aConfigurationClass name asString		description: commitMessage.	(self		updateDevelopment: version versionString		for: aConfigurationClass name asString		updateProjects: false		description: commitMessage) isEmpty		ifTrue: [ self updateDescription: version versionString for: aConfigurationClass name asString description: commitMessage ].	self saveConfigurationPackageFor: aConfigurationClass name asString description: commitMessage! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!saveModifiedPackagesIn: aConfigurationClass description: commitMessage	"Save modified mcz files and update the configuration."	| version |	version := aConfigurationClass project version: #development.	self		saveModifiedDevelopmentPackages: version versionString for: aConfigurationClass name asString description: commitMessage;		updateDevelopment: version versionString			for: aConfigurationClass name asString			updateProjects: false			description: commitMessage! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!stableVersion: stableVersionString for: configurationBasename platformAttribute: platformAttribute	<apiDocumentation>	"Set the #stable symbolic version to the given version, using the given platformAttribute."		(MetacelloToolBox configurationNamed: configurationBasename)		symbolicVersionMethod: #stable;		addSymbolicSection: platformAttribute version: stableVersionString;		commitMethod.! !!MetacelloToolBox class methodsFor: 'private' stamp: '9/28/2017 08:53:18'!stripVersionStringForSelector: versionString	^((versionString copyWithout: $.) copyWithout: $-) 		copyReplaceAll: 'baseline' with: '' ! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!updateDescription: developmentVersionString for: configurationBasename description: message	"Update description"	<apiDocumentation>	^ (self configurationNamed: configurationBasename)		updateVersionMethodForVersion: developmentVersionString			updateProjects: false			updatePackages: false			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp.						self appendDescription: message to: versionSpec ].				true ];		commitMethod! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!updateDevelopment: developmentVersionString for: configurationBasename updatePackages: updatePackages description: message	"Update project specs and (conditionally) the package specs in the given version to reflect the new mcz file and project versions."	<apiDocumentation>	| toolbox updatedSpecs |	toolbox := self configurationNamed: configurationBasename.	updatedSpecs := toolbox		updateVersionMethodForVersion: developmentVersionString		updateProjects: true		updatePackages: updatePackages		versionSpecsDo: [ :attribute :versionSpec | 			attribute == #common				ifTrue: [ 					"update the author, description and timeStamp"					versionSpec						author: MetacelloPlatform current authorName;						timestamp: MetacelloPlatform current timestamp.					self appendDescription: message to: versionSpec ].			true ].	updatedSpecs notEmpty		ifTrue: [ toolbox commitMethod ].	^ updatedSpecs! !!MetacelloToolBox class methodsFor: 'scripts' stamp: '9/28/2017 08:53:18'!updateDevelopment: developmentVersionString for: configurationBasename updateProjects: updateProjects description: message	"Update packageSpecs and (conditionally) the project specs in the given version to reflect the new mcz file and project versions."	<apiDocumentation>	| toolbox updatedSpecs |	toolbox := self configurationNamed: configurationBasename.	updatedSpecs := toolbox		updateVersionMethodForVersion: developmentVersionString		updateProjects: updateProjects		updatePackages: true		versionSpecsDo: [ :attribute :versionSpec | 			attribute == #common				ifTrue: [ 					"update the author, description and timeStamp"					versionSpec						author: MetacelloPlatform current authorName;						timestamp: MetacelloPlatform current timestamp.					self appendDescription: message to: versionSpec ].			true ].	updatedSpecs notEmpty		ifTrue: [ toolbox commitMethod ].	^ updatedSpecs! !!MetacelloToolBox class methodsFor: 'development support' stamp: '9/28/2017 08:53:18'!updateToLatestPackageVersionsIn: aConfigurationClass description: descriptionString	"Update the #development version to match currently loaded mcz files."	"self updateToLatestPackageVersions: '- fixed a bug'"	<apiDocumentation>	^self		updateDevelopment: #development		for: aConfigurationClass name asString		updateProjects: false 		description: descriptionString! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateBaseline: baselineClass  "Check the baseline for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "  <apiDocumentation>  ^ self validateBaseline: baselineClass debug: #() recurse: false! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateBaseline: baselineClass debug: debugList recurse: aBool  "Check the baseline for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "  <apiDocumentation>  ^ MetacelloMCVersionValidator    validateBaseline: baselineClass    debug: debugList    recurse: aBool! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateConfiguration: configurationClass	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ self validateConfiguration: configurationClass debug: #() recurse: false! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateConfiguration: configurationClass debug: debugList recurse: aBool	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ MetacelloMCVersionValidator validateConfiguration: configurationClass debug: debugList recurse: aBool! !!MetacelloToolBox class methodsFor: 'load validation' stamp: '9/28/2017 08:53:18'!validatePlatformLoad: platformAttribute for: configurationBasename	"Validate, Load, and run tests for all versions of the given configuration. Return list of issues."	<apiDocumentation>	| issues configurationClass toolbox cleanDevelopmentLoads cleanLoadAndTests stableVersion |	configurationClass := Smalltalk at: (self configurationNameFrom: configurationBasename) asSymbol.	cleanDevelopmentLoads := OrderedCollection new.	cleanLoadAndTests := OrderedCollection new.	issues := [ MetacelloMCVersionValidator validateConfigurationLoad: configurationClass ]		on: MetacelloCleanNotification		do: [ :ex | 			(ex isKindOf: MetacelloCleanLoadAndTestsNotification)				ifTrue: [ cleanLoadAndTests add: ex version ].			((ex isKindOf: MetacelloCleanLoadNotification) and: [ ex version blessing == #development ])				ifTrue: [ cleanDevelopmentLoads add: ex version ].			ex resume ].	(cleanDevelopmentLoads isEmpty and: [ cleanLoadAndTests isEmpty ])		ifTrue: [ 			self inform: 'Failed validation with no versions load clean'.			^ issues ].	toolbox := self configurationNamed: configurationBasename.	cleanLoadAndTests notEmpty		ifTrue: [ 			toolbox				symbolicVersionMethod: #stable;				addSymbolicSection: platformAttribute version: (stableVersion := cleanLoadAndTests last) versionString;				commitMethod ].	stableVersion notNil		ifTrue: [ 			stableVersion blessing == #development				ifTrue: [ 					issues						add:							(MetacelloValidationWarning								configurationClass: configurationClass								reasonCode: #stableDevelopmentVersion								callSite: #validatePlatformLoad:for:								explanation:									'Development version ' , stableVersion versionString printString , ' is marked as #stableVersion for '										, configurationClass name asString) ].			cleanDevelopmentLoads := cleanDevelopmentLoads select: [ :version | version > stableVersion ] ].	cleanDevelopmentLoads notEmpty		ifTrue: [ 			toolbox				symbolicVersionMethod: #development;				addSymbolicSection: platformAttribute version: cleanDevelopmentLoads last versionString;				commitMethod ]		ifFalse: [ 			toolbox				symbolicVersionMethod: #development;				addSymbolicSection: platformAttribute version: #notDefined;				commitMethod ].	^ issues! !!MetacelloToolBox class methodsFor: 'load validation' stamp: '9/28/2017 08:53:18'!validatePlatformLoad: platformAttribute for: configurationBasename version: versionString	"Load, and run tests for the given version of the configuration. Mark as #stable, if load and tests are clean. Return list of issues."	<apiDocumentation>	| issues configurationClass toolbox cleanLoadAndTests stableVersion |	configurationClass := Smalltalk at: (self configurationNameFrom: configurationBasename) asSymbol.	cleanLoadAndTests := OrderedCollection new.	issues := [ MetacelloMCVersionValidator validateConfigurationLoad: configurationClass version: versionString ]		on: MetacelloCleanNotification		do: [ :ex | 			(ex isKindOf: MetacelloCleanLoadAndTestsNotification)				ifTrue: [ cleanLoadAndTests add: ex version ].			ex resume ].	toolbox := self configurationNamed: configurationBasename.	cleanLoadAndTests isEmpty		ifTrue: [ ^issues ].	stableVersion := cleanLoadAndTests last.	toolbox		symbolicVersionMethod: #stable;		addSymbolicSection: platformAttribute version: stableVersion versionString;		commitMethod.	stableVersion blessing == #development		ifTrue: [ 			issues				add:					(MetacelloValidationWarning						configurationClass: configurationClass						reasonCode: #stableDevelopmentVersion						callSite: #validatePlatformLoad:for:version:						explanation:							'Development version ' , stableVersion versionString printString , ' is marked as #stableVersion for '								, configurationClass name asString) ].	^ issues! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateProject: aMetacelloProject version: versionString	"Check a specific version in the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ self validateProject: aMetacelloProject version: versionString debug: #() recurse: false! !!MetacelloToolBox class methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool	"Check a specific version in the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ MetacelloMCVersionValidator		validateProject: aMetacelloProject		version: versionString		debug: debugList		recurse: aBool! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!abortMethod	project := project configuration class project.	"recalculate project"	methodSpec := nil! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies groups: groups versionSpecsDo: aBlock  "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"  self    addBaselineOfSection: sectionAttributeOrPath    requiredProjects: projectList    packages: packageList    dependencies: dependecies    includes: #()    files: #()    repositories: #()    preLoadDoIts: #()    postLoadDoIts: #()    supplyingAnswers: #()    groups: groups    versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock  "		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |  versionSpec := self createVersionSpec: self methodSpec versionString.  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self    buildMapFrom: repositories    for: packageList , projectList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  projectList    do: [ :projectName |       | spec |      spec := self createProjectReferenceSpec: projectName.      repositoriesMap        at: projectName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      versionSpec packages merge: spec ].  packageList    do: [ :packageName |       | spec |      spec := self createPackageSpec: packageName.      dependencyMap        at: packageName        ifPresent: [ :dependencyList | spec requires: dependencyList ].      includesMap        at: packageName        ifPresent: [ :includesList | spec includes: includesList ].      filesMap at: packageName ifPresent: [ :file | spec file: file ].      repositoriesMap        at: packageName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      preLoadDoItsMap        at: packageName        ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].      postLoadDoItsMap        at: packageName        ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].      supplyingAnswersMap        at: packageName        ifPresent: [ :answer | spec answers: answer ].      versionSpec packages merge: spec ].  groups    do: [ :assoc |       | spec |      spec := self createGroupSpec: assoc key.      spec includes: assoc value.      versionSpec packages merge: spec ].  aBlock value: versionSpec.  self methodSpec    addMethodSection: sectionAttributeOrPath asMetacelloAttributePath    versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependecies groups: groups versionSpecsDo: aBlock  "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"  self    addBaselineOfSection: sectionAttributeOrPath    requiredProjects: projectList    packages: packageList    dependencies: dependecies    includes: #()    files: #()    repositories: repositories    preLoadDoIts: #()    postLoadDoIts: #()    supplyingAnswers: #()    groups: groups    versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies groups: groups versionSpecsDo: aBlock	"		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"	self		addSection: sectionAttributeOrPath		repository: repositoryDescription		requiredProjects: projectList		packages: packageList		dependencies: dependecies		includes: #()		files: #()		repositories: #()		preLoadDoIts: #()		postLoadDoIts: #()		supplyingAnswers: #()		groups: groups		versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |    versionSpec := self createVersionSpec: self methodSpec versionString.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    projectList        do: [ :projectName |             | spec |            spec := self createProjectReferenceSpec: projectName.            repositoriesMap                at: projectName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            versionSpec packages merge: spec ].    packageList        do: [ :packageName |             | spec |            spec := self createPackageSpec: packageName.            dependencyMap at: packageName ifPresent: [ :dependencyList | spec requires: dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec includes: includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ].            versionSpec packages merge: spec ].    groups        do: [ :assoc |             | spec |            spec := self createGroupSpec: assoc key.            spec includes: assoc value.            versionSpec packages merge: spec ].    aBlock value: versionSpec.    self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependecies groups: groups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"    self        addSection: sectionAttributeOrPath        repository: repositoryDescription        requiredProjects: projectList        packages: packageList        dependencies: dependecies        includes: #()        files: #()        repositories: repositories        preLoadDoIts: #()        postLoadDoIts: #()        supplyingAnswers: #()        groups: groups        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addSectionsFrom: inputVersionStringOrSymbol forBaseline: forBaseline updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    | constructor updatedSpecs projectAttributes fullVersionSpec version coll pragma imports visitedSpecs fromVersionString |    constructor := self constructor.    updatedSpecs := Set new.    visitedSpecs := Set new.    projectAttributes := project attributes.    version := project version: inputVersionStringOrSymbol.    fromVersionString := version versionString.    fullVersionSpec := version spec.    fullVersionSpec := version spec.    coll := constructor extractAllVersionPragmas at: fromVersionString ifAbsent: [ ^ nil ].    coll size > 1        ifTrue: [ self error: 'More than one pragma defining ' , fromVersionString printString ].    pragma := coll at: 1.    imports := pragma numArgs = 2        ifTrue: [ pragma argumentAt: 2 ]        ifFalse: [ #() ].    methodSpec imports: imports.    constructor extractMethodSectionsFor: fromVersionString.    constructor methodSections        do: [ :methodSection |             | versionSpec attributeList |            versionSpec := methodSection versionSpec.            attributeList := methodSection attributes.            forBaseline                ifFalse: [                     (projectAttributes includes: attributeList)                        ifTrue: [                             self                                updateVersionSpec: versionSpec                                fullVersionSpec: fullVersionSpec                                updateProjects: updateProjects                                updatePackages: updatePackages                                visited: visitedSpecs                                updated: updatedSpecs ] ].            (aBlock value: methodSection attributeOrPath value: versionSpec)                ifTrue: [ self methodSpec addMethodSection: methodSection attributePath versionSpec: versionSpec ] ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!addSymbolicSection: attribute version: versionString    self methodSpec methodSections        do: [ :methodSection |             methodSection attributes = {attribute}                ifTrue: [                     methodSection versionString: versionString.                    ^ self ] ].    self methodSpec addMethodSection: attribute versionString: versionString! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!baselineNameFrom: baseName  ^ self class baselineNameFrom: baseName! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/24/2015 08:32'!baselineNamed: baseName  | baselineName |  "Check if the class does not exist"  baselineName := self baselineNameFrom: baseName.  (Smalltalk includesKey: baselineName asSymbol)    ifFalse: [       "Create the configuration class"      self ensureMetacello.      BaselineOf        subclass: baselineName asSymbol        instanceVariableNames: ''        classVariableNames: ''        poolDictionaries: ''        category: baselineName.      MetacelloPlatform current registerPackageNamed: baselineName.      (MetacelloPlatform current globalNamed: baselineName asSymbol)        compile: 'baseline: spec <baseline>'        classified: 'baseline'	"a bit of a hack here to create an initial null basline method" ].  project := (MetacelloPlatform current globalNamed: baselineName asSymbol)    project! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!buildMapFrom: mapList for: packageList	| map |	map := Dictionary new.	mapList		do: [ :assoc | 			| pkgName pkgSpec |			pkgName := assoc key.			(packageList includes: pkgName)				ifFalse: [ self error: 'package ' , pkgName printString , ' not found in packages.' ].			map at: pkgName put: assoc value ].	^ map! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!classicCreateProjectReferenceSpec: projectBaseName  | configurationName projectReferenceProject versionString |  configurationName := self configurationNameFrom: projectBaseName.  projectReferenceProject := (MetacelloPlatform current    globalNamed: configurationName asSymbol    ifAbsent: [       self        error:          'The project with configuration ' , configurationName printString            , ' for the project ' , projectBaseName printString            , ' is not currently loaded into the image.' ])    project.  versionString := (projectReferenceProject hasVersion: #'stable')    ifTrue: [ #'stable' ]    ifFalse: [ #'bleedingEdge' ].  ^ project projectReferenceSpec    name: projectBaseName;    projectReference:        (project projectSpec            name: projectBaseName;            className: configurationName;            versionString: versionString;            yourself);    yourself! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!clearVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages	versionSpec		specListProjectDo: [ :spec | 			updateProjects				ifTrue: [ 					| fullProjectReferenceSpec fullProjectSpec |					(fullProjectReferenceSpec := fullVersionSpec packageNamed: spec name) ~~ nil						ifTrue: [ 							fullProjectSpec := fullProjectReferenceSpec projectReference.							fullProjectSpec versionString == nil								ifTrue: [ spec projectReference versionString: '' ] ] ] ]		packageDo: [ :spec | 			updatePackages				ifTrue: [ 					spec getFile ~~ nil						ifTrue: [ spec file: '' ] ] ]		groupDo: [ :ignored |  ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!commitBaselineOfMethod  | skipValidation |  skipValidation := false.  self methodSpec ifNil: [ ^ self ].  self methodSpec compileMethod.  project := project configuration class project.	"recalculate project"  [ project version: self methodSpec versionString ]    on: MetacelloSymbolicVersionDoesNotExistError    do: [ :ex |       "symbolic versions can be removed"      skipValidation := true ].  skipValidation    ifFalse: [ self validateVersion: self methodSpec versionString ].  methodSpec := nil! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!commitConfiguration: commitComment! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!commitMethod	| skipValidation |	skipValidation := false.	self methodSpec ifNil: [ ^self ].	self methodSpec compileMethod.	project := project configuration class project.	"recalculate project"	[ project version: self methodSpec versionString ]		on: MetacelloSymbolicVersionDoesNotExistError		do: [ :ex | 			"symbolic versions can be removed"			skipValidation := true ].	skipValidation		ifFalse: [ self validateVersion: self methodSpec versionString ].	methodSpec := nil! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!configurationNameFrom: baseName		^self class configurationNameFrom: baseName! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!configurationNamed: baseName  | configurationName |  "Check if the class does not exist"  configurationName := self configurationNameFrom: baseName.  (Smalltalk includesKey: configurationName asSymbol)    ifFalse: [       self ensureMetacello.	"Create the configuration class"      MetacelloPlatform current        copyClass:          (MetacelloPlatform current globalNamed: #'MetacelloConfigTemplate')        as: configurationName asSymbol        inCategory: configurationName asString.	"Create the package that has the same name"      MetacelloPlatform current registerPackageNamed: configurationName ].  project := (MetacelloPlatform current globalNamed: configurationName asSymbol)    project! !!MetacelloToolBox methodsFor: 'accessing' stamp: '9/28/2017 08:53:18'!constructor	| constructor |	constructor := MetacelloToolBoxConstructor new.	constructor configuration: project configuration class new.	^constructor! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!createBaselineOfMethod: selector inCategory: category  methodSpec := MetacelloBaselineOfMethodSpec new    project: project;    selector: selector;    category: category;    yourself! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!createConfiguration: baseName  | configurationName |  "Check if the class does not exist"  configurationName := (baseName beginsWith: 'ConfigurationOf')    ifTrue: [ baseName ]    ifFalse: [ 'ConfigurationOf' , baseName ].  (Smalltalk includesKey: configurationName asSymbol)    ifFalse: [       self ensureMetacello.	"Create the configuration class"      MetacelloPlatform current        copyClass:          (MetacelloPlatform current globalNamed: #'MetacelloConfigTemplate')        as: configurationName asSymbol        inCategory: configurationName asString.	"Create the package that has the same name"      MetacelloPlatform current registerPackageNamed: configurationName ].  ^ (MetacelloPlatform current globalNamed: configurationName asSymbol) project! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!createGroupSpec: baseName	^ (self project groupSpec)		name: baseName;		yourself! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!createPackageSpec: baseName	^ (project packageSpec)		name: baseName;		yourself! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!createProjectReferenceSpec: projectBaseName  | projectSpec |  projectSpec := (Metacello image    project: projectBaseName;    list)    detect: [ :each | true ]    ifNone: [ ^ self classicCreateProjectReferenceSpec: projectBaseName ].  ^ project projectReferenceSpec    name: projectBaseName;    projectReference: projectSpec;    yourself! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!createSymbolicVersionMethod: selector inCategory: category forVersion: versionSymbol	| constructor |	methodSpec := (MetacelloSymbolicVersionMethodSpec new)		project: project;		selector: selector;		category: category;		versionString: versionSymbol;		yourself.	constructor := self constructor.	self methodSpec methodSections: (constructor extractSymbolicVersionSpecsFor: versionSymbol) asOrderedCollection.! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!createVersion: versionString	| version  |	[ version := project version: versionString ]		on: MetacelloVersionDoesNotExistError		do: [ :ex | 			| versionSpec |			versionSpec := self createVersionSpec: versionString.			version := versionSpec createVersion.			project map == nil				ifTrue: [ project map: Dictionary new ].			project map at: versionString put: version ].	^version! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!createVersionMethod: selector inCategory: category forVersion: versionString		methodSpec := (MetacelloVersionMethodSpec new)		project: project;		selector: selector;		category: category;		versionString: versionString;		yourself.! !!MetacelloToolBox methodsFor: 'spec creation' stamp: '9/28/2017 08:53:18'!createVersionSpec: versionString	| versionSpec |	versionSpec := project versionSpec.	versionSpec versionString: versionString.	^ versionSpec! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!editVersionSpecsForImport: constructor projectAttributes: projectAttributes active: activeSection fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs    | fileSpecified encounteredPackageSpecs |    fileSpecified := Bag new.    encounteredPackageSpecs := Bag new.    constructor        methodSectionsInEvaluationOrder: projectAttributes reverse        do: [ :methodSection |             "collect packageSpec names ... interested in singletons"            methodSection versionSpec                specListProjectDo: [ :spec |  ]                packageDo: [ :spec |                     encounteredPackageSpecs add: spec name.                    (spec copy updateForSpawnMethod: spec)                        ifFalse: [ fileSpecified add: spec name ] ]                groupDo: [ :spec |  ] ].    constructor        methodSectionsInEvaluationOrder: projectAttributes reverse        do: [ :methodSection |             | versionSpec attributePath packageSpecsToDelete |            versionSpec := methodSection versionSpec.            attributePath := methodSection attributePath.            versionSpec updateForSpawnMethod: versionSpec.            packageSpecsToDelete := OrderedCollection new.            versionSpec                specListProjectDo: [ :spec | spec updateForSpawnMethod: spec ]                packageDo: [ :spec |                     encounteredPackageSpecs remove: spec name.                    (spec updateForSpawnMethod: spec)                        ifTrue: [                             "no file speced"                            ((fileSpecified includes: spec name) or: [ encounteredPackageSpecs includes: spec name ])                                ifTrue: [                                     "already specified somewhere else, need to delete this spec from version spec OR we're deleting all but first occurence"                                    packageSpecsToDelete add: spec ]                                ifFalse: [                                     "file hasn't been specified, so specify now"                                    spec file: spec name.                                    fileSpecified add: spec name ] ]                        ifFalse: [                             "file specified"                            (fileSpecified occurrencesOf: spec name) > 1                                ifTrue: [                                     "multiple specifications for file ... delete all but first occurence"                                    packageSpecsToDelete add: spec.                                    fileSpecified remove: spec name ] ] ]                groupDo: [ :spec | spec updateForSpawnMethod: spec ].            packageSpecsToDelete do: [ :spec | versionSpec deleteSpec: spec ].            activeSection                ifTrue: [                     self                        updateVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages                        visited: visitedSpecs                        updated: updatedSpecs ]                ifFalse: [                     self                        clearVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages ] ]! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!ensureMetacello	"noop for now"! !!MetacelloToolBox methodsFor: 'testing' stamp: '9/28/2017 08:53:18'!hasMethodForSymbolicVersion: versionSymbol	^(self constructor extractSymbolicVersionPragmas at: versionSymbol ifAbsent: [ ^ false ]) size > 0! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!importFrom: inputVersionStringOrSymbol projectAttributes: projectAttributes inactiveAttributes: inactiveAttributesList updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    | constructor updatedSpecs fullVersionSpec version visitedSpecs fromVersionString attributeSet |    constructor := self constructor.    updatedSpecs := Set new.    visitedSpecs := Set new.    version := project version: inputVersionStringOrSymbol.    fromVersionString := version versionString.	"resolve symbolic versions"    fullVersionSpec := version spec.    self methodSpec imports: {fromVersionString}.    constructor extractMethodSectionsFor: fromVersionString.    self        editVersionSpecsForImport: constructor        projectAttributes: projectAttributes        active: true        fullVersionSpec: fullVersionSpec        updateProjects: updateProjects        updatePackages: updatePackages        visited: visitedSpecs        updated: updatedSpecs.    attributeSet := projectAttributes.    inactiveAttributesList        do: [ :inactiveAttributes |             self                editVersionSpecsForImport: constructor                projectAttributes: inactiveAttributes                active: false                fullVersionSpec: fullVersionSpec                updateProjects: updateProjects                updatePackages: updatePackages                visited: visitedSpecs                updated: updatedSpecs.            attributeSet := attributeSet , projectAttributes ].    attributeSet := attributeSet asSet.    constructor        methodSectionsDo: [ :methodSection |             | versionSpec attributePath |            versionSpec := methodSection versionSpec.            attributePath := methodSection attributePath.            (methodSection includesAttributeFrom: attributeSet)                ifFalse: [                     versionSpec updateForSpawnMethod: versionSpec.                    versionSpec                        specListProjectDo: [ :spec | spec updateForSpawnMethod: spec ]                        packageDo: [ :spec | spec updateForSpawnMethod: spec ]                        groupDo: [ :spec | spec updateForSpawnMethod: spec ].                    self                        clearVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages ].            (aBlock value: attributePath asAttributeOrPath value: versionSpec)                ifTrue: [ self methodSpec addMethodSection: attributePath versionSpec: versionSpec ] ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!importFrom: inputVersionStringOrSymbol updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    ^ self        importFrom: inputVersionStringOrSymbol        projectAttributes: project attributes        inactiveAttributes: #()        updateProjects: updateProjects        updatePackages: updatePackages        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!imports: importList	self methodSpec imports: importList! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!methodSectionsFrom: inputVersionStringOrSymbol do: methodSectionBlock  | constructor version fromVersionString |  constructor := self constructor.  version := project version: inputVersionStringOrSymbol.  fromVersionString := version versionString.	"resolve symbolic versions"  constructor extractMethodSectionsFor: fromVersionString.  constructor methodSectionsDo: methodSectionBlock! !!MetacelloToolBox methodsFor: 'accessing' stamp: '9/28/2017 08:53:18'!methodSpec	^methodSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!modifiedPackageSpecs: versionStringOrSymbol packageSpecsDo: aBlock	| versionSpec |	versionSpec := (self project version: versionStringOrSymbol) spec.	versionSpec		projectDo: [ :ignored |  ]		packageDo: [ :packageSpec | 			| wc |			wc := packageSpec workingCopy.			wc ~~ nil				ifTrue: [ 					wc modified						ifTrue: [ aBlock value: versionSpec value: packageSpec value: wc ] ] ]		groupDo: [ :ignored |  ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EstebanLorenzano 9/29/2017 13:53'!modifyBaselineOf  | baselineClass constructor pragma baseline |  baselineClass := project configuration class.  baseline := baselineClass new.  constructor := MetacelloToolBoxBaselineConstructor new    configuration: project configuration class new;    yourself.  pragma := constructor extractBaselinePragmaFor: baselineClass.  constructor extractMethodSectionsForClass: baselineClass.  methodSpec := MetacelloBaselineOfMethodSpec new    project: project;    selector: (MetacelloPlatform current selectorForPragma: pragma);    category: (baselineClass whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: pragma));    yourself.  constructor methodSections    do: [ :methodSection | self methodSpec methodSections add: methodSection ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!modifySection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		newProjectList - collection of project base names (without ConfigurationOf prefix)		newPackageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		newGroups - collection of associations where key is the name of the group and value is the collection of group members	"    self        modifySection: sectionAttributeOrPath        sectionIndex: 1        repository: repositoryDescription        requiredProjects: newProjectList        packages: newPackageList        dependencies: dependecies        includes: includes        files: files        repositories: repositories        preLoadDoIts: preLoadDoIts        postLoadDoIts: postLoadDoIts        supplyingAnswers: supplyingAnswers        groups: newGroups        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!modifySection: sectionAttributeOrPath sectionIndex: sectionIndex repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		newProjectList - collection of project base names (without ConfigurationOf prefix)		newPackageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		newGroups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap groups packageList newGroupNames |    versionSpec := (self methodSpec        findMethodSection: sectionAttributeOrPath asMetacelloAttributePath        sectionIndex: sectionIndex) versionSpec.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    newProjectList        do: [ :projectName |             (versionSpec packages specListDetect: [ :spec | spec name = projectName ] ifNone: [  ]) == nil                ifTrue: [ versionSpec packages merge: (self createProjectReferenceSpec: projectName) ]                ifFalse: [ self error: 'Project named: ' , projectName printString , ' already exists.' ] ].    packageList := OrderedCollection new.    groups := OrderedCollection new.    newGroupNames := OrderedCollection new.    versionSpec        projectDo: [ :ignored |  ]        packageDo: [ :pkg | packageList add: pkg name ]        groupDo: [ :group |             groups add: group name -> group includes.            newGroupNames add: group name ].    newPackageList        do: [ :packageName |             (packageList includes: packageName)                ifTrue: [ self error: 'Package named: ' , packageName printString , ' already exists.' ]                ifFalse: [ packageList add: packageName ] ].    newGroups        do: [ :assoc |             (newGroupNames includes: assoc key)                ifTrue: [ self error: 'Group named: ' , assoc key printString , ' already exists.' ]                ifFalse: [ groups add: assoc ] ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    packageList        do: [ :packageName |             | spec |            (newPackageList includes: packageName)                ifTrue: [                     spec := self createPackageSpec: packageName.                    versionSpec packages merge: spec ]                ifFalse: [ spec := versionSpec packages specListDetect: [ :spc | spc name = packageName ] ].            dependencyMap                at: packageName                ifPresent: [ :dependencyList | spec setRequires: spec requires , dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec setIncludes: spec includes , includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ] ].    groups        do: [ :assoc |             | spec |            (newGroupNames includes: assoc key)                ifFalse: [                     spec := self createGroupSpec: assoc key.                    versionSpec packages merge: spec.                    spec setIncludes: spec includes , assoc value ] ].    aBlock value: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!modifySymbolicVersionMethodFor: versionSymbol	^self modifySymbolicVersionMethodFor: versionSymbol symbolicVersionSpecsDo: [:symbolicVersionSpec | true ].! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'TesterBob 10/2/2017 10:13'!modifySymbolicVersionMethodFor: versionSymbol symbolicVersionSpecsDo: aBlock    | constructor coll pragma |    constructor := self constructor.    coll := constructor extractSymbolicVersionPragmas at: versionSymbol ifAbsent: [ ^ nil ].    coll size > 1        ifTrue: [ self error: 'More than one pragma defining ' , versionSymbol printString ].    pragma := coll at: 1.    methodSpec := MetacelloSymbolicVersionMethodSpec new        project: project;        selector: (MetacelloPlatform current selectorForPragma: pragma);        category: (project configuration class whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: pragma));        versionString: versionSymbol;        yourself.    (constructor extractSymbolicVersionSpecsFor: versionSymbol)        do: [ :symbolicVersionSpec |             (aBlock value: symbolicVersionSpec)                ifTrue: [ self methodSpec addMethodSection: symbolicVersionSpec attributes versionString: symbolicVersionSpec versionString ] ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!modifyVersionMethodForVersion: inputVersionStringOrSymbol	^ self modifyVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: [ :attribute :versionSpec | true ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!modifyVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock	^ self		updateVersionMethodForVersion: inputVersionStringOrSymbol		updateProjects: false		updatePackages: false		versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'accessing' stamp: '9/28/2017 08:53:18'!project	^project! !!MetacelloToolBox methodsFor: 'accessing' stamp: '9/28/2017 08:53:18'!project: aMetacelloProject	project := aMetacelloProject! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!symbolicVersionMethod: versionSymbol	(self hasMethodForSymbolicVersion: versionSymbol)		ifTrue: [ self modifySymbolicVersionMethodFor: versionSymbol ]		ifFalse: [ 			self				createSymbolicVersionMethod: versionSymbol asString , ':'				inCategory: 'symbolic versions'				forVersion: versionSymbol ].! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EstebanLorenzano 9/29/2017 13:44'!updateVersionMethodForVersion: inputVersionStringOrSymbol projectAttributes: projectAttributes updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    | constructor updatedSpecs fullVersionSpec version coll pragma imports blessing addedSections visitedSpecs sourceVersionString keptSections |    updatedSpecs := Set new.    version := project version: inputVersionStringOrSymbol.    sourceVersionString := version versionString.	"resolve symbolic version"    blessing := version blessing.    blessing == #'release'        ifTrue: [             MetacelloCannotUpdateReleasedVersionError                signal: 'Should not update a version that has been released (resume to continue update).' ].    fullVersionSpec := version spec.    constructor := self constructor.    coll := constructor extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^ updatedSpecs ].    coll size > 1        ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].    pragma := coll at: 1.    imports := pragma numArgs = 2        ifTrue: [ pragma argumentAt: 2 ]        ifFalse: [ #() ].    methodSpec := MetacelloVersionMethodSpec new        project: project;        selector: (MetacelloPlatform current selectorForPragma: pragma);        category: (project configuration class whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma:  pragma));        versionString: sourceVersionString;        imports: imports;        yourself.    constructor extractMethodSectionsFor: sourceVersionString.    addedSections := Dictionary new.    visitedSpecs := Set new.    keptSections := IdentitySet new.    constructor        methodSectionsInEvaluationOrder: projectAttributes reverse        do: [ :methodSection |             | versionSpec |            versionSpec := methodSection versionSpec.            (blessing ~~ #'baseline' and: [ methodSection includesAttributeFrom: projectAttributes ])                ifTrue: [                     self                        updateVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages                        visited: visitedSpecs                        updated: updatedSpecs ].            (aBlock value: methodSection attributeOrPath value: versionSpec)                ifTrue: [ keptSections add: methodSection topParent ] ].    constructor methodSections        do: [ :methodSection |             (methodSection includesAttributeFrom: projectAttributes)                ifTrue: [                     (keptSections includes: methodSection)                        ifTrue: [ self methodSpec methodSections add: methodSection ] ]                ifFalse: [ self methodSpec methodSections add: methodSection ] ].    ^ updatedSpecs! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!updateVersionMethodForVersion: inputVersionStringOrSymbol updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    ^ self        updateVersionMethodForVersion: inputVersionStringOrSymbol        projectAttributes: project attributes        updateProjects: updateProjects        updatePackages: updatePackages        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: '9/28/2017 08:53:18'!updateVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock	^ self		updateVersionMethodForVersion: inputVersionStringOrSymbol		updateProjects: true		updatePackages: true		versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'private' stamp: '9/28/2017 08:53:18'!updateVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs    versionSpec        specListProjectDo: [ :spec |             (updateProjects and: [ (visitedSpecs includes: spec name) not ])                ifTrue: [                     | fullProjectSpec |                    fullProjectSpec := (fullVersionSpec packageNamed: spec name) projectReference.                    (fullProjectSpec versionString ~~ nil                        and: [ fullProjectSpec versionString ~~ #'stable' and: [ fullProjectSpec projectClass ~~ nil ] ])                        ifTrue: [                             | cv |                            cv := fullProjectSpec projectClassProject currentVersion.                            cv ~~ nil                                ifTrue: [                                     cv versionString ~= fullProjectSpec versionString                                        ifTrue: [                                             spec projectReference versionString: cv versionString.                                            updatedSpecs add: spec name ] ]                                ifFalse: [                                     "set to an empty string as a place holder, since we know we should have a version, but we are unable to figure out the version"                                    spec projectReference versionString: ''.                                    updatedSpecs add: spec name ] ] ] ]        packageDo: [ :spec |             (updatePackages and: [ (visitedSpecs includes: spec name) not ])                ifTrue: [                     spec getFile ~~ nil                        ifTrue: [                             | viName |                            spec file = ''                                ifTrue: [ spec file: spec name ].                            (viName := spec workingCopyNameFor: spec loader) ~~ nil                                ifTrue: [                                     viName ~= spec file                                        ifTrue: [                                             spec file: viName.                                            updatedSpecs add: spec name ].                                    visitedSpecs add: spec name ] ] ] ]        groupDo: [ :ignored |  ]! !!MetacelloToolBox methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateConfiguration    | issues |    issues := (MetacelloMCVersionValidator validateConfiguration: project configuration class recurse: false)        select: [ :issue | issue isCritical ].    issues notEmpty        ifTrue: [ MetacelloValidationFailure issues: issues message: 'There are critical issues in the configuration' ]! !!MetacelloToolBox methodsFor: 'validation' stamp: '9/28/2017 08:53:18'!validateVersion: versionStringOrSymbol    | issues |    issues := (MetacelloMCVersionValidator validateProject: project version: versionStringOrSymbol)        select: [ :issue | issue isError ].    issues notEmpty        ifTrue: [             MetacelloValidationFailure                issues: issues                message: 'There are error issues with version ' , versionStringOrSymbol printString ]! !!MetacelloValidationCriticalWarning methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isCriticalWarning	^true! !!MetacelloValidationCriticalWarning methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!label	^'Critical Warning'! !!MetacelloValidationError methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isError	^true! !!MetacelloValidationError methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!label	^'Error'! !!MetacelloValidationIssue class methodsFor: 'instance creation' stamp: '9/28/2017 08:54:38'!configurationClass: aClass reasonCode: aSymbol callSite: aCallSite explanation: aString	^(self new)		configurationClass: aClass;		reasonCode: aSymbol;		callSite: aCallSite;		explanation: aString;		yourself! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!callSite	^ callSite! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!callSite: anObject	callSite := anObject! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationClass	^ configurationClass! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configurationClass: aClass	configurationClass := aClass! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!explanation	^ explanation! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!explanation: aString	explanation := aString! !!MetacelloValidationIssue methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isCritical	^self isError or: [ self isCriticalWarning ]! !!MetacelloValidationIssue methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isCriticalWarning	^false! !!MetacelloValidationIssue methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isError	^false! !!MetacelloValidationIssue methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isWarning	^false! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!label	^''! !!MetacelloValidationIssue methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24'!printOn: aStream	aStream		nextPutAll: self label;		nextPut: $:;		space;		nextPutAll: self explanation.	self reasonCode ~~ #none		ifTrue: [ 			aStream				space;				nextPut: ${;				space;				nextPutAll: self reasonCode asString;				space;				nextPut: $} ].	(self configurationClass ~~ nil or: [ self callSite ~~ nil ])		ifTrue: [ 			aStream				space;				nextPut: $[;				space.			self configurationClass ~~ nil				ifTrue: [ 					aStream						nextPutAll: self configurationClass name asString;						space ].			self callSite ~~ nil				ifTrue: [ 					aStream						nextPutAll: self callSite name asString;						space ].			aStream nextPut: $] ]! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!reasonCode	reasonCode == nil ifTrue: [ reasonCode := #none ].	^ reasonCode! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!reasonCode: anObject	reasonCode := anObject! !!MetacelloValidationWarning methodsFor: 'testing' stamp: '9/28/2017 08:54:38'!isWarning	^true! !!MetacelloValidationWarning methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!label	^'Warning'! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!additions	additions ifNil: [ additions := Dictionary new ].	^ additions! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!additions: anObject	additions := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configuration	^ configuration! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!configuration: anObject	configuration := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!from	^ from! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!from: anObject	from := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!modifications	modifications ifNil: [ modifications := Dictionary new ].	^ modifications! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!modifications: anObject	modifications := anObject! !!MetacelloVersionDiffReport methodsFor: 'printing' stamp: '9/28/2017 08:54:38'!printOn: aStream	| printBlock |	printBlock := [ :pkgName :ar | 	aStream		tab: 2;		nextPutAll: pkgName asString;		cr.	aStream		tab: 3;		nextPutAll: (ar at: 1) asString printString;		nextPutAll: ' to ';		nextPutAll: (ar at: 2) asString printString;		cr ].	aStream		nextPutAll: self configuration asString;		space;		nextPutAll: from asString printString;		nextPutAll: ' to ';		nextPutAll: to asString printString;		cr.	aStream		tab;		nextPutAll: 'Additions:';		cr.	self additions keysAndValuesDo: printBlock.	aStream		tab;		nextPutAll: 'Modifications:';		cr.	self modifications keysAndValuesDo: printBlock.	aStream		tab;		nextPutAll: 'Removals:';		cr.	self removals keysAndValuesDo: printBlock! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!removals	removals ifNil: [ removals := Dictionary new ].	^ removals! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!removals: anObject	removals := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!to	^ to! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: '9/28/2017 08:54:38'!to: anObject	to := anObject! !!MetacelloVisitedPackages methodsFor: 'initialize-release' stamp: '9/28/2017 08:53:29'!initialize	groups := Set new.	packages := Set new.	projects := Set new.! !!MetacelloVisitedPackages methodsFor: 'visiting' stamp: '9/28/2017 08:53:29'!pushProject: aBlock	| oldGroups oldPackages oldProjects |	oldGroups := groups.	oldPackages := packages.	oldProjects := projects.	groups := Set new.	packages := Set new.	^aBlock ensure: [		groups := oldGroups.		packages := oldPackages.		projects := oldProjects ]! !!MetacelloVisitedPackages methodsFor: 'visiting' stamp: '9/28/2017 08:53:29'!visit: aSpec doing: aBlock	aSpec		projectDo: [:spec | 			(projects includes: spec name) ifTrue: [ ^self ].			projects add: spec name ] 		packageDo: [:spec | 			(packages includes: spec name) ifTrue: [ ^self ].			packages add: spec name ] 		groupDo: [:spec | 			(groups includes: spec name) ifTrue: [ ^self ].			groups add: spec name ].	aBlock value: aSpec! !!Object class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Create a new instance and delegate decoding to instance side.	Override only when new instance should be created directly (see implementors). "		^ self new		fromSton: stonReader;		yourself! !!Object class methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!Object class methodsFor: '*metacello-mc' stamp: '9/28/2017 08:53:29'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!Object class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonAllInstVarNames	"Override to encode my instances using a custom set of instance variables or to define their order."		^ self allInstVarNames ! !!Object class methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonName	"Override to encode my instances using a different class name.	Use symbols as class name/tag."		^ self name! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	"Decode non-variable classes from a map of their instance variables and values.	Override to customize and add a matching #toSton: (see implementors)."		self class isVariable 		ifTrue: [			stonReader error: 'custom #fromSton: implementation needed for variable/indexable class' ]		ifFalse: [			stonReader parseNamedInstVarsFor: self ]! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!isStonReference	^ false! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloIntegerLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:08'!metacelloSemanticIntegerLessThanSelf: anInteger    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:09'!metacelloSemanticStringLessThanSelf: anInteger    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:08'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloStringLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonContainSubObjects	"Return true if I contain subObjects that should be processed, false otherwise.	Overwrite when necessary. See also #stonProcessSubObjects:"		^ true! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	"Encode non-variable classes with a map of their instance variable and values.	Override to customize and add a matching #fromSton: (see implementors)."	self class isVariable 		ifTrue: [			stonWriter error: 'custom #stonOn: implementation needed for variable/indexable class' ]		ifFalse: [			stonWriter writeObject: self ]! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonPostReferenceResolution	"Hook that is called when references were resolved processing this object or one of its sub objects. This will most probably influence hash values. Override to take appropriate action."! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonProcessSubObjects: block	"Execute block to (potentially) change each of my subObjects.	In general, all instance and indexable variables are processed.	Overwrite when necessary. Not used when #stonContainSubObjects returns false."		1 to: self class instSize do: [ :each |		self instVarAt: each put: (block value: (self instVarAt: each)) ].	(self class isVariable and: [ self class isBytes not ])		ifTrue: [			1 to: self basicSize do: [ :each |				self basicAt: each put: (block value: (self basicAt: each)) ] ]! !!Object methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonShouldWriteNilInstVars	"Return true if my instance variables that are nil should be written out, 	false otherwise. Overwrite when necessary. By default, return false."		^ false! !!Object methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonForHtmlOn: aStream indent: startIndent    self writeCypressJsonOn: aStream forHtml: true indent: startIndent! !!Object methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    ^ self subclassResponsibility! !!Object methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream indent: startIndent    self writeCypressJsonOn: aStream forHtml: false indent: startIndent! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!associationClass	^ Association! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!classNameKey	^ #className! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!fromStream: readStream	^ (self reader on: readStream) next! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!fromStreamWithComments: readStream	^ (self reader on: (STONCStyleCommentsSkipStream on: readStream)) next! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!fromString: string	^ self fromStream: string readStream! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!fromStringWithComments: string	^ self fromStreamWithComments: string readStream! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!jsonWriter	^ STONWriter new			jsonMode: true;			referencePolicy: #error;			yourself! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!listClass	^ Array! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!mapClass	^ Dictionary! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!put: object asJsonOnStream: stream	(self jsonWriter on: stream) nextPut: object! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!put: object asJsonOnStreamPretty: stream	(self jsonWriter on: stream)		prettyPrint: true; 		nextPut: object! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!put: object onStream: stream	(self writer on: stream) nextPut: object! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!put: object onStreamPretty: stream	(self writer on: stream)		prettyPrint: true; 		nextPut: object! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!reader	^ STONReader new! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!toJsonString: object	^ String streamContents: [ :stream |		self put: object asJsonOnStream: stream ]! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!toJsonStringPretty: object	^ String streamContents: [ :stream |		self put: object asJsonOnStreamPretty: stream ]! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!toString: object	^ String streamContents: [ :stream |		self put: object onStream: stream ]! !!STON class methodsFor: 'convencience' stamp: '5/7/2020 21:03:38'!toStringPretty: object	^ String streamContents: [ :stream |		self put: object onStreamPretty: stream ]! !!STON class methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!writer	^ STONWriter new! !!STONCStyleCommentsSkipStream class methodsFor: 'instance creation' stamp: '5/7/2020 21:03:38'!on: readStream	^ self new		on: readStream;		yourself! !!STONCStyleCommentsSkipStream methodsFor: 'testing' stamp: '5/7/2020 21:03:38'!atEnd	^ self peek isNil! !!STONCStyleCommentsSkipStream methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!close	stream close! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!collectionSpecies	^ String! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!consumeComment	stream peek = $/ ifTrue: [ self consumeToEOL ].	stream peek = $* ifTrue: [ self consumeToCommentEnd ]! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!consumeToCommentEnd	[ stream atEnd or: [ stream next = $* and: [ stream peekFor: $/ ] ] ] whileFalse! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!consumeToEOL	| eol char |	eol := false.	[ eol ] whileFalse: [ 		char := stream next.		(char isNil or: [ char = Character lf ])			ifTrue: [ eol := true ]			ifFalse: [ 				char = Character cr					ifTrue: [ 						eol := true.						stream peekFor: Character lf ] ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!escape	"Return true when we previously read a backslash escape inside a string, 	so that the next string delimiter should be returned as is"		^ escape = true! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!handleStringDelimiter: char	self escape		ifTrue: [ escape := false ]		ifFalse: [ 			self insideString				ifTrue: [ 					char = delimiter						ifTrue: [ delimiter := nil ] ]				ifFalse: [ delimiter := char ] ].	^ char! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!insideString	"Return true when we are currently inside a string where comments should be ignored."		^ (delimiter = $') | (delimiter = $")! !!STONCStyleCommentsSkipStream methodsFor: 'testing' stamp: '5/7/2020 21:03:38'!isBinary	^ false! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!next	^ peekedCharacter		ifNil: [ 			stream atEnd				ifFalse: [ self nextNonCommentChar ] ]		ifNotNil: [ | character |			character := peekedCharacter.			peekedCharacter := nil.			character ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!next: requestedCount 	"Read requestedCount elements into new collection and return it,	 it could be that less elements were available"	^ self 		next: requestedCount 		into: (self collectionSpecies new: requestedCount)! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!next: requestedCount into: collection	"Read requestedCount elements into collection,	returning a copy if less elements are available"		^ self		next: requestedCount		into: collection		startingAt: 1! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!next: requestedCount into: collection startingAt: offset	"Read requestedCount elements into collection starting at offset,	returning a copy if less elements are available"		| readCount |	readCount := self 		readInto: collection 		startingAt: offset 		count: requestedCount.	^ requestedCount = readCount		ifTrue: [ collection ]		ifFalse: [ collection copyFrom: 1 to: offset + readCount - 1 ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!nextLine	"Read a CR, LF or CRLF terminated line, returning the contents of the line without the EOL. Return nil when the receiver is #atEnd."		self atEnd ifTrue: [ ^ nil ].	^ self collectionSpecies streamContents: [ :out | | eol char |		eol := false.		[ eol ] whileFalse: [ 			char := self next.			(char isNil or: [ char = Character lf ])				ifTrue: [ eol := true ]				ifFalse: [ 					char = Character cr 						ifTrue: [ eol := true. self peekFor: Character lf ]						ifFalse: [  out nextPut: char ] ] ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: '5/7/2020 21:03:38'!nextNonCommentChar	| char |	char := stream next.	(self insideString and: [ char = $\ ])		ifTrue: [ 			escape := true. 			^ char ].	(char = $') | (char = $")		ifTrue: [ 			^ self handleStringDelimiter: char ].	escape := false. 	^ (char = $/ and: [ self insideString not and: [ (stream peek = $/) | (stream peek = $*) ] ])		ifTrue: [ 			self consumeComment.			stream next ]		ifFalse: [ char ]! !!STONCStyleCommentsSkipStream methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!on: readStream	stream := readStream! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!peek	^ peekedCharacter		ifNil: [			stream atEnd				ifFalse: [ 					peekedCharacter := self nextNonCommentChar ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!peekFor: object	^ self peek = object		ifTrue: [ 			self next.			true ]		ifFalse: [ false ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!position	^ stream position! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!readInto: collection startingAt: offset count: requestedCount 	"Read count elements and place them in collection starting at offset.	Return the number of elements actually read."		^ peekedCharacter 		ifNil: [			0 to: requestedCount - 1 do: [ :count | | object |				(object := self nextNonCommentChar) ifNil: [ ^ count ].  				collection at: offset + count put: object ].			^ requestedCount ]		ifNotNil: [ 			collection at: offset put: peekedCharacter.			peekedCharacter := nil.			(self 				readInto: collection 				startingAt: offset + 1				count: requestedCount - 1) + 1 ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!skip: count	count timesRepeat: [ self next ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!upTo: anObject 		^ self collectionSpecies 		streamContents: [ :out | | element |			[ self atEnd or: [ (element := self next) = anObject ] ] whileFalse: [ 				out nextPut: element ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!upToEnd	^ self collectionSpecies		streamContents: [ :collectionStream | 			[ self atEnd ] whileFalse: [ collectionStream nextPut: self next ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!wrappedStream	^ stream! !!STONJSON class methodsFor: 'convenience' stamp: '5/7/2020 21:03:38'!fromStream: stream	^ STON fromStream: stream! !!STONJSON class methodsFor: 'convenience' stamp: '5/7/2020 21:03:38'!fromString: string	^ STON fromString: string! !!STONJSON class methodsFor: 'convenience' stamp: '5/7/2020 21:03:38'!put: object onStream: stream	STON put: object asJsonOnStream: stream! !!STONJSON class methodsFor: 'convenience' stamp: '5/7/2020 21:03:38'!put: object onStreamPretty: stream	STON put: object asJsonOnStreamPretty: stream! !!STONJSON class methodsFor: 'convenience' stamp: '5/7/2020 21:03:38'!toString: object	^ STON toJsonString: object! !!STONJSON class methodsFor: 'convenience' stamp: '5/7/2020 21:03:38'!toStringPretty: object	^ STON toJsonStringPretty: object! !!STONReader class methodsFor: 'instance creation' stamp: '5/7/2020 21:03:38'!on: readStream	^ self new		on: readStream;		yourself! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!acceptUnknownClasses: boolean	acceptUnknownClasses := boolean! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!allowComplexMapKeys: boolean	"This is a no-op, this used to be an option, but it is now always enabled"! !!STONReader methodsFor: 'testing' stamp: '5/7/2020 21:03:38'!atEnd	^ readStream atEnd! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ readStream next ]! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!convertNewLines: boolean	"When true, any newline CR, LF or CRLF read unescaped inside strings or symbols 	will be converted to the newline convention chosen, see #newLine:	The default is false, not doing any convertions."		convertNewLines := boolean! !!STONReader methodsFor: 'error handling' stamp: '5/7/2020 21:03:38'!error: aString	| streamPosition |	"Remain compatible with streams that don't understand #position"	streamPosition := [ readStream position ]		on: MessageNotUnderstood do: [ nil ].	^ STONReaderError signal: aString streamPosition: streamPosition! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!initialize	super initialize.	objects := IdentityDictionary new.	classes := IdentityDictionary new.	acceptUnknownClasses := convertNewLines := false.	newLine := String cr.	unresolvedReferences := 0! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!isClassChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_' includes: char! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!isClassStartChar: char	^ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' includes: char! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!isSimpleSymbolChar: char	^char isLetter or: ['0123456789-_./' includes: char]! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!lookupClass: name	"name is a symbol at this point"	Smalltalk globals 		at: name 		ifPresent: [ :class | ^ class ].	"note that classes is an identity dictionary"	^ classes 		at: name 		ifAbsentPut: [			Object allSubclasses 				detect: [ :class | class isMeta not and: [ class stonName = name ]  ]				ifNone: [ NotFound signalFor: name ] ]	! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!newLine: string	"Set the newline convention to be used when converting newlines, see #convertNewLines"		newLine := string ! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!newReference	| index reference |	index := objects size + 1.	reference := STONReference index: index.	objects at: index put: reference.	^ reference! !!STONReader methodsFor: 'public' stamp: '5/7/2020 21:03:38'!next	| object |	self consumeWhitespace.	object := self parseValue.	unresolvedReferences > 0		ifTrue: [ self processSubObjectsOf: object ].	unresolvedReferences = 0		ifFalse: [ self error: 'Inconsistent reference resolution' ].	^ object! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!on: aReadStream	readStream := aReadStream! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!optimizeForLargeStructures	self class environment		at: #FLLargeIdentityDictionary		ifPresent: [ :identityDictionaryClass | objects := identityDictionaryClass new ]! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseCharacter	| char |	^ (char := readStream next) = $\		ifTrue: [ self parseEscapedCharacter ]		ifFalse: [ char ]! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseCharacterConvertingNewLinesOn: writeStream	| char |	(char := readStream next) = $\		ifTrue: [ writeStream nextPut: self parseEscapedCharacter ]		ifFalse: [ 			char = Character lf 				ifTrue: [ writeStream nextPutAll: newLine ]				ifFalse: [ 					char = Character cr 						ifTrue: [ 							readStream peekFor: Character lf.							writeStream nextPutAll: newLine ]						ifFalse: [ writeStream nextPut: char ] ] ]! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseCharacterHexDigit	| digit |	readStream atEnd ifFalse: [ 		digit := readStream next asInteger.		(digit between: "$0" 48 and: "$9" 57)			ifTrue: [ ^ digit - 48 ].		(digit between: "$A" 65 and: "$F" 70)			ifTrue: [ ^ digit - 55 ].		(digit between: "$a" 97 and: "$f" 102)			ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseClass	| className |	className := self stringStreamContents: [ :stream |		[ readStream atEnd not and: [ self isClassChar: readStream peek ] ] whileTrue: [ 			stream nextPut: readStream next ] ].	self consumeWhitespace.	^ self lookupClass: className asSymbol	! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			readStream next.			(readStream peek = $i)				ifTrue: [					self match: 'il' do: [ block value: nil ] ].			(readStream peek = $u)				ifTrue: [					self match: 'ull' do: [ block value: nil ] ] ]		! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseEscapedCharacter	| char |	char := readStream next.	(#($' $" $/ $\) includes: char)		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char).	^ char! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseList	| reference array |	reference := self newReference.	array := STON listClass streamContents: [ :stream |		self parseListDo: [ :each | stream nextPut: each ] ].	self setReference: reference to: array.	^ array! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseListDo: block	| index |	self expectChar: $[.	(self matchChar: $]) ifTrue: [ ^ self ]. "short cut for empty lists"	index := 1.	[ readStream atEnd ] whileFalse: [		block cull: self parseValue cull: index.		(self matchChar: $]) ifTrue: [ ^ self ].		index := index + 1.		self expectChar: $, ].	self error: 'end of list expected'! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseListSingleton	| value |	value := nil.	self parseListDo: [ :each :index |		index = 1 ifTrue: [ value := each ] ].	^ value! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseMap	| map |	map := STON mapClass new.	self storeReference: map.	self parseMapDo: [ :key :value |		map at: key put: value ].	^ map! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseMapDo: block	self expectChar: ${.	(self matchChar: $}) ifTrue: [ ^ self ]. "short cut for empty maps"	[ readStream atEnd ] whileFalse: [ | name value |		name := self parseSimpleValue.		self expectChar: $:.		value := self parseValue.		block value: name value: value.		"The above is a more efficient way to say 'self parseValue' and using the returned association"		(self matchChar: $}) ifTrue: [ ^ self ].		self expectChar: $, ].	self error: 'end of map expected'! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseMapOrListRepresentation	"Parse either a map or list to be used as a representation, not considering it as a referenceable object"	readStream atEnd 		ifFalse: [ 			readStream peek = ${				ifTrue: [ | map |					map := STON mapClass new.					self parseMapDo: [ :key :value |						map at: key put: value ].					^ map ].			readStream peek = $[				ifTrue: [ 					^ STON listClass streamContents: [ :stream |						self parseListDo: [ :each | stream nextPut: each ] ] ] ].	self error: 'invalid input'! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseNamedInstVarsFor: anObject	self parseMapDo: [ :instVarName :value |		anObject instVarNamed: instVarName asString put: value ]! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $/)		ifTrue: [ 			number := Fraction numerator: number denominator: self parseNumberInteger.			(readStream peekFor: $s)				ifTrue: [ number := ScaledDecimal newFromNumber: number scale: self parseNumberInteger ] ]		ifFalse: [ 			(readStream peekFor: $.)				ifTrue: [ number := number + self parseNumberFraction ].			((readStream peekFor: $e) or: [ readStream peekFor: $E ])				ifTrue: [ number := number * self parseNumberExponent ] ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	^ 10 raisedTo: number! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] whileTrue: [		number := 10 * number + readStream next digitValue.		power := power * 10.0 ].	^ number / power! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseNumberInteger	| number |	number := 0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] whileTrue: [ 		number := 10 * number + readStream next digitValue ].	^ number! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseObject	| targetClass reference object |	[		reference := self newReference.		targetClass := self parseClass.		object := targetClass fromSton: self .		self setReference: reference to: object ]		on: NotFound 		do: [ :notFound |			acceptUnknownClasses 				ifTrue: [ 					object := STON mapClass new.					self storeReference: object.					self parseMapDo: [ :key :value |						object at: key put: value ].					object at: STON classNameKey put: notFound object ]				ifFalse: [ self error: 'Cannot resolve class named ', notFound object printString ] ].	^ object! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseReference	| index |	self expectChar: $@.	index := self parseNumberInteger.	self consumeWhitespace.	unresolvedReferences := unresolvedReferences + 1.	^ STONReference index: index! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseSimpleValue	| char |	readStream atEnd ifFalse: [ 		(self isClassStartChar: (char := readStream peek)) 			ifTrue: [ ^ self parseObject ].		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		(char = $' or: [ char = $" ])			ifTrue: [ ^ self parseString ].		char = $#			ifTrue: [ ^ self parseSymbol ].		char = $@			ifTrue: [ ^ self parseReference ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input'! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseString	^ self parseStringInternal! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseStringInternal	| result delimiter |	delimiter := readStream next.	(delimiter = $' or: [ delimiter = $" ])		ifFalse: [ self error: ''' or " expected' ].	result := self		stringStreamContents: [ :stream | 			convertNewLines				ifTrue: [ 					[ readStream atEnd or: [ readStream peek = delimiter ] ] 						whileFalse: [ self parseCharacterConvertingNewLinesOn: stream ] ]				ifFalse: [ 					[ readStream atEnd or: [ readStream peek = delimiter ] ] 						whileFalse: [ stream nextPut: self parseCharacter ] ] ].	self expectChar: delimiter.	^ result! !!STONReader methodsFor: 'parsing-internal' stamp: '5/7/2020 21:03:38'!parseSymbol	| string |	self expectChar: $#.	readStream peek = $'		ifTrue: [ ^ self parseStringInternal asSymbol ].	string := self stringStreamContents: [ :stream |		[ readStream atEnd not and: [ self isSimpleSymbolChar: readStream peek ] ] whileTrue: [			stream nextPut: readStream next ] ].	string isEmpty		ifFalse: [ 			self consumeWhitespace.			^ string asSymbol ].	self error: 'unexpected input'! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!STONReader methodsFor: 'parsing' stamp: '5/7/2020 21:03:38'!parseValue	| value |	value := self parseSimpleValue.	^ (self matchChar: $:)		ifTrue: [ STON associationClass key: value value: self parseValue ]		ifFalse: [ value ]! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!processSubObjectsOf: object	| unresolvedReferencesCount |	unresolvedReferencesCount := unresolvedReferences.	object stonProcessSubObjects: [ :each | 		each isStonReference			ifTrue: [ self resolveReference: each ]			ifFalse: [ 				each stonContainSubObjects					ifTrue: [ self processSubObjectsOf: each ]					ifFalse: [ each ] ] ].	unresolvedReferencesCount > unresolvedReferences		ifTrue: [ object stonPostReferenceResolution ].	^ object! !!STONReader methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!reset	unresolvedReferences := 0.	objects removeAll! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!resolveReference: reference	unresolvedReferences := unresolvedReferences - 1.	^ self resolveReferenceIndex: reference index! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!resolveReferenceIndex: index	^ objects at: index! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!setReference: reference to: object	objects at: reference index put: object! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!storeReference: object	| index |	index := objects size + 1.	objects at: index put: object.	^ index! !!STONReader methodsFor: 'private' stamp: '5/7/2020 21:03:38'!stringStreamContents: block	stringStream ifNil: [ 		stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!STONReference class methodsFor: 'instance creation' stamp: '5/7/2020 21:03:38'!index: integer	^ self new		index: integer;		yourself! !!STONReference methodsFor: 'comparing' stamp: '5/7/2020 21:03:38'!= anObject	^ self class == anObject class and: [ self index = anObject index ]! !!STONReference methodsFor: 'comparing' stamp: '5/7/2020 21:03:38'!hash	^ index hash! !!STONReference methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!index	^ index! !!STONReference methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!index: integer	index := integer! !!STONReference methodsFor: 'testing' stamp: '5/7/2020 21:03:38'!isStonReference	^ true! !!STONReference methodsFor: 'printing' stamp: '5/7/2020 21:03:38'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: index; nextPut: $)! !!STONListWriter methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!add: anObject	first ifTrue: [ first := false ] ifFalse: [ writer listElementSeparator ].	writer nextPut: anObject! !!STONShortListWriter methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!add: anObject	first ifTrue: [ first := false ] ifFalse: [ writer shortListElementSeparator ].	writer nextPut: anObject! !!STONMapWriter methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!at: key put: value	first ifTrue: [ first := false ] ifFalse: [ writer mapElementSeparator ].	writer encodeKey: key value: value! !!STONStreamWriter class methodsFor: 'instance creation' stamp: '5/7/2020 21:03:38'!on: stonWriter	^ self new		on: stonWriter;		yourself! !!STONStreamWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!initialize	super initialize.	first := true! !!STONStreamWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!on: stonWriter	writer := stonWriter! !!STONWriter class methodsFor: 'class initialization' stamp: '5/7/2020 21:03:38'!initialize	"Modification timestamp 20170131"		self initializeSTONCharacters.	self initializeSTONSimpleSymbolCharacters! !!STONWriter class methodsFor: 'class initialization' stamp: '5/7/2020 21:03:38'!initializeSTONCharacters	| escapes |	STONCharacters := Array new: 127.	32 to: 126 do: [ :each | 		STONCharacters at: each + 1 put: #pass ].	"This is the minimal STON set of named escapes"	escapes := #( 8 '\b' 9 '\t' 10 '\n' 12 '\f' 13 '\r' 39 '\''' 92 '\\' ).	escapes pairsDo: [ :code :escape | 		STONCharacters at: code + 1 put: escape ]! !!STONWriter class methodsFor: 'class initialization' stamp: '5/7/2020 21:03:38'!initializeSTONSimpleSymbolCharacters	"STONSimpleSymbolCharacters asArray collectWithIndex: [ :each :index |		each isZero ifTrue: [ (index - 1) asCharacter ] ]."			STONSimpleSymbolCharacters := ByteArray new: 256 withAll: 1.	1 to: 256 do: [ :each | | char |		char := (each - 1) asCharacter.		(self isSimpleSymbolChar: char)			ifTrue: [ 				STONSimpleSymbolCharacters at: each put: 0 ] ]! !!STONWriter class methodsFor: 'private' stamp: '5/7/2020 21:03:38'!isSimpleSymbolChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_./' includes: char! !!STONWriter class methodsFor: 'instance creation' stamp: '5/7/2020 21:03:38'!on: writeStream	^ self new		on: writeStream;		yourself! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!asciiOnly: boolean	asciiOnly := boolean! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!close	writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!encodeCharacter: char	| code encoding |	"STONCharacters contains for the lower 127 characters (codes 0 to 126) either nil (unknown), 	#pass (output as is, clean ASCII characters) or a full escape string"	((code := char codePoint) < 127 and: [ (encoding := self stonCharacters at: code + 1) notNil ])		ifTrue: [ 			(encoding = #pass or: [ jsonMode and: [ char = $' ] ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ writeStream nextPutAll: encoding ] ]		ifFalse: [			"always escape Latin1 C1 controls, or when asciiOnly is true" 			(code > 16r9F and: [ asciiOnly not ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ self escapeUnicode: code ] ]! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!encodeKey: key value: value	(jsonMode and: [ key isString not ])		ifTrue: [ self error: 'JSON key names in objects must be strings' ].	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!encodeList: elements	writeStream nextPut: $[.	elements isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				self newlineIndent.				elements 					do: [ :each | self nextPut: each ]					separatedBy: [ self listElementSeparator ] ].			self newlineIndent ].	writeStream nextPut: $]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!encodeMap: pairs	| first |	first := true.	writeStream nextPut: ${.	pairs isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				self newlineIndent.				pairs keysAndValuesDo: [ :key :value |					first 						ifTrue: [ first := false ] 						ifFalse: [ self mapElementSeparator ].					self encodeKey: key value: value ] ].			self newlineIndent ].	writeStream nextPut: $}! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!encodeString: string	writeStream nextPut: (jsonMode ifTrue: [ $" ] ifFalse: [ $' ]).	keepNewLines		ifTrue: [ 			self encodeStringKeepingNewLines: string ]		ifFalse: [ 			string do: [ :each | self encodeCharacter: each ] ].	writeStream nextPut: (jsonMode ifTrue: [ $" ] ifFalse: [ $' ])! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!encodeStringKeepingNewLines: string	| input char |	input := string readStream.	[ input atEnd ]		whileFalse: [ 			char := input next.			char = Character lf				ifTrue: [ writeStream nextPutAll: newLine ]				ifFalse: [ 					char = Character cr						ifTrue: [ 							input peekFor: Character lf.							writeStream nextPutAll: newLine ]						ifFalse: [ self encodeCharacter: char ] ] ]! !!STONWriter methodsFor: 'error handling' stamp: '5/7/2020 21:03:38'!error: aString	^ STONWriterError signal: aString! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!escape: char with: anObject	"Instruct me to escape char with object, either a replacement string or #pass"		"self escape: $/ with: '\/'."		self assert: (anObject isString | (anObject == #pass)).	self assert: char isOctetCharacter.	self writeableStonCharacters at: char codePoint + 1 put: anObject! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!initialize	super initialize.	stonCharacters := STONCharacters.	prettyPrint := false.	newLine := String cr.	level := 0.	referencePolicy := #normal.	jsonMode := keepNewLines := asciiOnly := false.	objects := IdentityDictionary new! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!isSimpleSymbol: symbol	(symbol isEmpty or: [ symbol isWideString ]) 		ifTrue: [ ^ false ].	^ (symbol class 		findFirstInString: symbol 		inSet: STONSimpleSymbolCharacters 		startingAt: 1) = 0! !!STONWriter methodsFor: 'accessing' stamp: '5/7/2020 21:03:38'!jsonMode	^ jsonMode ! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!jsonMode: boolean	(jsonMode := boolean)		ifTrue: [ 			self				escape: $' with: #pass;				escape: $" with: '\"' ]		ifFalse: [ 			self				escape: $" with: #pass;				escape: $' with: '\''' ]! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!keepNewLines: boolean	"If true, any newline CR, LF or CRLF inside strings or symbols will not be escaped	but will instead be converted to the newline convention chosen, see #newLine:	The default is false, where CR, LF or CRLF will be enscaped unchanged."		keepNewLines := boolean! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!newLine: string	"The sequence to use when ending a line, either CR, LF or CRLF"		newLine := string! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!newlineIndent	prettyPrint ifTrue: [ 		writeStream nextPutAll: newLine.		level timesRepeat: [ writeStream tab ] ]! !!STONWriter methodsFor: 'public' stamp: '5/7/2020 21:03:38'!nextPut: anObject	anObject stonOn: self! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!on: aWriteStream	writeStream := aWriteStream! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!optimizeForLargeStructures	self class environment		at: #FLLargeIdentityDictionary		ifPresent: [ :identityDictionaryClass | objects := identityDictionaryClass new ].! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!prettyPrint: boolean	prettyPrint := boolean! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!prettyPrintSpace	prettyPrint ifTrue: [ writeStream space ]! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!referencePolicy: policy	self assert: ( #(#normal #ignore #error) includes: policy ).	referencePolicy := policy! !!STONWriter methodsFor: 'initialize-release' stamp: '5/7/2020 21:03:38'!reset	objects removeAll! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!shortListElementSeparator	writeStream nextPut: $,.	self prettyPrintSpace! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!stonCharacters	^ stonCharacters ifNil: [ stonCharacters := STONCharacters ]! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!with: object do: block	| index |	referencePolicy = #ignore 		ifTrue: [ ^ block value ].	(index := objects at: object ifAbsent: [ nil ]) notNil		ifTrue: [			referencePolicy = #error				ifTrue: [ ^ self error: 'shared reference detected' ].			self writeReference: index ]		ifFalse: [			index := objects size + 1.			objects at: object put: index.			block value ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeAssociation: association	jsonMode		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self 		encodeKey: association key 		value: association value! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeBoolean: boolean	writeStream print: boolean! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeFloat: float	writeStream print: float! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeFraction: fraction	jsonMode		ifTrue: [ self writeFloat: fraction asFloat ]		ifFalse: [ writeStream				print: fraction numerator;				nextPut: $/;				print: fraction denominator ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeInteger: integer	writeStream print: integer! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeList: collection	self with: collection do: [ 		self encodeList: collection ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeMap: hashedCollection	self with: hashedCollection do: [ 		self encodeMap: hashedCollection ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeNull	jsonMode		ifTrue: [ writeStream nextPutAll: 'null' ]		ifFalse: [ writeStream print: nil ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: anObject	| instanceVariableNames |	(instanceVariableNames := anObject class stonAllInstVarNames) isEmpty		ifTrue: [ 			self writeObject: anObject do: [ self encodeMap: #() ] ]		ifFalse: [ 			self writeObject: anObject streamMap: [ :dictionary | 				instanceVariableNames do: [ :each | 					(anObject instVarNamed: each)						ifNotNil: [ :value | 							dictionary at: each asSymbol put: value ]						ifNil: [ 							anObject stonShouldWriteNilInstVars 								ifTrue: [ dictionary at: each asSymbol put: nil ] ] ] ] ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: anObject do: block	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self with: anObject do: [		writeStream nextPutAll: anObject class stonName.		self prettyPrintSpace.		block value ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: object listSingleton: element	self writeObject: object do: [		writeStream nextPut: $[.		self 			prettyPrintSpace;			nextPut: element;			prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: anObject named: stonName do: block	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self with: anObject do: [		writeStream nextPutAll: stonName.		self prettyPrintSpace.		block value ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: object named: stonName listSingleton: element	self writeObject: object named: stonName do: [		writeStream nextPut: $[.		self 			prettyPrintSpace;			nextPut: element;			prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: object streamList: block	self writeObject: object do: [ | listWriter |		listWriter := STONListWriter on: self.		writeStream nextPut: $[.		self indentedDo: [			self newlineIndent.			block value: listWriter ].		self newlineIndent.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: object streamMap: block	self writeObject: object do: [ | mapWriter |		mapWriter := STONMapWriter on: self.		writeStream nextPut: ${.		self indentedDo: [			self newlineIndent.			block value: mapWriter ].		self newlineIndent.		writeStream nextPut: $} ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeObject: object streamShortList: block	self writeObject: object do: [ | listWriter |		listWriter := STONShortListWriter on: self.		writeStream nextPut: $[.		self indentedDo: [			self prettyPrintSpace.			block value: listWriter ].		self prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeReference: index	writeStream		nextPut: $@;		print: index! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeScaledDecimal: scaledDecimal	jsonMode		ifTrue: [ self writeFloat: scaledDecimal asFloat ]		ifFalse: [ writeStream				print: scaledDecimal numerator;				nextPut: $/;				print: scaledDecimal denominator;				nextPut: $s;				print: scaledDecimal scale ]! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeString: string	self encodeString: string! !!STONWriter methodsFor: 'writing' stamp: '5/7/2020 21:03:38'!writeSymbol: symbol	jsonMode		ifTrue: [			self writeString: symbol ]		ifFalse: [			writeStream nextPut: $#.			(self isSimpleSymbol: symbol)				ifTrue: [					writeStream nextPutAll: symbol ]				ifFalse: [					self encodeString: symbol ] ]! !!STONWriter methodsFor: 'private' stamp: '5/7/2020 21:03:38'!writeableStonCharacters	^ self stonCharacters == STONCharacters		ifTrue: [ stonCharacters := stonCharacters copy ]		ifFalse: [ stonCharacters ]! !!Point methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	stonReader parseListDo: [ :each :index |		index = 1 ifTrue: [ x := each ].		index = 2 ifTrue: [ y := each ] ]! !!Point methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeObject: self streamShortList: [ :array |		array add: x; add: y ]! !"Metacello-Base"!"Metacello-Core"!"MonticelloFileTree-Core"!"MonticelloFileTree-FileDirectory-Utilities"!"STON-Text support"!"Metacello-FileTree"!"Gofer-Core"!"STON-Core"!"Metacello-MC"!"Metacello-GitBasedRepository"!"Metacello-Cypress"!"Metacello-ToolBox"!"Metacello-Platform"!"Metacello-GitHub"!"Metacello-Help"!"Metacello-Bitbucket"!| loader |((Smalltalk globals includesKey: #MetacelloStub) and: [(Smalltalk at: #Metacello ifAbsent: [nil]) = (Smalltalk at: #MetacelloStub)]) ifTrue: [Smalltalk globals removeKey: #Metacello].loader := MCVersionLoader new.loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-Base.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-Core.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'MonticelloFileTree-Core.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'MonticelloFileTree-FileDirectory-Utilities.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'STON-Text support.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-FileTree.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Gofer-Core.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'STON-Core.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-MC.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-GitBasedRepository.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-Cypress.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-ToolBox.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-Platform.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-GitHub.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-Help.mcz') contentStream).loader addVersion: (MCMczReader versionFromStream: (self memberNamed: 'Metacello-Bitbucket.mcz') contentStream).loader load.!----End fileIn of a stream----!----QUIT----{29 October 2023 . 6:13:50 am} mine.image priorSource: 31314!----STARTUP----{29 November 2023 . 12:31:52 am} as C:\Users\1\Desktop\Squeak\mine.image!----QUIT----{29 November 2023 . 12:31:57 am} mine.image priorSource: 1158398!